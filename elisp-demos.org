#+TITLE: Elisp API Demos
#+PROPERTY: header-args:elisp :results pp :exports both :eval never-export

* %

#+BEGIN_SRC elisp
(% 9 4)
#+END_SRC

#+RESULTS:
: 1

* *

#+BEGIN_SRC elisp
(* 2 3)
#+END_SRC

#+RESULTS:
: 6

* +

#+BEGIN_SRC elisp
(+ 1 2 3)
#+END_SRC

#+RESULTS:
: 6

* -

#+BEGIN_SRC elisp
(- 3 1)
#+END_SRC

#+RESULTS:
: 2

* -->

#+BEGIN_SRC elisp
(--> "def" (concat "abc" it "ghi") (upcase it))
#+END_SRC

#+RESULTS:
: "ABCDEFGHI"

* --all?

#+BEGIN_SRC elisp
(--all? (= 0 (% it 2)) '(2 4 6))
#+END_SRC

#+RESULTS:
: t

* --annotate

#+BEGIN_SRC elisp
(--annotate (< 1 it) '(0 1 2 3))
#+END_SRC

#+RESULTS:
: ((nil . 0)
:  (nil . 1)
:  (t . 2)
:  (t . 3))

* --any?

#+BEGIN_SRC elisp
(--any? (> it 3) '(1 2 3 4))
#+END_SRC

#+RESULTS:
: t

* --count

#+BEGIN_SRC elisp
(--count (< it 4) '(1 2 3 4))
#+END_SRC

#+RESULTS:
: 3

* --dotimes

#+BEGIN_SRC elisp :results output
(--dotimes 3 (princ it))
#+END_SRC

#+RESULTS:
: "012"

* --drop-while

#+BEGIN_SRC elisp
(--drop-while (< it 4) '(1 2 3 4 3 2 1))
#+END_SRC

#+RESULTS:
: (4 3 2 1)

* --filter

#+BEGIN_SRC elisp
(--filter (= 0 (% it 2)) '(1 2 3 4))
#+END_SRC

#+RESULTS:
: (2 4)

* --find-index

#+BEGIN_SRC elisp
(--find-index (< 5 it) '(2 4 1 6 3 3 5 8))
#+END_SRC

#+RESULTS:
: 3

* --find-indices

#+BEGIN_SRC elisp
(--find-indices (zerop (% it 2)) '(1 2 3 4))
#+END_SRC

#+RESULTS:
: (1 3)

* --find-last-index

#+BEGIN_SRC elisp
(--find-last-index (< 5 it) '(2 7 1 6 3 8 5 2))
#+END_SRC

#+RESULTS:
: 5

* --fix

#+BEGIN_SRC elisp
(--fix (if (zerop it)
           it
         (1- it))
       5)
#+END_SRC

#+RESULTS:
: 0

* --if-let

#+BEGIN_SRC elisp
(--if-let (cl-evenp 4)
    it
  nil)
#+END_SRC

#+RESULTS:
: t

* --iterate

#+BEGIN_SRC elisp
(--iterate (* it it) 2 5)
#+END_SRC

#+RESULTS:
: (2 4 16 256 65536)

* --keep

#+BEGIN_SRC elisp
(--keep (and (cl-evenp it) (* it it))
        '(1 2 3 4))
#+END_SRC

#+RESULTS:
: (4 16)

* --last

#+BEGIN_SRC elisp
(--last (> (length it) 3) '("a" "looong" "word" "and" "short" "one"))
#+END_SRC

#+RESULTS:
: "short"

* --map

#+BEGIN_SRC elisp
(--map (* it it) '(1 2 3 4))
#+END_SRC

#+RESULTS:
: (1 4 9 16)

* --map-first

#+BEGIN_SRC elisp
(--map-first (> it 2) (* it it) '(1 2 3 4))
#+END_SRC

#+RESULTS:
: (1 2 9 4)

* --map-indexed

#+BEGIN_SRC elisp
(--map-indexed (cons it-index it) '(a b c d))
#+END_SRC

#+RESULTS:
: ((0 . a)
:  (1 . b)
:  (2 . c)
:  (3 . d))

* --map-last

#+BEGIN_SRC elisp
(--map-last (> it 2) (* it it) '(1 2 3 4))
#+END_SRC

#+RESULTS:
: (1 2 3 16)

* --map-when

#+BEGIN_SRC elisp
(--map-when (numberp it) (* it it) '(a b 1 2 3))
#+END_SRC

#+RESULTS:
: (a b 1 4 9)

* --mapcat

#+BEGIN_SRC elisp
(--mapcat
 (list (car it) (cdr it))
 '((x . 1) (y . 2) (z . 3)))
#+END_SRC

#+RESULTS:
: (x 1 y 2 z 3)

* --min-by

#+BEGIN_SRC elisp
(--min-by (> (length it) (length other)) '((1 2 3) (2) (3 2)))
#+END_SRC

#+RESULTS:
: (2)

* --none?

#+BEGIN_SRC elisp
(--none? (= 0 (% it 2)) '(1 3 5 7))
#+END_SRC

#+RESULTS:
: t

* --only-some?

#+BEGIN_SRC elisp
(--only-some? (zerop (% it 2)) '(1 2 3))
#+END_SRC

#+RESULTS:
: t

* --partition-by

#+BEGIN_SRC elisp
(--partition-by (< it 3) '(1 2 3 4 3 2 1))
#+END_SRC

#+RESULTS:
: ((1 2)
:  (3 4 3)
:  (2 1))

* --partition-by-header

#+BEGIN_SRC elisp
(--partition-by-header (= it 1) '(1 2 3 1 2 1 2 3 4))
#+END_SRC

#+RESULTS:
: ((1 2 3)
:  (1 2)
:  (1 2 3 4))

* --reduce

#+BEGIN_SRC elisp
(--reduce (format "%s-%d" acc it) '(1 2 3))
#+END_SRC

#+RESULTS:
: "1-2-3"

* --reduce-from

#+BEGIN_SRC elisp
(--reduce-from (concat acc " " it) "START" '("a" "b" "c"))
#+END_SRC

#+RESULTS:
: "START a b c"

* --reduce-r

#+BEGIN_SRC elisp
(--reduce-r (format "%s-%d" acc it) '(1 2 3))
#+END_SRC

#+RESULTS:
: "3-2-1"

* --reduce-r-from

#+BEGIN_SRC elisp
(--reduce-r-from (concat it " " acc) "END" '("a" "b" "c"))
#+END_SRC

#+RESULTS:
: "a b c END"

* --remove

#+BEGIN_SRC elisp
(--remove (= 0 (% it 2)) '(1 2 3 4))
#+END_SRC

#+RESULTS:
: (1 3)

* --remove-first

#+BEGIN_SRC elisp
(--remove-first (zerop (% it 2)) '(1 2 3 4))
#+END_SRC

#+RESULTS:
: (1 3 4)

* --remove-last

#+BEGIN_SRC elisp
(--remove-last #'cl-evenp '(1 2 3 4))
#+END_SRC

#+RESULTS:
: (1 2 3)

* --separate

#+BEGIN_SRC elisp
(--separate (< it 5) '(3 7 5 9 3 2 1 4 6))
#+END_SRC

#+RESULTS:
: ((3 3 2 1 4)
:  (7 5 9 6))

* --some

#+BEGIN_SRC elisp
(--some (and (> it 0) it) '(0 1 2))
#+END_SRC

#+RESULTS:
: 1

* --splice

#+BEGIN_SRC elisp
(--splice t
          (list (car it) (cdr it))
          '((x . 1)
            (y . 2)
            (z . 3)))
#+END_SRC

#+RESULTS:
: (x 1 y 2 z 3)

* --splice-list

#+BEGIN_SRC elisp
(--splice-list (keywordp it) '(a b c) '(1 :foo 2))
#+END_SRC

#+RESULTS:
: (1 a b c 2)

* --split-when

#+BEGIN_SRC elisp
(--split-when (memq it '(&optional &rest))
              '(a b &optional c d &rest args))
#+END_SRC

#+RESULTS:
: ((a b)
:  (c d)
:  (args))

* --take-while

#+BEGIN_SRC elisp
(--take-while (< it 4) '(1 2 3 4 3 2 1))
#+END_SRC

#+RESULTS:
: (1 2 3)

* --tree-map

#+BEGIN_SRC elisp
(--tree-map (length it) '("<body>" ("<p>" "text" "</p>") "</body>"))
#+END_SRC

#+RESULTS:
: (6
:  (3 4 4)
:  7)

* --tree-reduce

#+BEGIN_SRC elisp
(--tree-reduce
 (cond ((stringp it) (concat it " " acc))
       (t (let ((sn (symbol-name it)))
            (concat "<" sn ">" acc "</" sn ">"))))
 '(body (p "some words") (div "more" (b "bold") "words")))
#+END_SRC

#+RESULTS:
: "<body><p>some words</p> <div>more <b>bold</b> words</div></body>"

* --unfold

#+BEGIN_SRC elisp
(--unfold (when it (cons it (cdr it))) '(1 2 3 4))
#+END_SRC

#+RESULTS:
: ((1 2 3 4)
:  (2 3 4)
:  (3 4)
:  (4))

* --update-at

#+BEGIN_SRC elisp
(--update-at 2 (length it) '("foo" "bar" "baz" "quux"))
#+END_SRC

#+RESULTS:
: ("foo" "bar" 3 "quux")

* --when-let

#+BEGIN_SRC elisp
(--when-let (string-match "d" "abcd")
  (+ it 2))
#+END_SRC

#+RESULTS:
: 5

* ->

#+BEGIN_SRC elisp
;; (/ (- 5 1) 2)
(-> 5 (- 1) (/ 2))
#+END_SRC

#+RESULTS:
: 2

* ->>

#+BEGIN_SRC elisp
;; (+ 40 (- (/ 25 (+ 20 5))))
(->> 5
     (+ 20)
     (/ 25)
     -
     (+ 40))
#+END_SRC

#+RESULTS:
: 39

* -all?

#+BEGIN_SRC elisp
(-all? #'cl-evenp '(2 4 6 8))
#+END_SRC

#+RESULTS:
: t

* -andfn

#+BEGIN_SRC elisp
(funcall (-andfn #'numberp #'cl-evenp) 4)
#+END_SRC

#+RESULTS:
: t

* -annotate

#+BEGIN_SRC elisp
(-annotate #'1+ '(1 2 3))
#+END_SRC

#+RESULTS:
: ((2 . 1)
:  (3 . 2)
:  (4 . 3))

* -any?

#+BEGIN_SRC elisp
(-any? #'cl-evenp '(1 2 3))
#+END_SRC

#+RESULTS:
: t

* -applify

#+BEGIN_SRC elisp
(funcall (-applify #'<) '(3 6))
#+END_SRC

#+RESULTS:
: t

* -as->

#+BEGIN_SRC elisp
(-as-> 3 my-var 1+ (/ my-var 2))
#+END_SRC

#+RESULTS:
: 2

* -butlast

#+BEGIN_SRC elisp
(-butlast '(1 2 3))
#+END_SRC

#+RESULTS:
: (1 2)

* -clone

#+BEGIN_SRC elisp
(let* ((original '(:x (1 2 3)))
       (shallow (-copy original))
       (deep (-clone original)))
  (list (eq (plist-get original :x) (plist-get shallow :x))
        (eq (plist-get original :x) (plist-get deep :x))))
#+END_SRC

#+RESULTS:
: (t nil)

* -common-prefix

#+BEGIN_SRC elisp
(-common-prefix '(1 2) '(1 2 3) '(1 2 3 4))
#+END_SRC

#+RESULTS:
: (1 2)

* -compose

#+BEGIN_SRC elisp
(funcall (-compose #'string-trim #'upcase) " hello ")
#+END_SRC

#+RESULTS:
: "HELLO"

* -concat

#+BEGIN_SRC elisp
(-concat '(1) '(2 3) '(4))
#+END_SRC

#+RESULTS:
: (1 2 3 4)

* -cons*

#+BEGIN_SRC elisp
(-cons* 1 2 3)
#+END_SRC

#+RESULTS:
: (1 2 . 3)

* -const

#+BEGIN_SRC elisp
(-map (-const 1) '("a" "b" "c" "d"))
#+END_SRC

#+RESULTS:
: (1 1 1 1)

* -contains?

#+BEGIN_SRC elisp
(-contains? '(1 2 3) 1)
#+END_SRC

#+RESULTS:
: t

* -copy

#+BEGIN_SRC elisp
(-copy '(1 2 3))
#+END_SRC

#+RESULTS:
: (1 2 3)

* -count

#+BEGIN_SRC elisp
(-count #'cl-evenp '(1 2 3 4 5))
#+END_SRC

#+RESULTS:
: 2

* -counter

#+BEGIN_SRC elisp
(let ((c (-counter 0)))
  (list (funcall c)
        (funcall c)
        (funcall c)))
#+END_SRC

#+RESULTS:
: (0 1 2)

* -cut

#+BEGIN_SRC elisp
(funcall (-cut list 1 <> 3 <> 5) 2 4)
#+END_SRC

#+RESULTS:
: (1 2 3 4 5)

* -cycle

#+BEGIN_SRC elisp
(-cycle '(1 2 3))
#+END_SRC

#+RESULTS:
: (1 2 3 1 2 . #2)

* -difference

#+BEGIN_SRC elisp
(-difference '(1 2 3 4) '(3 4 5 6))
#+END_SRC

#+RESULTS:
: (1 2)

* -distinct

#+BEGIN_SRC elisp
(-distinct '(1 2 2 4))
#+END_SRC

#+RESULTS:
: (1 2 4)

* -dotimes

#+BEGIN_SRC elisp :results output
(-dotimes 3 #'princ)
#+END_SRC

#+RESULTS:
: "012"

* -doto

#+BEGIN_SRC elisp
(-doto '(1 . 2) (setcar 3) (setcdr 4))
#+END_SRC

#+RESULTS:
: (3 . 4)

* -drop

#+BEGIN_SRC elisp
(-drop 3 '(1 2 3 4 5))
#+END_SRC

#+RESULTS:
: (4 5)

* -drop-last

#+BEGIN_SRC elisp
(-drop-last 3 '(1 2 3 4 5))
#+END_SRC

#+RESULTS:
: (1 2)

* -drop-while

#+BEGIN_SRC elisp
(-drop-while #'cl-evenp '(1 2 3 4))
#+END_SRC

#+RESULTS:
: (1 2 3 4)

* -each

#+BEGIN_SRC elisp :results output
(-each '(1 2 3) #'princ)
#+END_SRC

#+RESULTS:
: "123"

* -each-indexed

#+BEGIN_SRC elisp :results output
(-each-indexed '(a b c) (lambda (index item)
                          (princ index)
                          (princ item)))
#+END_SRC

#+RESULTS:
: "0a1b2c"

* -each-r

#+BEGIN_SRC elisp :results output
(-each-r '(1 2 3) #'princ)
#+END_SRC

#+RESULTS:
: "321"

* -each-r-while

#+BEGIN_SRC elisp :results output
(-each-r-while '(2 4 5 6) #'cl-evenp #'princ)
#+END_SRC

#+RESULTS:
: "6"

* -each-while

#+BEGIN_SRC elisp :results output
(-each-while '(2 4 5 6) #'cl-evenp #'princ)
#+END_SRC

#+RESULTS:
: "24"

* -elem-index

#+BEGIN_SRC elisp
(-elem-index 2 '(6 7 8 2 3 4))
#+END_SRC

#+RESULTS:
: 3

* -elem-indices

#+BEGIN_SRC elisp
(-elem-indices 2 '(6 7 8 2 3 4 2 1))
#+END_SRC

#+RESULTS:
: (3 6)

* -fifth-item

#+BEGIN_SRC elisp
(-fifth-item '(1 2 3 4 5))
#+END_SRC

#+RESULTS:
: 5

* -filter

#+BEGIN_SRC elisp
(-filter #'cl-evenp '(1 2 3 4))
#+END_SRC

#+RESULTS:
: (2 4)

* -find-index

#+BEGIN_SRC elisp
(-find-index #'cl-evenp '(1 2 3 4))
#+END_SRC

#+RESULTS:
: 1

* -find-indices

#+BEGIN_SRC elisp
(-find-indices #'cl-evenp '(1 2 3 4))
#+END_SRC

#+RESULTS:
: (1 3)

* -find-last-index

#+BEGIN_SRC elisp
(-find-last-index #'cl-evenp '(1 2 3 4))
#+END_SRC

#+RESULTS:
: 3

* -first

#+BEGIN_SRC elisp
(-first #'cl-evenp '(1 2 3))
#+END_SRC

#+RESULTS:
: 2

* -first-item

#+BEGIN_SRC elisp
(-first-item '(1 2 3))
#+END_SRC

#+RESULTS:
: 1

* -fix

#+BEGIN_SRC elisp
(-fix (lambda (x) (expt (+ x 10) 0.25))
      2.0)
#+END_SRC

#+RESULTS:
: 1.8555845286409378

* -fixfn

#+BEGIN_SRC elisp
(funcall (-fixfn (lambda (x) (expt (+ x 10) 0.25)))
         2.0)
#+END_SRC

#+RESULTS:
: 1.8555845286409378

* -flatten

#+BEGIN_SRC elisp
(-flatten '((1 (2 3) (((4 (5)))))))
#+END_SRC

#+RESULTS:
: (1 2 3 4 5)

* -flatten-n

#+BEGIN_SRC elisp
(-flatten-n 1 '((1 2) ((3 4) ((5 6)))))
#+END_SRC

#+RESULTS:
: (1 2
:    (3 4)
:    ((5 6)))

* -flip

#+BEGIN_SRC elisp
(funcall (-flip #'<) 2 1)
#+END_SRC

#+RESULTS:
: t

* -fourth-item

#+BEGIN_SRC elisp
(-fourth-item '(1 2 3 4))
#+END_SRC

#+RESULTS:
: 4

* -group-by

#+BEGIN_SRC elisp
(-group-by #'cl-evenp '(1 2 3 4))
#+END_SRC

#+RESULTS:
: ((nil 1 3)
:  (t 2 4))

* -if-let

#+BEGIN_SRC elisp
(-if-let (match-index (string-match "d" "abc"))
    (+ match-index 3)
  7)
#+END_SRC

#+RESULTS:
: 7

* -inits

#+BEGIN_SRC elisp
(-inits '(1 2 3 4))
#+END_SRC

#+RESULTS:
: (nil
:  (1)
:  (1 2)
:  (1 2 3)
:  (1 2 3 4))

* -insert-at

#+BEGIN_SRC elisp
(-insert-at 1 'x '(a b c))
#+END_SRC

#+RESULTS:
: (a x b c)

* -interleave

#+BEGIN_SRC elisp
(-interleave '(1 2) '("a" "b"))
#+END_SRC

#+RESULTS:
: (1 "a" 2 "b")

* -interpose

#+BEGIN_SRC elisp
(-interpose "-" '("a" "b" "c"))
#+END_SRC

#+RESULTS:
: ("a" "-" "b" "-" "c")

* -intersection

#+BEGIN_SRC elisp
(-intersection '(1 2 3 4) '(3 4 5 6))
#+END_SRC

#+RESULTS:
: (3 4)

* -is-infix?

#+BEGIN_SRC elisp
(-is-infix? '(2 3 4) '(1 2 3 4 5))
#+END_SRC

#+RESULTS:
: t

* -is-prefix?

#+BEGIN_SRC elisp
(-is-prefix? '(1 2 3) '(1 2 3 4 5))
#+END_SRC

#+RESULTS:
: t

* -is-suffix?

#+BEGIN_SRC elisp
(-is-suffix? '(3 4 5) '(1 2 3 4 5))
#+END_SRC

#+RESULTS:
: t

* -iterate

#+BEGIN_SRC elisp
(-iterate #'1+ 1 10)
#+END_SRC

#+RESULTS:
: (1 2 3 4 5 6 7 8 9 10)

* -iteratefn

#+BEGIN_SRC elisp
(funcall (-iteratefn #'1+ 3) 1)
#+END_SRC

#+RESULTS:
: 4

* -juxt

#+BEGIN_SRC elisp
(funcall (-juxt #'+ #'-) 3 5)
#+END_SRC

#+RESULTS:
: (8 -2)

* -keep

#+BEGIN_SRC elisp
(-keep (lambda (num)
         (and (cl-evenp num) (* num num)))
       '(1 2 3 4))
#+END_SRC

#+RESULTS:
: (4 16)

* -lambda

#+BEGIN_SRC elisp
(-map (-lambda ((x . y))
        (+ x y))
      '((1 . 2)
        (3 . 4)
        (5 . 6)))
#+END_SRC

#+RESULTS:
: (3 7 11)

* -last

#+BEGIN_SRC elisp
(-last #'cl-evenp '(1 2 3 4 5 6 3 3 3))
#+END_SRC

#+RESULTS:
: 6

* -last-item

#+BEGIN_SRC elisp
(-last-item '(1 2 3))
#+END_SRC

#+RESULTS:
: 3

* -let

#+BEGIN_SRC elisp
(-let (([a (b c) d]
        [1 (2 3) 4]))
  (list a b c d))
#+END_SRC

#+RESULTS:
: (1 2 3 4)

* -let*

#+BEGIN_SRC elisp
(-let* (((a b) '( 1 2))
        ((c d) (--map (+ it 2) (list a b))))
  (list a b c d))
#+END_SRC

#+RESULTS:
: (1 2 3 4)

* -list

#+BEGIN_SRC elisp
(-list 1 2 3)
#+END_SRC

#+RESULTS:
: (1 2 3)

* -map

#+BEGIN_SRC elisp
(-map #'1+ '(1 2 3))
#+END_SRC

#+RESULTS:
: (2 3 4)

* -map-first

#+BEGIN_SRC elisp
(-map-first #'numberp #'1+ '(a b 1 2 3))
#+END_SRC

#+RESULTS:
: (a b 2 2 3)

* -map-indexed

#+BEGIN_SRC elisp
(-map-indexed (lambda (index item)
                (cons index item))
              '(a b c d))
#+END_SRC

#+RESULTS:
: ((0 . a)
:  (1 . b)
:  (2 . c)
:  (3 . d))

* -map-last

#+BEGIN_SRC elisp
(-map-last #'numberp #'1+ '(a b c 1 2))
#+END_SRC

#+RESULTS:
: (a b c 1 3)

* -map-when

#+BEGIN_SRC elisp
(-map-when #'numberp #'1+ '(a b 1 2 3))
#+END_SRC

#+RESULTS:
: (a b 2 3 4)

* -mapcat

#+BEGIN_SRC elisp
(-mapcat
 (pcase-lambda (`(,key . ,val))
   (list (intern (format ":%s" key))
         val))
 '((x . 1) (y . 2) (z . 3)))
#+END_SRC

#+RESULTS:
: (:x 1 :y 2 :z 3)

* -max

#+BEGIN_SRC elisp
(-max '(1 2 3))
#+END_SRC

#+RESULTS:
: 3

* -max-by

#+BEGIN_SRC elisp
(--max-by (> (length it) (length other)) '((1 2 3) (2) (3 2)))
#+END_SRC

#+RESULTS:
: (1 2 3)

* -min

#+BEGIN_SRC elisp
(-min '(3 2 1))
#+END_SRC

#+RESULTS:
: 1

* -min-by

#+BEGIN_SRC elisp
(-min-by #'> '(4 3 6 1))
#+END_SRC

#+RESULTS:
: 1

* -non-nil

#+BEGIN_SRC elisp
(-non-nil '(1 nil 2 nil nil 3 4 nil 5 nil))
#+END_SRC

#+RESULTS:
: (1 2 3 4 5)

* -none?

#+BEGIN_SRC elisp
(-none? #'cl-evenp '(1 3 5 7))
#+END_SRC

#+RESULTS:
: t

* -not

#+BEGIN_SRC elisp
(funcall (-not #'cl-evenp) 5)
#+END_SRC

#+RESULTS:
: t

* -on

#+BEGIN_SRC elisp
(-sort (-on #'< #'length) '((1 2 3) (1) (1 2)))
#+END_SRC

#+RESULTS:
: ((1)
:  (1 2)
:  (1 2 3))

* -only-some?

#+BEGIN_SRC elisp
(-only-some? #'cl-evenp '(1 2 3))
#+END_SRC

#+RESULTS:
: t

* -orfn

#+BEGIN_SRC elisp
(funcall (-orfn #'stringp #'cl-evenp) 4)
#+END_SRC

#+RESULTS:
: t

* -pad

#+BEGIN_SRC elisp
(-pad 0 '(1 2 3) '(4 5))
#+END_SRC

#+RESULTS:
: ((1 2 3)
:  (4 5 0))

* -partial

#+BEGIN_SRC elisp
(funcall (-partial '- 5) 3)
#+END_SRC

#+RESULTS:
: 2

* -partition

#+BEGIN_SRC elisp
(-partition 2 '(1 2 3 4 5))
#+END_SRC

#+RESULTS:
: ((1 2)
:  (3 4))

* -partition-after-item

#+BEGIN_SRC elisp
(-partition-after-item '| '(a | b | c))
#+END_SRC

#+RESULTS:
: ((a |)
:  (b |)
:  (c))

* -partition-after-pred

#+BEGIN_SRC elisp
(-partition-after-pred #'cl-oddp '(1 2 3 4))
#+END_SRC

#+RESULTS:
: ((1)
:  (2 3)
:  (4))

* -partition-all

#+BEGIN_SRC elisp
(-partition-all 2 '(1 2 3 4 5))
#+END_SRC

#+RESULTS:
: ((1 2)
:  (3 4)
:  (5))

* -partition-all-in-steps

#+BEGIN_SRC elisp
(-partition-all-in-steps 3 2 '(1 2 3 4))
#+END_SRC

#+RESULTS:
: ((1 2 3)
:  (3 4))

* -partition-before-item

#+BEGIN_SRC elisp
(-partition-before-item '| '(a | b | c))
#+END_SRC

#+RESULTS:
: ((a)
:  (| b)
:  (| c))

* -partition-before-pred

#+BEGIN_SRC elisp
(-partition-before-pred #'cl-oddp '(0 1 2 3 4))
#+END_SRC

#+RESULTS:
: ((0)
:  (1 2)
:  (3 4))

* -partition-by

#+BEGIN_SRC elisp
(-partition-by #'cl-evenp '(1 1 2 2 2 3 4 6 8))
#+END_SRC

#+RESULTS:
: ((1 1)
:  (2 2 2)
:  (3)
:  (4 6 8))

* -partition-by-header

#+BEGIN_SRC elisp
(-partition-by-header #'cl-evenp '(2 1 1 1 4 1 3 5 6 6 1))
#+END_SRC

#+RESULTS:
: ((2 1 1 1)
:  (4 1 3 5)
:  (6 6 1))

* -partition-in-steps

#+BEGIN_SRC elisp
(-partition-in-steps 2 1 '(1 2 3 4))
#+END_SRC

#+RESULTS:
: ((1 2)
:  (2 3)
:  (3 4))

* -permutations

#+BEGIN_SRC elisp
(-permutations '(a b c))
#+END_SRC

#+RESULTS:
: ((a b c)
:  (a c b)
:  (b a c)
:  (b c a)
:  (c a b)
:  (c b a))

* -powerset

#+BEGIN_SRC elisp
(-powerset '(x y z))
#+END_SRC

#+RESULTS:
: ((x y z)
:  (x y)
:  (x z)
:  (x)
:  (y z)
:  (y)
:  (z)
:  nil)

* -prodfn

#+BEGIN_SRC elisp
(funcall (-prodfn '1+ '1- 'number-to-string)
         '(1 2 3))
#+END_SRC

#+RESULTS:
: (2 1 "3")

* -product

#+BEGIN_SRC elisp
(-product '(1 2 3 4))
#+END_SRC

#+RESULTS:
: 24

* -reduce

#+BEGIN_SRC elisp
(-reduce #'- '(1 2 3 4))
#+END_SRC

#+RESULTS:
: -8

* -reduce-from

#+BEGIN_SRC elisp
(-reduce-from #'- 10 '(1 2 3))
#+END_SRC

#+RESULTS:
: 4

* -reduce-r

#+BEGIN_SRC elisp
;; (- 1 (- 2 (- 3 4)))
(-reduce-r #'- '(1 2 3 4))
#+END_SRC

#+RESULTS:
: -2

* -reduce-r-from

#+BEGIN_SRC elisp
;; (- 3 (- 2 (- 1 10)))
(-reduce-r-from #'- 10 '(1 2 3))
#+END_SRC

#+RESULTS:
: -8

* -reductions

#+BEGIN_SRC elisp
(-reductions '+ '(1 2 3 4))
#+END_SRC

#+RESULTS:
: (1 3 6 10)

* -reductions-from

#+BEGIN_SRC elisp
(-reductions-from '*  1 '(1 2 3 4))
#+END_SRC

#+RESULTS:
: (1 1 2 6 24)

* -reductions-r

#+BEGIN_SRC elisp
(-reductions-r #'+ '(1 2 3 4))
#+END_SRC

#+RESULTS:
: (10 9 7 4)

* -reductions-r-from

#+BEGIN_SRC elisp
(-reductions-r-from '* 1 '(1 2 3 4))
#+END_SRC

#+RESULTS:
: (24 24 12 4 1)

* -remove

#+BEGIN_SRC elisp
(-remove #'cl-evenp '(1 2 3 4))
#+END_SRC

#+RESULTS:
: (1 3)

* -remove-at

#+BEGIN_SRC elisp
(-remove-at 0 '("0" "1" "2" "3" "4" "5"))
#+END_SRC

#+RESULTS:
: ("1" "2" "3" "4" "5")

* -remove-at-indices

#+BEGIN_SRC elisp
(-remove-at-indices '(0 3) '(a b c d))
#+END_SRC

#+RESULTS:
: (b c)

* -remove-first

#+BEGIN_SRC elisp
(-remove-first #'cl-evenp '(1 2 3 4))
#+END_SRC

#+RESULTS:
: (1 3 4)

* -remove-item

#+BEGIN_SRC elisp
(-remove-item 'foo '(foo bar baz foo))
#+END_SRC

#+RESULTS:
: (bar baz)

* -remove-last

#+BEGIN_SRC elisp
(-remove-last #'cl-evenp '(1 2 3 4))
#+END_SRC

#+RESULTS:
: (1 2 3)

* -repeat

#+BEGIN_SRC elisp
(-repeat 3 'a)
#+END_SRC

#+RESULTS:
: (a a a)

* -replace

#+BEGIN_SRC elisp
(-replace 1 "1" '(1 2 3 4 3 2 1))
#+END_SRC

#+RESULTS:
: ("1" 2 3 4 3 2 "1")

* -replace-at

#+BEGIN_SRC elisp
(-replace-at 0 9 '(0 1 2 3 4 5))
#+END_SRC

#+RESULTS:
: (9 1 2 3 4 5)

* -replace-first

#+BEGIN_SRC elisp
(-replace-first 1 "1" '(1 2 3 4 3 2 1))
#+END_SRC

#+RESULTS:
: ("1" 2 3 4 3 2 1)

* -replace-last

#+BEGIN_SRC elisp
(-replace-last 1 "1" '(1 2 3 4 3 2 1))
#+END_SRC

#+RESULTS:
: (1 2 3 4 3 2 "1")

* -rotate

#+BEGIN_SRC elisp
(-rotate 3 '(1 2 3 4 5 6 7))
#+END_SRC

#+RESULTS:
: (5 6 7 1 2 3 4)

* -rpartial

#+BEGIN_SRC elisp
(funcall (-rpartial '- 5) 8)
#+END_SRC

#+RESULTS:
: 3

* -running-product

#+BEGIN_SRC elisp
(-running-product '(1 2 3 4))
#+END_SRC

#+RESULTS:
: (1 2 6 24)

* -running-sum

#+BEGIN_SRC elisp
(-running-sum '(1 2 3 4))
#+END_SRC

#+RESULTS:
: (1 3 6 10)

* -same-items?

#+BEGIN_SRC elisp
(-same-items? '(1 2 3) '(3 2 1))
#+END_SRC

#+RESULTS:
: t

* -second-item

#+BEGIN_SRC elisp
(-second-item '(1 2 3))
#+END_SRC

#+RESULTS:
: 2

* -select-by-indices

#+BEGIN_SRC elisp
(-select-by-indices '(2 1 0) '(a b c))
#+END_SRC

#+RESULTS:
: (c b a)

* -select-column

#+BEGIN_SRC elisp
(-select-column 1 '((1 2 3)
                    (a b c)
                    (:a :b :c)))
#+END_SRC

#+RESULTS:
: (2 b :b)

* -select-columns

#+BEGIN_SRC elisp
(-select-columns '(0 2)
                 '((1 2 3)
                   (a b c)
                   (:a :b :c)))
#+END_SRC

#+RESULTS:
: ((1 3)
:  (a c)
:  (:a :c))

* -separate

#+BEGIN_SRC elisp
(-separate #'cdr '((1 2) (1) (1 2 3) (4)))
#+END_SRC

#+RESULTS:
: (((1 2)
:   (1 2 3))
:  ((1)
:   (4)))

* -setq

#+BEGIN_SRC elisp
(let (a b)
  (-setq [a b] [1 2 3])
  (list a b))
#+END_SRC

#+RESULTS:
: (1 2)

* -slice

#+BEGIN_SRC elisp
(-slice '(a b c d e) 1 4)
#+END_SRC

#+RESULTS:
: (b c d)

* -snoc

#+BEGIN_SRC elisp
(-snoc '(1 2 3) 4 5 6)
#+END_SRC

#+RESULTS:
: (1 2 3 4 5 6)

* -some

#+BEGIN_SRC elisp
(-some #'cl-evenp '(1 2 3))
#+END_SRC

#+RESULTS:
: t

* -some-->

#+BEGIN_SRC elisp
(-some--> "def" (concat "abc" it "ghi"))
#+END_SRC

#+RESULTS:
: "abcdefghi"

* -some->

#+BEGIN_SRC elisp
(-some-> 6 (/ 2))
#+END_SRC

#+RESULTS:
: 3

* -some->>

#+BEGIN_SRC elisp
(-some->> '(2 4 6) (-last #'cl-evenp) (+ 100))
#+END_SRC

#+RESULTS:
: 106

* -sort

#+BEGIN_SRC elisp
(-sort #'< '(3 1 2))
#+END_SRC

#+RESULTS:
: (1 2 3)

* -splice

#+BEGIN_SRC elisp
(-splice #'cl-evenp (lambda (x) (list x x)) '(1 2 3 4))
#+END_SRC

#+RESULTS:
: (1 2 2 3 4 4)

* -splice-list

#+BEGIN_SRC elisp
(-splice-list 'keywordp '(a b c) '(1 :foo 2))
#+END_SRC

#+RESULTS:
: (1 a b c 2)

* -split-at

#+BEGIN_SRC elisp
(-split-at 3 '(1 2 3 4 5))
#+END_SRC

#+RESULTS:
: ((1 2 3)
:  (4 5))

* -split-on

#+BEGIN_SRC elisp
(-split-on '| '(Nil | Leaf a | Node [Tree a]))
#+END_SRC

#+RESULTS:
: ((Nil)
:  (Leaf a)
:  (Node
:   [Tree a]))

* -split-when

#+BEGIN_SRC elisp
(-split-when #'cl-evenp '(1 2 3 4 5 6))
#+END_SRC

#+RESULTS:
: ((1)
:  (3)
:  (5))

* -split-with

#+BEGIN_SRC elisp
(-split-with #'cl-evenp '(2 4 5 6))
#+END_SRC

#+RESULTS:
: ((2 4)
:  (5 6))

* -sum

#+BEGIN_SRC elisp
(-sum '(1 2 3 4))
#+END_SRC

#+RESULTS:
: 10

* -table

#+BEGIN_SRC elisp
(-table #'* '(1 2 3) '(1 2 3))
#+END_SRC

#+RESULTS:
: ((1 2 3)
:  (2 4 6)
:  (3 6 9))

* -table-flat

#+BEGIN_SRC elisp
(-table-flat #'list '(1 2 3) '(a b c))
#+END_SRC

#+RESULTS:
: ((1 a)
:  (2 a)
:  (3 a)
:  (1 b)
:  (2 b)
:  (3 b)
:  (1 c)
:  (2 c)
:  (3 c))

* -tails

#+BEGIN_SRC elisp
(-tails '(1 2 3 4))
#+END_SRC

#+RESULTS:
: ((1 2 3 4)
:  (2 3 4)
:  (3 4)
:  (4)
:  nil)

* -take

#+BEGIN_SRC elisp
(-take 3 '(1 2 3 4 5))
#+END_SRC

#+RESULTS:
: (1 2 3)

* -take-last

#+BEGIN_SRC elisp
(-take-last 3 '(1 2 3 4 5))
#+END_SRC

#+RESULTS:
: (3 4 5)

* -take-while

#+BEGIN_SRC elisp
(-take-while #'cl-evenp '(2 4 5 6))
#+END_SRC

#+RESULTS:
: (2 4)

* -third-item

#+BEGIN_SRC elisp
(-third-item '(1 2 3))
#+END_SRC

#+RESULTS:
: 3

* -tree-map

#+BEGIN_SRC elisp
(-tree-map #'1+ '(1 (2 3) (4 (5 6) 7)))
#+END_SRC

#+RESULTS:
: (2
:  (3 4)
:  (5
:   (6 7)
:   8))

* -tree-map-nodes

#+BEGIN_SRC elisp
(-tree-map-nodes
 'keywordp
 (lambda (x) (symbol-name x))
 '(1 :foo 4 ((5 6 :bar) :baz 8)))
#+END_SRC

#+RESULTS:
: (1 ":foo" 4
:    ((5 6 ":bar")
:     ":baz" 8))

* -tree-reduce

#+BEGIN_SRC elisp
(-tree-reduce #'+ '(1 (2 3) (4 5)))
#+END_SRC

#+RESULTS:
: 15

* -tree-reduce-from

#+BEGIN_SRC elisp
(-tree-reduce-from '+ 1 '(1 (1 1) ((1))))
#+END_SRC

#+RESULTS:
: 8

* -unfold

#+BEGIN_SRC elisp
(-unfold (lambda (x)
           (unless (= x 0) (cons x (1- x))))
         10)
#+END_SRC

#+RESULTS:
: (10 9 8 7 6 5 4 3 2 1)

* -union

#+BEGIN_SRC elisp
(-union '(1 1 2 2) '(3 2 1))
#+END_SRC

#+RESULTS:
: (1 2 3)

* -unzip

#+BEGIN_SRC elisp
(-unzip '((1 2) (3 4) (5 6) (7 8) (9 10)))
#+END_SRC

#+RESULTS:
: ((1 3 5 7 9)
:  (2 4 6 8 10))

* -update-at

#+BEGIN_SRC elisp
(-update-at 0 (lambda (x) (+ x 9)) '(0 1 2 3 4 5))
#+END_SRC

#+RESULTS:
: (9 1 2 3 4 5)

* -when-let

#+BEGIN_SRC elisp
(-when-let (match-index (string-match "d" "abcd"))
  (+ match-index 2))
#+END_SRC

#+RESULTS:
: 5

* -when-let*

#+BEGIN_SRC elisp
(-when-let* ((x 5)
             (y 3)
             (z (+ y 4)))
  (+ x y z))
#+END_SRC

#+RESULTS:
: 15

* -zip

#+BEGIN_SRC elisp
(-zip '(1 2 3) '(4 5 6))
#+END_SRC

#+RESULTS:
: ((1 . 4)
:  (2 . 5)
:  (3 . 6))

* -zip-fill

#+BEGIN_SRC elisp
(-zip-fill 0 '(1 2 3 4 5) '(6 7 8 9))
#+END_SRC

#+RESULTS:
: ((1 . 6)
:  (2 . 7)
:  (3 . 8)
:  (4 . 9)
:  (5 . 0))

* -zip-with

#+BEGIN_SRC elisp
(-zip-with 'cons '(1 2 3) '(4 5 6))
#+END_SRC

#+RESULTS:
: ((1 . 4)
:  (2 . 5)
:  (3 . 6))

* /

#+BEGIN_SRC elisp
(/ 6 2)
#+END_SRC

#+RESULTS:
: 3

#+BEGIN_SRC elisp
(list (/ 3 2)
      (/ 3 2.0))
#+END_SRC

#+RESULTS:
: (1 1.5)

* /=

#+BEGIN_SRC elisp
(/= 2 3)
#+END_SRC

#+RESULTS:
: t

* 1+

#+BEGIN_SRC elisp
(1+ 2)
#+END_SRC

#+RESULTS:
: 3

* 1-

#+BEGIN_SRC elisp
(1- 2)
#+END_SRC

#+RESULTS:
: 1

* <

#+BEGIN_SRC elisp
(< 2 3)
#+END_SRC

#+RESULTS:
: t

* <=

#+BEGIN_SRC elisp
(<= 2 2.0)
#+END_SRC

#+RESULTS:
: t

* =

#+BEGIN_SRC elisp
(= 1 1.0)
#+END_SRC

#+RESULTS:
: t

* >

#+BEGIN_SRC elisp
(> 3 2)
#+END_SRC

#+RESULTS:
: t

* >=

#+BEGIN_SRC elisp
(>= 2 2.0)
#+END_SRC

#+RESULTS:
: t

* `

#+BEGIN_SRC elisp
(apply #'+ `(1 ,@(number-sequence 2 4) 5))
#+END_SRC

#+RESULTS:
: 15

* abbreviate-file-name

#+BEGIN_SRC elisp
(abbreviate-file-name user-init-file)
#+END_SRC

#+RESULTS:
: "~/.emacs.d/init.el"

* abs

#+BEGIN_SRC elisp
(abs -4)
#+END_SRC

#+RESULTS:
: 4

* accept-process-output

#+BEGIN_SRC elisp
;; Block untill the process is done
(accept-process-output
 (start-process-shell-command "sh" nil "sleep 3"))
#+END_SRC

#+RESULTS:
: nil

* access-file

#+BEGIN_SRC elisp
(access-file user-init-file "Can't open your init file")
#+END_SRC

#+RESULTS:
: nil

* acos

#+BEGIN_SRC elisp
(acos 0)
#+END_SRC

#+RESULTS:
: 1.5707963267948966

* active-minibuffer-window

#+BEGIN_SRC elisp
(active-minibuffer-window)
#+END_SRC

#+RESULTS:
: nil

* add-face-text-property
:PROPERTIES:
:added:    24.4
:END:

#+BEGIN_SRC elisp
(let ((s "RED|GREEN"))
  (add-face-text-property 0 3 '(:foreground "red") 'append s)
  (add-face-text-property 4 9 '(:foreground "green") 'append s)
  (message s))
#+END_SRC

#+RESULTS:
: #("RED|GREEN" 0 3
:   (face
:    (:foreground "red"))
:   4 9
:   (face
:    (:foreground "green")))

* add-hook

#+BEGIN_SRC elisp :eval no
(add-hook 'lisp-interaction-mode-hook #'prettify-symbols-mode)
#+END_SRC

* add-text-properties

#+BEGIN_SRC elisp
(let ((s "hello"))
  (add-text-properties 0 (length s) '(display "world") s)
  s)
#+END_SRC

#+RESULTS:
: #("hello" 0 5
:   (display "world"))

* add-to-list

#+BEGIN_SRC elisp
(let ((l '(1 2)))
  (add-to-list 'l 1)
  (add-to-list 'l 2)
  (add-to-list 'l 3)
  l)
#+END_SRC

#+RESULTS:
: (3 1 2)

* advice-add
:PROPERTIES:
:added:    24.4
:END:

#+BEGIN_SRC elisp :eval no
(advice-add 'emacs-version :around #'ignore)
#+END_SRC

* advice-eval-interactive-spec
:PROPERTIES:
:added:    24.4
:END:

#+BEGIN_SRC elisp
(advice-eval-interactive-spec "r\nP")
#+END_SRC

* advice-remove
:PROPERTIES:
:added:    24.4
:END:

#+BEGIN_SRC elisp
(advice-remove 'emacs-version #'ignore)
#+END_SRC

* aio-defun

#+BEGIN_SRC elisp :lexical t
(aio-defun foo (url)
  (aio-await (aio-sleep 3))
  (message "Done sleeping. Now fetching %s" url)
  (let* ((result (aio-await (aio-url-retrieve url)))
         (contents (with-current-buffer (cdr result)
                     (prog1 (buffer-string)
                       (kill-buffer)))))
    (message "Result: %s" contents)))

(foo "http://example.com")
#+END_SRC

#+RESULTS:
: #s(aio-promise nil nil)

* aio-lambda

#+BEGIN_SRC elisp :lexical t
(funcall
 (aio-lambda ()
   (aio-await (aio-sleep 3))
   (message "Done sleeping 3 seconds")))
#+END_SRC

#+RESULTS:
: #s(aio-promise nil nil)

* alist-get
:PROPERTIES:
:added:    25.1
:changes:  26.1 The TESTFN argument is added.
:END:

#+BEGIN_SRC elisp
(alist-get 'y '((x . 1) (y . 2)))
#+END_SRC

#+RESULTS:
: 2

#+BEGIN_SRC elisp
;; TESTFN was added since 26.1
(cl-assert (version<= "26.1" emacs-version))
(alist-get "x" '(("x" . 1) ("y" . 2)) nil nil #'equal)
#+END_SRC

#+RESULTS:
: 1

* all-completions

#+BEGIN_SRC elisp
(all-completions "b" '("foo" "bar" "baz"))
#+END_SRC

#+RESULTS:
: ("bar" "baz")

* always
:PROPERTIES:
:added:    28.1
:END:

#+BEGIN_SRC elisp
(always 'foo 'bar 'args-dont-matter)
#+END_SRC

#+RESULTS:
: t

* and

#+BEGIN_SRC elisp
(list (and 1 2 3)
      (and 1 nil 3))
#+END_SRC

#+RESULTS:
: (3 nil)

* and-let*
:PROPERTIES:
:added:    26.1
:END:

#+BEGIN_SRC elisp
(and-let* ((bashrc (expand-file-name "~/.bashrc"))
           ((file-readable-p bashrc))
           (attrs (file-attributes bashrc))
           (mt (file-attribute-modification-time attrs))
           ((format-time-string "%Y-%m-%d" mt))))
#+END_SRC

#+RESULTS:
: "2018-10-27"

* ansi-color-apply

#+BEGIN_SRC elisp
(ansi-color-apply (concat "\e[31m" "Hello world" "\e[0m"))
#+END_SRC

#+RESULTS:
: #("Hello world" 0 11
:   (font-lock-face
:    (foreground-color . "red3")))

* append

#+BEGIN_SRC elisp
(append '(1) '(2 3 4) nil)
#+END_SRC

#+RESULTS:
: (1 2 3 4)

* apply

#+BEGIN_SRC elisp
(apply #'+ 1 2 '(3 4))
#+END_SRC

#+RESULTS:
: 10

* apply-partially

#+BEGIN_SRC elisp
(mapcar (apply-partially #'* 2) '(1 2 3))
#+END_SRC

#+RESULTS:
: (2 4 6)

* aref

#+BEGIN_SRC elisp
(aref [1 2 3] 0)
#+END_SRC

#+RESULTS:
: 1

* arrayp

#+BEGIN_SRC elisp
(arrayp [])
#+END_SRC

#+RESULTS:
: t

* aset

#+BEGIN_SRC elisp
(let ((array [vector 1 2 3]))
  (aset array 0 100)
  array)
#+END_SRC

#+RESULTS:
: [100 1 2 3]

* ash

#+BEGIN_SRC elisp
(ash #B111 1)
#+END_SRC

#+RESULTS:
: 14

* asin

#+BEGIN_SRC elisp
(asin 1)
#+END_SRC

#+RESULTS:
: 1.5707963267948966

* assoc
:PROPERTIES:
:changes:  26.1 The TESTFN argument is added.
:END:

#+BEGIN_SRC elisp
(assoc "two" '(("one" 1)
               ("two" 2)
               ("three" 3)))
#+END_SRC

#+RESULTS:
: ("two" 2)

* assoc-default

#+BEGIN_SRC elisp
(list (assoc-default 'x '(x (y 2)) #'eq 1)
      (assoc-default 'y '(x (y 2)) #'eq 1)
      (assoc-default 'z '(x (y 2)) #'eq 1))
#+END_SRC

#+RESULTS:
: (1
:  (2)
:  nil)

* assoc-delete-all
:PROPERTIES:
:added:    26.2
:changes:  27.1 The TEST argument is added.
:END:

#+BEGIN_SRC elisp
(assoc-delete-all "a" '(("a" 1)
                        ("b" 2)
                        ("c" 3)
                        ("a" 4)))
#+END_SRC

#+RESULTS:
: (("b" 2)
:  ("c" 3))

* assoc-string

#+BEGIN_SRC elisp
(assoc-string "path"
              '(("Domain" . "example.com")
                ("Path" . "/"))
              'ignore-case)
#+END_SRC

#+RESULTS:
: ("Path" . "/")

* assq

#+BEGIN_SRC elisp
(assq 'y '((x . 1)
           (y . 2)
           (z . 3)))
#+END_SRC

#+RESULTS:
: (y . 2)

* assq-delete-all

#+BEGIN_SRC elisp
(let ((alist (list (cons 1 11)
                   (cons 2 22)
                   (cons 3 33)
                   (cons 1 1111))))
  (setq alist (assq-delete-all 1 alist)))
#+END_SRC

#+RESULTS:
: ((2 . 22)
:  (3 . 33))

* atan

#+BEGIN_SRC elisp
(atan 1)
#+END_SRC

#+RESULTS:
: 0.7853981633974483

* atom

#+BEGIN_SRC elisp
(atom 42)
#+END_SRC

#+RESULTS:
: t

#+BEGIN_SRC elisp
(atom '())
#+END_SRC

#+RESULTS:
: t

#+BEGIN_SRC elisp
(atom '(1 2 . 3))
#+END_SRC

#+RESULTS:
: nil

* atomic-change-group

#+BEGIN_SRC elisp
(with-temp-buffer
  (insert "hello")
  (ignore-errors
    (atomic-change-group
      (insert "world")
      (error "I cannot do it")))
  (buffer-string))
#+END_SRC

#+RESULTS:
: "hello"

* auth-source-forget-all-cached

#+BEGIN_SRC elisp
(auth-source-forget-all-cached)
#+END_SRC

#+RESULTS:
: nil

* auth-source-pick-first-password

#+BEGIN_SRC elisp
(auth-source-pick-first-password :host "vlc")
#+END_SRC

#+RESULTS:
: "secret"

* auth-source-search

#+BEGIN_SRC elisp
(let ((tmpfile (make-temp-file "elisp-demos-authinfo-")))
  (write-region
   (concat "machine foo.com login user1 password pass1" "\n"
           "machine bar.com login user2 password pass2" "\n"
           "machine baz.com login user3 password pass2" "\n")
   nil tmpfile)
  (unwind-protect
      (let ((auth-source-do-cache nil)
            (auth-sources (list tmpfile)))
        (when-let ((plist (car (auth-source-search :host "bar.com" :max 1)))
                   (user (plist-get plist :user))
                   (pass (funcall (plist-get plist :secret))))
          (list user pass)))
    (delete-file tmpfile)))
#+END_SRC

#+RESULTS:
: ("user2" "pass2")

* autoload

#+BEGIN_SRC elisp
(autoload #'dired-omit-mode "dired-x")
#+END_SRC

#+RESULTS:
: nil

* autoloadp
:PROPERTIES:
:added:    24.3
:END:

#+BEGIN_SRC elisp
(autoloadp (symbol-function 'run-python))
#+END_SRC

#+RESULTS:
: t

* base64-decode-region

#+BEGIN_SRC elisp
(with-temp-buffer
  (insert "aGVsbG8=")
  (base64-decode-region (point-min) (point-max))
  (buffer-string))
#+END_SRC

#+RESULTS:
: "hello"

* base64-decode-string

#+BEGIN_SRC elisp
(base64-decode-string "aGVsbG8=")
#+END_SRC

#+RESULTS:
: "hello"

* base64-encode-region

#+BEGIN_SRC elisp
(with-temp-buffer
  (insert "hello")
  (base64-encode-region (point-min) (point-max))
  (buffer-string))
#+END_SRC

#+RESULTS:
: "aGVsbG8="

* base64-encode-string

#+BEGIN_SRC elisp
(base64-encode-string "hello")
#+END_SRC

#+RESULTS:
: "aGVsbG8="

* beginning-of-line

#+BEGIN_SRC elisp
(beginning-of-line)
#+END_SRC

#+RESULTS:
: nil

* benchmark

#+BEGIN_SRC elisp
(benchmark 10 '(sit-for 0.1))
#+END_SRC

#+RESULTS:
: "Elapsed time: 1.087937s"

* benchmark-call
:PROPERTIES:
:added:    28.1
:END:

#+BEGIN_SRC elisp
(benchmark-call (lambda () (sit-for 0.01)) 2.0)
#+END_SRC

#+RESULTS:
: (211 3.319833 0 0.0)

* benchmark-elapse

#+BEGIN_SRC elisp
(benchmark-elapse
  (sit-for 1))
#+END_SRC

#+RESULTS:
: 1.011088

* benchmark-progn
:PROPERTIES:
:added:    27.1
:END:

#+BEGIN_SRC elisp
(benchmark-progn
  (dotimes (i 1000000 i)))
#+END_SRC

#+RESULTS:
: 1000000

* benchmark-run

#+BEGIN_SRC elisp
(benchmark-run 10 (sit-for 0.1))
#+END_SRC

#+RESULTS:
: (1.072229 0 0.0)

* benchmark-run-compiled

#+BEGIN_SRC elisp
(benchmark-run 1
  (let ((i 10000000))
    (while (> (setq i (1- i)) 0))))
#+END_SRC

#+RESULTS:
: (1.377883 0 0.0)

#+BEGIN_SRC elisp
(benchmark-run-compiled 1
  (let ((i 10000000))
    (while (> (setq i (1- i)) 0))))
#+END_SRC

#+RESULTS:
: (0.281128 0 0.0)

* bind-keys

#+BEGIN_SRC elisp
(bind-keys :map winner-mode-map
           ("M-N" . winner-redo)
           ("M-P" . winner-undo))
#+END_SRC

* bindat-get-field

#+BEGIN_SRC elisp
(let* ((binary-data [192 168 1 100 192 168 1 101 4 210 17 215])
       (spec '((dest-ip ip)
               (src-ip ip)
               (dest-port u16)
               (src-port u16)))
       (decoded (bindat-unpack spec binary-data)))
  (bindat-get-field decoded 'src-ip))
#+END_SRC

#+RESULTS:
: [192 168 1 101]

* bindat-ip-to-string

#+BEGIN_SRC elisp
(bindat-ip-to-string [127 0 0 1])
#+END_SRC

#+RESULTS:
: "127.0.0.1"

* bindat-length

#+BEGIN_SRC elisp
(bindat-length '((id strz 8)
                 (ip ip))
               '((id . [?A ?B ?C ?D ?E ?F ?G 0])
                 (ip . [192 168 1 100])))
#+END_SRC

#+RESULTS:
: 12

* bindat-pack

#+BEGIN_SRC elisp
(string-to-vector
 (bindat-pack '((dest-ip ip)
                (src-ip ip)
                (dest-port u16)
                (src-port u16))
              '((dest-ip   . [192 168 1 100])
                (src-ip    . [192 168 1 101])
                (dest-port . 1234)
                (src-port  . 4567))))
#+END_SRC

#+RESULTS:
: [192 168 1 100 192 168 1 101 4 210 17 215]

* bindat-unpack

#+BEGIN_SRC elisp
(bindat-unpack '((dest-ip ip)
                 (src-ip ip)
                 (dest-port u16)
                 (src-port u16))
               [192 168 1 100 192 168 1 101 4 210 17 215])
#+END_SRC

#+RESULTS:
: ((src-port . 4567)
:  (dest-port . 1234)
:  (src-ip .
:          [192 168 1 101])
:  (dest-ip .
:           [192 168 1 100]))

#+BEGIN_SRC elisp
;; socks4: first packet to server
(bindat-unpack
 '((VER u8)
   (CMD u8)
   (DSTPORT u16)
   (DSTIP ip)
   (ID strz (eval (- (length bindat-raw) bindat-idx))))
 [#x04 #x01 #x00 #x50 #x5d #xb8 #xd8 #x22 #x46 #x72 #x65 #x64 #x00])
#+END_SRC

#+RESULTS:
: ((ID . "Fred")
:  (DSTIP .
:         [93 184 216 34])
:  (DSTPORT . 80)
:  (CMD . 1)
:  (VER . 4))

* bindat-vector-to-hex

#+BEGIN_SRC elisp
(bindat-vector-to-hex [0 1 2 255 256] " ")
#+END_SRC

#+RESULTS:
: "00 01 02 ff 100"

* bobp

#+BEGIN_SRC elisp
(with-temp-buffer (bobp))
#+END_SRC

#+RESULTS:
: t

* bolp

#+BEGIN_SRC elisp
(with-temp-buffer (bolp))
#+END_SRC

#+RESULTS:
: t

* bool-vector

#+BEGIN_SRC elisp
(vconcat (bool-vector nil t nil t))
#+END_SRC

#+RESULTS:
: [nil t nil t]

* bool-vector-count-consecutive

#+BEGIN_SRC elisp
(bool-vector-count-consecutive
 (bool-vector nil t nil t t t t t nil)
 t 3)
#+END_SRC

#+RESULTS:
: 5

* bool-vector-count-population

#+BEGIN_SRC elisp
(bool-vector-count-population (bool-vector nil t nil t t))
#+END_SRC

#+RESULTS:
: 3

* bool-vector-exclusive-or

#+BEGIN_SRC elisp
(vconcat
 (bool-vector-exclusive-or (bool-vector nil t nil t)
                           (bool-vector nil t t nil)))
#+END_SRC

#+RESULTS:
: [nil nil t t]

* bool-vector-intersection

#+BEGIN_SRC elisp
(vconcat
 (bool-vector-intersection (bool-vector nil nil t t)
                           (bool-vector nil t nil t)))
#+END_SRC

#+RESULTS:
: [nil nil nil t]

* bool-vector-not

#+BEGIN_SRC elisp
(vconcat (bool-vector-not (bool-vector nil t)))
#+END_SRC

#+RESULTS:
: [t nil]

* bool-vector-p

#+BEGIN_SRC elisp
(bool-vector-p (bool-vector))
#+END_SRC

#+RESULTS:
: t

* bool-vector-set-difference

#+BEGIN_SRC elisp
(vconcat
 (bool-vector-set-difference (bool-vector nil nil t t)
                             (bool-vector nil t nil t)))
#+END_SRC

#+RESULTS:
: [nil nil t nil]

* bool-vector-subsetp

#+BEGIN_SRC elisp
(bool-vector-subsetp (bool-vector t nil t nil)
                     (bool-vector t t t t))
#+END_SRC

#+RESULTS:
: t

* bool-vector-union

#+BEGIN_SRC elisp
(vconcat
 (bool-vector-union (bool-vector nil nil t t)
                    (bool-vector nil t nil t)))
#+END_SRC

#+RESULTS:
: [nil t t t]

* booleanp

#+BEGIN_SRC elisp
(booleanp nil)
#+END_SRC

#+RESULTS:
: t

* boundp

#+BEGIN_SRC elisp
(boundp 'emacs-version)
#+END_SRC

#+RESULTS:
: t

* buffer-chars-modified-tick

#+BEGIN_SRC elisp
(buffer-chars-modified-tick)
#+END_SRC

#+RESULTS:
: 62893

* buffer-end

#+BEGIN_SRC elisp
(cl-assert (buffer-end +1) (point-max))
(cl-assert (buffer-end -1) (point-min))
#+END_SRC

#+RESULTS:
: nil

* buffer-file-name

#+BEGIN_SRC elisp
(buffer-file-name)
#+END_SRC

#+RESULTS:
: "/Users/xcy/src/elisp-demos/elisp-demos.org"

* buffer-hash

#+BEGIN_SRC elisp
(with-temp-buffer
  (buffer-hash))
#+END_SRC

#+RESULTS:
: "da39a3ee5e6b4b0d3255bfef95601890afd80709"

* buffer-line-statistics

#+BEGIN_SRC elisp
(buffer-line-statistics)
#+END_SRC

#+RESULTS:
: (18915 183 13.353053132434633)

* buffer-list

#+BEGIN_SRC elisp
(message "There are %d buffers" (length (buffer-list)))
#+END_SRC

#+RESULTS:
: "There are 32 buffers"

* buffer-live-p

#+BEGIN_SRC elisp
(let ((buffer (generate-new-buffer "*test*")))
  (list buffer
        (buffer-live-p buffer)
        (kill-buffer buffer)
        (buffer-live-p buffer)
        buffer))
#+END_SRC

#+RESULTS:
: (#<killed buffer> t t nil #<killed buffer>)

* buffer-local-value

#+BEGIN_SRC elisp
(buffer-local-value 'major-mode (get-buffer "*Messages*"))
#+END_SRC

#+RESULTS:
: messages-buffer-mode

* buffer-match-p
:PROPERTIES:
:added:    29.1
:END:

#+BEGIN_SRC elisp
(let ((case-fold-search t))
  (buffer-match-p "messages" (get-buffer "*Messages*")))
#+END_SRC

#+RESULTS:
: t

* buffer-modified-p
:PROPERTIES:
:changes:  29.1 The return value has been changed to nil/'autosaved'/non-nil
:END:

#+BEGIN_SRC elisp
(buffer-modified-p)
#+END_SRC

#+RESULTS:
: t

* buffer-modified-tick

#+BEGIN_SRC elisp
(buffer-modified-tick)
#+END_SRC

#+RESULTS:
: 62561

* buffer-name

#+BEGIN_SRC elisp
(buffer-name)
#+END_SRC

#+RESULTS:
: "elisp-demos.org"

* buffer-narrowed-p
:PROPERTIES:
:added:    24.3
:END:

#+BEGIN_SRC elisp
(list (buffer-narrowed-p)
      (with-temp-buffer
        (insert "hello")
        (narrow-to-region 1 2)
        (buffer-narrowed-p)))
#+END_SRC

#+RESULTS:
: (nil t)

* buffer-size

#+BEGIN_SRC elisp
(buffer-size)
#+END_SRC

#+RESULTS:
: 14480

* buffer-string

#+BEGIN_SRC elisp
(with-temp-buffer
  (insert (propertize "hello" 'face 'bold))
  (buffer-string))
#+END_SRC

#+RESULTS:
: #("hello" 0 5
:   (face bold))

* buffer-swap-text

#+BEGIN_SRC elisp
(let ((b1 (generate-new-buffer "*buffer 1*"))
      (b2 (generate-new-buffer "*buffer 2*")))
  (with-current-buffer b1
    (insert "hello")
    (with-current-buffer b2 (insert "world"))
    (buffer-swap-text b2)
    (list (buffer-string)
          (with-current-buffer b2 (buffer-string)))))
#+END_SRC

#+RESULTS:
: ("world" "hello")

* buffer-text-pixel-size
:PROPERTIES:
:added:    29.1
:END:

#+BEGIN_SRC elisp
(with-temp-buffer
  (insert "hello")
  (buffer-text-pixel-size))
#+END_SRC

#+RESULTS:
: (40 . 18)

* bufferp

#+BEGIN_SRC elisp
(mapcar #'bufferp (list "*Messages*" (get-buffer "*Messages*")))
#+END_SRC

#+RESULTS:
: (nil t)

* butlast

#+BEGIN_SRC elisp
(butlast '(1 2 3 4 5) 2)
#+END_SRC

#+RESULTS:
: (1 2 3)

* byte-code-function-p

#+BEGIN_SRC elisp
(byte-code-function-p (symbol-function 'next-line))
#+END_SRC

#+RESULTS:
: t

* byte-compile

#+BEGIN_SRC elisp :results silent
(byte-compile '(lambda (a b) (+ a a b)))
#+END_SRC

#+BEGIN_SRC elisp
;; byte-compiled code is more efficient than interpreted code
(let* ((form '(let ((i 10000000))
                (while (> (setq i (- i 1)) 0))))
       (fun `(lambda () ,form))
       (compiled (byte-compile fun)))
  (list (benchmark-elapse 1 (funcall fun))
        (benchmark-elapse 1 (funcall compiled))))
#+END_SRC

#+RESULTS:
: (1.628522 0.265482)

* byte-to-position

#+BEGIN_SRC elisp
(with-temp-buffer
  (insert "lambda Î»")
  (byte-to-position 10))
#+END_SRC

#+RESULTS:
: 9

* byte-to-string

#+BEGIN_SRC elisp
(byte-to-string 65)
#+END_SRC

#+RESULTS:
: "A"

* caar

#+BEGIN_SRC elisp
(caar '((42)))
#+END_SRC

#+RESULTS:
: 42

* cadr

#+BEGIN_SRC elisp
(cadr '(1 2 3))
#+END_SRC

#+RESULTS:
: 2

* calc-eval

#+BEGIN_SRC elisp
(calc-eval "2 + 3")
#+END_SRC

#+RESULTS:
: "5"

* calendar-absolute-from-gregorian

#+BEGIN_SRC elisp
;; How many days since the Gregorian date 12/31/1 BC
(calendar-absolute-from-gregorian
 (calendar-current-date))
#+END_SRC

#+RESULTS:
: 737031

* calendar-chinese-from-absolute

#+BEGIN_SRC elisp
(calendar-chinese-from-absolute
 (calendar-absolute-from-gregorian
  (calendar-current-date)))
#+END_SRC

#+RESULTS:
: (78 35 10 26)

* calendar-current-date

#+BEGIN_SRC elisp
(calendar-current-date)
#+END_SRC

#+RESULTS:
: (12 3 2018)

* call-interactively

#+BEGIN_SRC elisp
(call-interactively #'emacs-version)
#+END_SRC

#+RESULTS:
: "GNU Emacs 26.1 (build 1, x86_64-apple-darwin18.2.0, Carbon Version 158 AppKit 1671.1) of 2018-11-11"

* call-process

#+BEGIN_SRC elisp
(with-temp-buffer
  (list :exit-status
        (call-process "echo" nil t nil "hello" "world")
        :output
        (buffer-string)))
#+END_SRC

#+RESULTS:
: (:exit-status 0 :output "hello world\n")

* call-process-region

#+BEGIN_SRC elisp
(with-temp-buffer
  (insert "hello\n")
  (call-process-region (point-min) (point-max) "wc" t t)
  (buffer-string))
#+END_SRC

#+RESULTS:
: "       1       1       6\n"

* call-process-shell-command

#+BEGIN_SRC elisp
(with-temp-buffer
  (list :exit-status
        (call-process-shell-command "echo hello | wc" nil t)
        :output
        (buffer-string)))
#+END_SRC

#+RESULTS:
: (:exit-status 0 :output "       1       1       6\n")

* cancel-timer

#+BEGIN_SRC elisp
(cancel-timer (run-at-time 1 nil #'ignore))
#+END_SRC

#+RESULTS:
: nil

* capitalize

#+BEGIN_SRC elisp
(capitalize "THE cat in the hat")
#+END_SRC

#+RESULTS:
: "The Cat In The Hat"

* car

#+BEGIN_SRC elisp
(car '(a b c))
#+END_SRC

#+RESULTS:
: a

#+BEGIN_SRC elisp
(car '())
#+END_SRC

#+RESULTS:
: nil

* car-safe

#+BEGIN_SRC elisp
(car-safe '(1))
#+END_SRC

#+RESULTS:
: 1

* catch

#+BEGIN_SRC elisp
(catch 'break
  (while t
    (throw 'break 42)))
#+END_SRC

#+RESULTS:
: 42

* category-docstring

#+BEGIN_SRC elisp
(category-docstring ?a)
#+END_SRC

#+RESULTS:
: "ASCII\nASCII graphic characters 32-126 (ISO646 IRV:1983[4/0])"

* category-set-mnemonics

#+BEGIN_SRC elisp
(category-set-mnemonics (char-category-set ?a))
#+END_SRC

#+RESULTS:
: ".Lalr"

* cdar

#+BEGIN_SRC elisp
(cdar '((1 2 3)))
#+END_SRC

#+RESULTS:
: (2 3)

* cddr

#+BEGIN_SRC elisp
(cddr '(1 2 3 4))
#+END_SRC

#+RESULTS:
: (3 4)

* cdr

#+BEGIN_SRC elisp
(cdr '(a b c))
#+END_SRC

#+RESULTS:
: (b c)

#+BEGIN_SRC elisp
(cdr '())
#+END_SRC

#+RESULTS:
: nil

* cdr-safe

#+BEGIN_SRC elisp
(cdr-safe '(1 2 3))
#+END_SRC

#+RESULTS:
: (2 3)

* ceiling

#+BEGIN_SRC elisp
;; -> +âˆž
(ceiling 1.2)
#+END_SRC

#+RESULTS:
: 2

* char-after

#+BEGIN_SRC elisp
(with-temp-buffer
  (insert "ABC")
  (string (char-after (point-min))))
#+END_SRC

#+RESULTS:
: "A"

* char-before

#+BEGIN_SRC elisp
(with-temp-buffer
  (insert "ABC")
  (string (char-before)))
#+END_SRC

#+RESULTS:
: "C"

* char-category-set

#+BEGIN_SRC elisp
(aref (char-category-set ?A) ?a)
#+END_SRC

#+RESULTS:
: t

* char-equal

#+BEGIN_SRC elisp
(list (char-equal ?x ?X)
      (let ((case-fold-search nil))
        (char-equal ?x ?X)))
#+END_SRC

#+RESULTS:
: (t nil)

* char-fold-to-regexp
:PROPERTIES:
:added:    25.1
:END:

#+BEGIN_SRC elisp
(char-fold-to-regexp "(")
#+END_SRC

#+RESULTS:
: "[(â½â‚ï¸µï¹™ï¼ˆ]"

* char-from-name
:PROPERTIES:
:added:    26.1
:END:

#+BEGIN_SRC elisp
(string (char-from-name "GREEK SMALL LETTER LAMBDA"))
#+END_SRC

#+RESULTS:
: "Î»"

* char-or-string-p

#+BEGIN_SRC elisp
(mapcar #'char-or-string-p '("" ?x 42 nil t))
#+END_SRC

#+RESULTS:
: (t t t nil nil)

* char-syntax

#+BEGIN_SRC elisp
(string (char-syntax ?a))
#+END_SRC

#+RESULTS:
: "w"

* char-table-range

#+BEGIN_SRC elisp
;; (aref char-width-table ?ðŸ’¯)
;; => 2

(char-table-range char-width-table ?ðŸ’¯)
#+END_SRC

#+RESULTS:
: 2

* char-to-string

#+BEGIN_SRC elisp
(char-to-string ?A)
#+END_SRC

#+RESULTS:
: "A"

* char-uppercase-p
:PROPERTIES:
:added:    29.1
:END:

#+BEGIN_SRC elisp
(char-uppercase-p ?A)
#+END_SRC

#+RESULTS:
: t

* char-width

#+BEGIN_SRC elisp
(char-width ?ä½ )
#+END_SRC

#+RESULTS:
: 2

* characterp

#+BEGIN_SRC elisp
(characterp 97)
#+END_SRC

#+RESULTS:
: t

* chart-bar-quickie

#+BEGIN_SRC elisp :results silent
;; http://francismurillo.github.io/2017-04-15-Exploring-Emacs-chart-Library/
(chart-bar-quickie
 'vertical
 "Eye Colors"
 '("Green" "Hazel" "Blue" "Brown") "Colors"
 '(64 93 215 220) "Frequency")
#+END_SRC

* check-coding-system

#+BEGIN_SRC elisp
(check-coding-system 'utf-8)
#+END_SRC

#+RESULTS:
: utf-8

* cl-adjoin

#+BEGIN_SRC elisp
(cl-adjoin 1 '(2 3))
#+END_SRC

#+RESULTS:
: (1 2 3)

#+BEGIN_SRC elisp
(cl-adjoin 1 '(2 3 1))
#+END_SRC

#+RESULTS:
: (2 3 1)

* cl-assert

#+BEGIN_SRC elisp
(cl-assert (= (+ 2 3) 5))
#+END_SRC

#+RESULTS:
: nil

* cl-block

#+BEGIN_SRC elisp
(cl-block nil
  1
  (cl-return 2)
  3)
#+END_SRC

#+RESULTS:
: 2

* cl-callf

#+BEGIN_SRC elisp
;; Toggle the value of `lexical-binding'
(cl-callf not lexical-binding)
#+END_SRC

#+RESULTS:
: t

* cl-callf2

#+BEGIN_SRC elisp
(let ((s "foo"))
  (cl-callf2 concat "<" s ">")
  s)
#+END_SRC

#+RESULTS:
: "<foo>"

* cl-case

#+BEGIN_SRC elisp
(cl-case (random 5)
  (0 "0")
  ((1 2 3) "[1, 3]")
  (t "4"))
#+END_SRC

#+RESULTS:
: "[1, 3]"

* cl-ceiling

#+BEGIN_SRC elisp
(cl-ceiling 10 3)
#+END_SRC

#+RESULTS:
: (4 -2)

* cl-coerce

#+BEGIN_SRC elisp
(cl-coerce 42 'float)
#+END_SRC

#+RESULTS:
: 42.0

* cl-concatenate

#+BEGIN_SRC elisp
(cl-concatenate 'vector '(1 2) [4 5] "67")
#+END_SRC

#+RESULTS:
: [1 2 4 5 54 55]

* cl-copy-list

#+BEGIN_SRC elisp
(cl-copy-list '(1 2 . 3))
#+END_SRC

#+RESULTS:
: (1 2 . 3)

* cl-count

#+BEGIN_SRC elisp
(cl-count nil '(1 2 nil () 3 4 nil) :test #'eq)
#+END_SRC

#+RESULTS:
: 3

* cl-count-if

#+BEGIN_SRC elisp
(cl-count-if #'cl-evenp '(1 2 3 4 5))
#+END_SRC

#+RESULTS:
: 2

* cl-count-if-not

#+BEGIN_SRC elisp
(cl-count-if-not #'cl-evenp '(1 2 3 4 5))
#+END_SRC

#+RESULTS:
: 3

* cl-defgeneric

#+BEGIN_SRC elisp
(cl-defgeneric greet (greeter))

(cl-defstruct cow)

(cl-defmethod greet ((_ cow))
  "Moo!")

(cl-defstruct bird)

(cl-defmethod greet ((_ bird))
  "Chirp!")

(list (greet (make-cow))
      (greet (make-bird)))
#+END_SRC

#+RESULTS:
: ("Moo!" "Chirp!")

* cl-defmethod

#+BEGIN_SRC elisp
(cl-defstruct dog)
(cl-defstruct person name)

(cl-defgeneric say-hi (object)
  "Greeting from OBJECT.")

(cl-defmethod say-hi ((n number))
  "Greating from a number."
  (number-to-string n))

(cl-defmethod say-hi ((d dog))
  "Greeting from a dog."
  "wowowowowoowooo")

(cl-defmethod say-hi ((p person))
  "Greeting from a person."
  (format "Hello, I am %s" (person-name p)))

(mapcar #'say-hi (list 42 (make-dog) (make-person :name user-full-name)))
#+END_SRC

#+RESULTS:
: ("42" "wowowowowoowooo" "Hello, I am Xu Chunyang")

* cl-defstruct
:PROPERTIES:
:changes:  27.1  'cl-defstruct' has a new ':noinline' argument to prevent inlining its functions.
:changes:  27.1  'cl-defstruct' slots accept a ':documentation' property.
:END:

#+BEGIN_SRC elisp
(cl-defstruct (person (:constructor person-create)
                      (:copier nil))
  name age sex)

(let ((tom (person-create :name "Tom" :age 19 :sex "Male")))
  (cl-incf (person-age tom))
  tom)
#+END_SRC

#+RESULTS:
: #s(person "Tom" 20 "Male")

* cl-defun

#+BEGIN_SRC elisp
(cl-defun foo (a &optional b &key c d (e 17))
  (list :a a
        :b b
        :c c
        :d d
        :e e))

(foo 1 2 :c 3 :d 4)
#+END_SRC

#+RESULTS:
: (:a 1 :b 2 :c 3 :d 4 :e 17)

* cl-delete

#+BEGIN_SRC elisp :results value pp
;; old will be changed by `cl-delete'
(let* ((old (list 0 1 2 0))
       (new (cl-delete 0 old :test #'=)))
  (list new old))
#+END_SRC

#+RESULTS:
: ((1 2)
:  (0 1 2))

* cl-delete-duplicates

#+BEGIN_SRC elisp
(cl-delete-duplicates (list 1 2 3 3 2 1) :test #'=)
#+END_SRC

#+RESULTS:
: (3 2 1)

* cl-destructuring-bind

#+BEGIN_SRC elisp
(cl-destructuring-bind (_ b c) (list 1 2 3)
  (list b c))
#+END_SRC

#+RESULTS:
: (2 3)

* cl-digit-char-p

#+BEGIN_SRC elisp
(cl-digit-char-p ?F 16)
#+END_SRC

#+RESULTS:
: 15

* cl-do

#+BEGIN_SRC elisp
(let (res)
  (cl-do ((x '(1 2 3) (cdr x))
          (y '(4 5 6 7) (cdr y)))
      ((not (and x y)) (nreverse res))
    (push (cons (car x) (car y)) res)))
#+END_SRC

#+RESULTS:
: ((1 . 4)
:  (2 . 5)
:  (3 . 6))

* cl-do-all-symbols

#+BEGIN_SRC elisp
(let (cmds)
  (cl-do-all-symbols (sym)
    (when (commandp sym)
      (push sym cmds)))
  (message "There are %d Emacs commands right now" (length cmds)))
#+END_SRC

#+RESULTS:
: "There are 8173 Emacs commands right now"

* cl-do-symbols

#+BEGIN_SRC elisp
(let (cmds)
  (cl-do-symbols (sym)
    (when (commandp sym)
      (push sym cmds)))
  (message "There are %d Emacs commands right now" (length cmds)))
#+END_SRC

#+RESULTS:
: "There are 8173 Emacs commands right now"

* cl-dolist

#+BEGIN_SRC elisp
(cl-dolist (i '(1 2 3 4))
  (when (> i 2)
    (cl-return i)))
#+END_SRC

#+RESULTS:
: 3

* cl-dotimes

#+BEGIN_SRC elisp
(cl-dotimes (i 10)
  (when (> i 3)
    (cl-return i)))
#+END_SRC

#+RESULTS:
: 4

* cl-ecase

#+BEGIN_SRC elisp
(condition-case err
    (cl-ecase 4
      ((1 2 3) 'do-something))
  (error err))
#+END_SRC

#+RESULTS:
: (error "cl-ecase failed: 4, (3 2 1)")

* cl-equalp

#+BEGIN_SRC elisp
(cl-equalp 3 3.0)
#+END_SRC

#+RESULTS:
: t

* cl-etypecase

#+BEGIN_SRC elisp
(condition-case err
    (cl-etypecase 42
      (float 'float))
  (error err))
#+END_SRC

#+RESULTS:
: (error "cl-etypecase failed: 42, (float)")

* cl-evenp

#+BEGIN_SRC elisp
(cl-evenp 0)
#+END_SRC

#+RESULTS:
: t

* cl-every

#+BEGIN_SRC elisp
(cl-every #'cl-evenp [0 2 4 6])
#+END_SRC

#+RESULTS:
: t

* cl-fill

#+BEGIN_SRC elisp
(cl-fill (list 1 2 3) 0)
#+END_SRC

#+RESULTS:
: (0 0 0)

* cl-find

#+BEGIN_SRC elisp
(cl-find ?o "hello" :test #'=)
#+END_SRC

#+RESULTS:
: 111

* cl-find-if

#+BEGIN_SRC elisp
(cl-find-if #'cl-evenp '(1 2 3 4))
#+END_SRC

#+RESULTS:
: 2

* cl-find-if-not

#+BEGIN_SRC elisp
(cl-find-if-not #'zerop '(0 0 0 1 2))
#+END_SRC

#+RESULTS:
: 1

* cl-flet

#+BEGIN_SRC elisp
(cl-flet ((mean
           (numbers)
           (/ (apply #'+ numbers)
              (float (length numbers)))))
  (mean '(1 2 3 4)))
#+END_SRC

#+RESULTS:
: 2.5

* cl-flet*

#+BEGIN_SRC elisp
(cl-flet* ((mean
            (numbers)
            (/ (apply #'+ numbers)
               (float (length numbers))))
           (variance
            (numbers)
            (let ((m (mean numbers)))
              (/ (apply #'+ (mapcar (lambda (x) (expt (- x m) 2)) numbers))
                 (float (length numbers))))))
  (variance '(1 2 3 4)))
#+END_SRC

#+RESULTS:
: 1.25

* cl-floor

#+BEGIN_SRC elisp
(cl-floor 10 3)
#+END_SRC

#+RESULTS:
: (3 1)

* cl-gcd

#+BEGIN_SRC elisp
(cl-gcd 4 6)
#+END_SRC

#+RESULTS:
: 2

* cl-generic-p
:PROPERTIES:
:added:    26.1
:END:

#+BEGIN_SRC elisp :results silent
(cl-generic-p #'seq-map)
#+END_SRC

* cl-incf

#+BEGIN_SRC elisp
(let ((x 0))
  (cl-incf x)
  x)
#+END_SRC

#+RESULTS:
: 1

#+BEGIN_SRC elisp
(let ((nums (list 1 2 3)))
  (cl-incf (cadr nums) 100)
  nums)
#+END_SRC

#+RESULTS:
: (1 102 3)

* cl-intersection

#+BEGIN_SRC elisp
(cl-intersection '(1 2 3) '(2 3 4))
#+END_SRC

#+RESULTS:
: (3 2)

* cl-isqrt

#+BEGIN_SRC elisp
(cl-isqrt 27)
#+END_SRC

#+RESULTS:
: 5

* cl-labels

#+BEGIN_SRC elisp
(cl-labels ((len
             (l)
             (if l
                 (1+ (len (cdr l)))
               0)))
  (len '(a b c d e)))
#+END_SRC

#+RESULTS:
: 5

* cl-lcm

#+BEGIN_SRC elisp
(cl-lcm 4 6)
#+END_SRC

#+RESULTS:
: 12

* cl-ldiff

#+BEGIN_SRC elisp
(let ((l (list 1 2 3 4)))
  (cl-ldiff l (cddr l)))
#+END_SRC

#+RESULTS:
: (1 2)

* cl-letf

#+BEGIN_SRC elisp
(cl-letf (((symbol-function 'emacs-version) #'ignore))
  (emacs-version))
#+END_SRC

#+RESULTS:
: nil

* cl-letf*

#+BEGIN_SRC elisp
(let ((lst (list 1 2 3 4)))
  (cl-letf* (((car lst) 100)
             ((car lst) 200))
    (format "%s" lst)))
#+END_SRC

#+RESULTS:
: "(200 2 3 4)"

* cl-loop

#+BEGIN_SRC elisp
(cl-loop for i from 1 to 5
         collect i)
#+END_SRC

#+RESULTS:
: (1 2 3 4 5)

* cl-macrolet

#+BEGIN_SRC elisp
(cl-macrolet ((inc (var) `(setq ,var (1+ ,var))))
  (let ((x 42))
    (inc x)
    x))
#+END_SRC

#+RESULTS:
: 43

* cl-map

#+BEGIN_SRC elisp
(cl-map 'vector #'1+ '(1 2 3))
#+END_SRC

#+RESULTS:
: [2 3 4]

* cl-mapc

#+BEGIN_SRC elisp
(cl-mapc #'message ["Hi, %s" "Hello, %s"] '(Emacs Tom))
#+END_SRC

#+RESULTS:
: ["Hi, %s" "Hello, %s"]

* cl-mapcan

#+BEGIN_SRC elisp
(cl-mapcan
 (lambda (pair)
   (let ((key (car pair))
         (val (cdr pair)))
     (list (intern (format ":%s" key)) val)))
 '((x . 1) (y . 2) (z . 3)))
#+END_SRC

#+RESULTS:
: (:x 1 :y 2 :z 3)

#+BEGIN_SRC elisp
(cl-mapcan #'make-list '(1 2 3) '(a b c))
#+END_SRC

#+RESULTS:
: (a b b c c c)

* cl-mapcar

#+BEGIN_SRC elisp
(cl-mapcar #'cons '(a b c) '(1 2 3))
#+END_SRC

#+RESULTS:
: ((a . 1)
:  (b . 2)
:  (c . 3))

* cl-mapcon

#+BEGIN_SRC elisp
(cl-mapcon #'copy-sequence '(1 2 3))
#+END_SRC

#+RESULTS:
: (1 2 3 2 3 3)

* cl-mapl

#+BEGIN_SRC elisp :results output
(cl-mapl #'princ '(1 2 3))
#+END_SRC

#+RESULTS:
: "(1 2 3)(2 3)(3)"

* cl-maplist

#+BEGIN_SRC elisp
(cl-maplist #'identity '(1 2 3))
#+END_SRC

#+RESULTS:
: ((1 2 3)
:  (2 3)
:  (3))

* cl-member

#+BEGIN_SRC elisp
(cl-member 2 '(1 2 3 4) :test #'=)
#+END_SRC

#+RESULTS:
: (2 3 4)

* cl-member-if

#+BEGIN_SRC elisp
(cl-member-if #'cl-evenp '(1 2 3 4))
#+END_SRC

#+RESULTS:
: (2 3 4)

* cl-member-if-not

#+BEGIN_SRC elisp
(cl-member-if-not #'cl-evenp '(0 2 3 4 5))
#+END_SRC

#+RESULTS:
: (3 4 5)

* cl-merge

#+BEGIN_SRC elisp
(cl-merge 'list '(1 4 6) '(2 3 5) #'<)
#+END_SRC

#+RESULTS:
: (1 2 3 4 5 6)

* cl-minusp

#+BEGIN_SRC elisp
(cl-minusp -1)
#+END_SRC

#+RESULTS:
: t

* cl-mismatch

#+BEGIN_SRC elisp
(cl-mismatch "HELLO" "hello1" :key #'upcase)
#+END_SRC

#+RESULTS:
: 5

* cl-mod

#+BEGIN_SRC elisp
(cl-mod 10 3)
#+END_SRC

#+RESULTS:
: 1

* cl-notany

#+BEGIN_SRC elisp
(cl-notany #'zerop [1 2 3])
#+END_SRC

#+RESULTS:
: t

* cl-notevery

#+BEGIN_SRC elisp
(cl-notevery #'zerop [0 0 0 0])
#+END_SRC

#+RESULTS:
: nil

* cl-nsubst

#+BEGIN_SRC elisp
(let ((l (list 1 0 (list 0 1))))
  (cl-nsubst :one 1 l :test #'eq)
  l)
#+END_SRC

#+RESULTS:
: (:one 0
:       (0 :one))

* cl-nsubstitute

#+BEGIN_SRC elisp
(cl-nsubstitute :new :old (list 1 :old 2 :old) :test #'eq)
#+END_SRC

#+RESULTS:
: (1 :new 2 :new)

* cl-nsubstitute-if

#+BEGIN_SRC elisp
(cl-nsubstitute-if :zero #'zerop (list 1 0 1 0))
#+END_SRC

#+RESULTS:
: (1 :zero 1 :zero)

* cl-nsubstitute-if-not

#+BEGIN_SRC elisp
(cl-substitute-if-not :not-zero #'zerop (list 1 0 1 0))
#+END_SRC

#+RESULTS:
: (:not-zero 0 :not-zero 0)

* cl-oddp

#+BEGIN_SRC elisp
(cl-oddp 1)
#+END_SRC

#+RESULTS:
: t

* cl-parse-integer
:PROPERTIES:
:added:    25.1
:END:

#+BEGIN_SRC elisp
(cl-parse-integer "400" :radix #x10)
#+END_SRC

#+RESULTS:
: 1024

* cl-plusp

#+BEGIN_SRC elisp
(cl-plusp 1)
#+END_SRC

#+RESULTS:
: t

* cl-position

#+BEGIN_SRC elisp
(cl-position "bar" '("foo" "bar" "bar") :test #'equal)
#+END_SRC

#+RESULTS:
: 1

* cl-position-if

#+BEGIN_SRC elisp
(cl-position-if #'zerop '(1 1 1 0 0))
#+END_SRC

#+RESULTS:
: 3

* cl-position-if-not

#+BEGIN_SRC elisp
(cl-position-if-not #'zerop '(0 0 0 1 2))
#+END_SRC

#+RESULTS:
: 3

* cl-progv

#+BEGIN_SRC elisp
(cl-progv (list (intern "x")) (list 42)
  x)
#+END_SRC

#+RESULTS:
: 42

* cl-psetf

#+BEGIN_SRC elisp
(let (x y z)
  (cl-psetf x (setq z 1)
            y (setq z 2))
  (list x y z))
#+END_SRC

#+RESULTS:
: (1 2 2)

* cl-psetq

#+BEGIN_SRC elisp
(let ((x 1)
      (y 2))
  (cl-psetq x y
            y x)
  (list x y))
#+END_SRC

#+RESULTS:
: (2 1)

* cl-pushnew

#+BEGIN_SRC elisp
(let ((l (list 1 2 3)))
  (cl-pushnew 0 l :test #'=)
  (cl-pushnew 2 l :test #'=)
  (cl-pushnew 4 l :test #'=)
  l)
#+END_SRC

#+RESULTS:
: (4 0 1 2 3)

* cl-random

#+BEGIN_SRC elisp
(cl-random 10)
#+END_SRC

#+RESULTS:
: 7

* cl-random-state-p

#+BEGIN_SRC elisp
(cl-random-state-p (cl-make-random-state))
#+END_SRC

#+RESULTS:
: t

* cl-reduce

#+BEGIN_SRC elisp
(cl-reduce #'+ [1 2 3])
#+END_SRC

#+RESULTS:
: 6

* cl-rem

#+BEGIN_SRC elisp
(cl-rem 10 3)
#+END_SRC

#+RESULTS:
: 1

* cl-remove

#+BEGIN_SRC elisp
(cl-remove 0 [0 1 2 0] :test #'=)
#+END_SRC

#+RESULTS:
: [1 2]

* cl-remove-duplicates

#+BEGIN_SRC elisp
(cl-remove-duplicates (list 1 nil 2 () 1) :test #'eq)
#+END_SRC

#+RESULTS:
: (2 nil 1)

* cl-remove-if

#+BEGIN_SRC elisp
(cl-remove-if (lambda (elt) (< elt 0)) '(0 1 -1 3 -3 5))
#+END_SRC

#+RESULTS:
: (0 1 3 5)

* cl-replace

#+BEGIN_SRC elisp
(cl-replace (list 0 0 3 4) (list 1 2))
#+END_SRC

#+RESULTS:
: (1 2 3 4)

* cl-return

#+BEGIN_SRC elisp
(cl-dolist (i '(1 2 3 4 5))
  (when (> i 3)
    (cl-return i)))
#+END_SRC

#+RESULTS:
: 4

* cl-return-from

#+BEGIN_SRC elisp
(cl-block 'found
  (dolist (i '(1 2 3 4 5))
    (when (> i 3)
      (cl-return-from 'found i))))
#+END_SRC

#+RESULTS:
: 4

* cl-rotatef

#+BEGIN_SRC elisp
(seq-let [a b c d] [1 2 3 4]
  (cl-rotatef a b c d)
  (list a b c d))
#+END_SRC

#+RESULTS:
: (2 3 4 1)

* cl-round

#+BEGIN_SRC elisp
(cl-round 3 2)
#+END_SRC

#+RESULTS:
: (2 -1)

* cl-search

#+BEGIN_SRC elisp
(cl-search "ar" "foobarzzzzz" :test #'=)
#+END_SRC

#+RESULTS:
: 4

* cl-set-difference

#+BEGIN_SRC elisp
(cl-set-difference '(1 2 3 4) '(2 3))
#+END_SRC

#+RESULTS:
: (1 4)

#+BEGIN_SRC elisp
(cl-set-difference '("foo" "bar") '("foo") :test #'equal)
#+END_SRC

#+RESULTS:
: ("bar")

* cl-set-exclusive-or

#+BEGIN_SRC elisp
(cl-set-exclusive-or '(1 2 3) '(2 3 4))
#+END_SRC

#+RESULTS:
: (1 4)

* cl-shiftf

#+BEGIN_SRC elisp
(seq-let [a b c d] [1 2 3 4]
  (cl-shiftf a b c d)
  (list a b c d))
#+END_SRC

#+RESULTS:
: (2 3 4 4)

* cl-some

#+BEGIN_SRC elisp
(cl-some #'cdr '(nil (1) (2 . 3) (4 5)))
#+END_SRC

#+RESULTS:
: 3

* cl-sort

#+BEGIN_SRC elisp
(cl-sort (list (cons 1 4)
               (cons 3 6)
               (cons 2 5))
         #'<
         :key #'car)
#+END_SRC

#+RESULTS:
: ((1 . 4)
:  (2 . 5)
:  (3 . 6))

* cl-stable-sort

#+BEGIN_SRC elisp
(cl-stable-sort (list (cons 1 4)
                      (cons 3 6)
                      (cons 2 5)
                      (cons 3 0))
                #'<
                :key #'car)
#+END_SRC

#+RESULTS:
: ((1 . 4)
:  (2 . 5)
:  (3 . 6)
:  (3 . 0))

* cl-subseq

#+BEGIN_SRC elisp
(cl-subseq '(a b c d) 1 3)
#+END_SRC

#+RESULTS:
: (b c)

* cl-subsetp

#+BEGIN_SRC elisp
(cl-subsetp '(1 3) '(1 2 3 4))
#+END_SRC

#+RESULTS:
: t

* cl-subst

#+BEGIN_SRC elisp
(cl-subst "1" 1 '(1 0 (1 0)) :test #'eq)
#+END_SRC

#+RESULTS:
: ("1" 0
:  ("1" 0))

* cl-substitute

#+BEGIN_SRC elisp
(cl-substitute ?A ?a "|aaa|" :test #'=)
#+END_SRC

#+RESULTS:
: "|AAA|"

* cl-substitute-if

#+BEGIN_SRC elisp
(cl-substitute-if :zero #'zerop '(1 0 1 0))
#+END_SRC

#+RESULTS:
: (1 :zero 1 :zero)

* cl-substitute-if-not

#+BEGIN_SRC elisp
(cl-substitute-if-not :not-zero #'zerop '(1 0 1 0))
#+END_SRC

#+RESULTS:
: (:not-zero 0 :not-zero 0)

* cl-symbol-macrolet

#+BEGIN_SRC elisp
(let ((pair (cons 5 9)))
  (cl-symbol-macrolet ((x (car pair)))
    (cl-incf x))
  pair)
#+END_SRC

#+RESULTS:
: (6 . 9)

* cl-tailp

#+BEGIN_SRC elisp
(let* ((x '(3 4))
       (y `(1 2 ,@x)))
  (cl-tailp x y))
#+END_SRC

#+RESULTS:
: t

* cl-tree-equal

#+BEGIN_SRC elisp
(cl-tree-equal '(?a . (?b . ?c))
               '(?A . (?B . ?C))
               :test #'=
               :key #'upcase)
#+END_SRC

#+RESULTS:
: t

* cl-truncate

#+BEGIN_SRC elisp
(cl-truncate 10 3)
#+END_SRC

#+RESULTS:
: (3 1)

* cl-typecase

#+BEGIN_SRC elisp
(mapcar (lambda (x)
          (cl-typecase x
            (integer 'integer)
            (float   'float)
            (string 'string)
            (t 'anything-else)))
        (list 42 float-pi emacs-version (current-time)))
#+END_SRC

#+RESULTS:
: (integer float string anything-else)

* cl-typep

#+BEGIN_SRC elisp
(cl-typep 42 'integer)
#+END_SRC

#+RESULTS:
: t

* cl-union

#+BEGIN_SRC elisp
(cl-union '(1 2 3) '(2 3 4))
#+END_SRC

#+RESULTS:
: (4 1 2 3)

* cl-values-list
:PROPERTIES:
:changes:  27.1 'cl-values-list' will now signal an error if its argument isn't a list.
:END:

#+BEGIN_SRC elisp
(cl-values-list (list 1 2 3))
#+END_SRC

#+RESULTS:
: (1 2 3)

* class-p

#+BEGIN_SRC elisp
(defclass my-class () () "My Class.")
(class-p 'my-class)
#+END_SRC

#+RESULTS:
: t

* clear-string

#+BEGIN_SRC elisp
(let ((password "123456"))
  (clear-string password)
  (string-to-list password))
#+END_SRC

#+RESULTS:
: (0 0 0 0 0 0)

* clrhash

#+BEGIN_SRC elisp
(let ((table (make-hash-table)))
  (puthash 'x 1 table)
  (puthash 'y 2 table)
  (clrhash table)
  table)
#+END_SRC

#+RESULTS:
: #s(hash-table size 65 test eql rehash-size 1.5 rehash-threshold 0.8125 data
: ())

* coding-system-aliases

#+BEGIN_SRC elisp
(coding-system-aliases 'chinese-gbk)
#+END_SRC

#+RESULTS:
: (chinese-gbk gbk cp936 windows-936)

* coding-system-change-eol-conversion

#+BEGIN_SRC elisp
(coding-system-change-eol-conversion 'utf-8 'unix)
#+END_SRC

#+RESULTS:
: utf-8-unix

* coding-system-change-text-conversion

#+BEGIN_SRC elisp
(coding-system-change-text-conversion 'unix 'utf-8)
#+END_SRC

#+RESULTS:
: utf-8-unix

* coding-system-eol-type

#+BEGIN_SRC elisp
(coding-system-eol-type 'utf-8)
#+END_SRC

#+RESULTS:
: [utf-8-unix utf-8-dos utf-8-mac]

* coding-system-get

#+BEGIN_SRC elisp
(coding-system-get 'chinese-gbk :mime-charset)
#+END_SRC

#+RESULTS:
: gbk

* coding-system-list

#+BEGIN_SRC elisp
(length (coding-system-list 'base-only))
#+END_SRC

#+RESULTS:
: 116

* coding-system-p

#+BEGIN_SRC elisp
(coding-system-p 'utf-8)
#+END_SRC

#+RESULTS:
: t

* color-complement

#+BEGIN_SRC elisp
(color-complement "green")
#+END_SRC

#+RESULTS:
: (1.0 0.0 1.0)

* color-name-to-rgb

#+BEGIN_SRC elisp
(color-name-to-rgb "green")
#+END_SRC

#+RESULTS:
: (0.0 1.0 0.0)

* color-rgb-to-hex

#+BEGIN_SRC elisp
(color-rgb-to-hex 0.0 1.0 0.0 2)
#+END_SRC

#+RESULTS:
: "#00ff00"

* color-rgb-to-hsl

#+BEGIN_SRC elisp
(color-rgb-to-hsl #x86 #xDE #xFA)
#+END_SRC

#+RESULTS:
: (0.5 -0.3036649214659686 192.0)

* color-values

#+BEGIN_SRC elisp
(color-values "green")
#+END_SRC

#+RESULTS:
: (0 65535 0)

* color-values-from-color-spec
:PROPERTIES:
:added:    28.1
:END:

#+BEGIN_SRC elisp
(color-values-from-color-spec "#FF0000")
#+END_SRC

#+RESULTS:
: (65535 0 0)

* combine-and-quote-strings

#+BEGIN_SRC elisp
(combine-and-quote-strings '("-o" "foo bar.txt"))
#+END_SRC

#+RESULTS:
: "-o \"foo bar.txt\""

* commandp

#+BEGIN_SRC elisp
(commandp #'next-line)
#+END_SRC

#+RESULTS:
: t

* compare-buffer-substrings

#+BEGIN_SRC elisp
(with-temp-buffer
  (insert "foo foobar")
  (compare-buffer-substrings nil 1 4 nil 5 8))
#+END_SRC

#+RESULTS:
: 0

* compare-strings

#+BEGIN_SRC elisp
(compare-strings "hello" nil nil "he" nil nil)
#+END_SRC

#+RESULTS:
: 3

* compiled-function-p
:PROPERTIES:
:added:    29.1
:END:

#+BEGIN_SRC elisp
(compiled-function-p (symbol-function 'car))
#+END_SRC

#+RESULTS:
: t

* completing-read
:PROPERTIES:
:changes:  29.1 Allows a function as its REQUIRE-MATCH argument.
:END:

#+BEGIN_SRC elisp
(completing-read "Enter a name: " '("Tom" "Jerry" "Spike" "Tyke"))
#+END_SRC

#+RESULTS:
: "Tom"

#+BEGIN_SRC elisp
(completing-read "M-x " obarray #'commandp)
#+END_SRC

#+RESULTS:
: "emacs-version"

* completing-read-multiple

#+BEGIN_SRC elisp
(completing-read-multiple "> " '("alice" "bob" "eve"))
#+END_SRC

#+RESULTS:
: ("alice" "bob")

* completion-table-dynamic

#+BEGIN_SRC elisp :results silent
(completing-read
 "> "
 (completion-table-dynamic
  (lambda (s)
    (list (concat s "123")
          (concat s "456")))))
#+END_SRC

* completion-table-with-cache

#+BEGIN_SRC elisp :results silent
(completing-read
 "> "
 (completion-table-with-cache
  (lambda (input)
    (message "=> Caching %s" input)
    (with-temp-buffer
      (call-process "seq" nil t nil input)
      (cl-loop for line in (split-string (buffer-string) "\n" t)
               collect (concat input line))))))
#+END_SRC

* concat

#+BEGIN_SRC elisp
(concat "hello" " world")
#+END_SRC

#+RESULTS:
: "hello world"

* cond

#+BEGIN_SRC elisp
(let ((x 42))
  (cond ((= x 0) 'zero)
        ((> x 0) 'positive)
        (t 'negative)))
#+END_SRC

#+RESULTS:
: positive

* condition-case
:PROPERTIES:
:changes:  27.1 A CONDITION-NAME of t applies to any symbol.
:changes+:  28.1 'condition-case' now allows for a success handler.
:END:

#+BEGIN_SRC elisp
(condition-case err
    (/ 1 0)
  (arith-error
   (message "%s" (error-message-string err))
   nil))
#+END_SRC

#+RESULTS:
: nil

* condition-case-unless-debug
:PROPERTIES:
:added:    24.1
:END:

#+BEGIN_SRC elisp
(condition-case-unless-debug nil
    (/ 1 0)
  (error nil))
#+END_SRC

#+RESULTS:
: nil

* cons

#+BEGIN_SRC elisp
(cons 1 (cons 2 (cons 3 nil)))
#+END_SRC

#+RESULTS:
: (1 2 3)

* consp

#+BEGIN_SRC elisp
(consp '(1 . 2))
#+END_SRC

#+RESULTS:
: t

#+BEGIN_SRC elisp
(consp '(1 2 3))
#+END_SRC

#+RESULTS:
: t

#+BEGIN_SRC elisp
(consp '())
#+END_SRC

#+RESULTS:
: nil

* controlling-tty-p

#+BEGIN_SRC elisp
(list window-system (controlling-tty-p))
#+END_SRC

#+RESULTS:
: (mac nil)

* convert-standard-filename

#+BEGIN_SRC elisp
(convert-standard-filename "etc/")
#+END_SRC

#+RESULTS:
: "etc/"

* copy-alist

#+BEGIN_SRC elisp
(let* ((alist (list (list 1 2 2)
                    (list 3 4 4)
                    (list 5 6 6)))
       (copy (copy-alist alist)))
  (list (eq (alist-get 1 alist)
            (alist-get 1 copy))
        (setcdr (assq 1 copy) '(22 22))
        (eq (alist-get 1 alist)
            (alist-get 1 copy))))
#+END_SRC

#+RESULTS:
: (t
:  (22 22)
:  nil)

* copy-hash-table

#+BEGIN_SRC elisp
(copy-hash-table #s(hash-table data (x 1 y 2)))
#+END_SRC

#+RESULTS:
: #s(hash-table size 65 test eql rehash-size 1.5 rehash-threshold 0.8125 data
: (x 1 y 2))

* copy-keymap

#+BEGIN_SRC elisp
(equal (current-local-map) (copy-keymap (current-local-map)))
#+END_SRC

#+RESULTS:
: t

* copy-sequence

#+BEGIN_SRC elisp
(let* ((x '(1 2 3 4))
       (y x)
       (z (copy-sequence x)))
  (setq x (nreverse x))
  (list :reversed x
        :modified y
        :copied z))
#+END_SRC

#+RESULTS:
: (:reversed
:  (4 3 2 1)
:  :modified
:  (1)
:  :copied
:  (1 2 3 4))

* copy-tree

#+BEGIN_SRC elisp
(let* ((list '((1 2)))
       (shallow-copy (copy-sequence list))
       (deep-copy (copy-tree list)))
  (cl-assert      (eq (car shallow-copy) (car list)))
  (cl-assert (not (eq (car deep-copy) (car list)))))
#+END_SRC

#+RESULTS:
: nil

* copysign

#+BEGIN_SRC elisp
(copysign 4.0 -1.0)
#+END_SRC

#+RESULTS:
: -4.0

* cos

#+BEGIN_SRC elisp
(cos 0)
#+END_SRC

#+RESULTS:
: 1.0

* count-lines

#+BEGIN_SRC elisp
(with-temp-buffer
  (insert "foo\n"
          "bar\n"
          "baz\n")
  (count-lines (point-min) (point-max)))
#+END_SRC

#+RESULTS:
: 3

* create-image

#+BEGIN_SRC elisp :results silent
(message (propertize " " 'display (create-image "splash.png")))
(sit-for 3)
#+END_SRC

#+begin_src elisp :results silent
(create-image
 ;; binary data
 (with-temp-buffer
   (set-buffer-multibyte nil)
   (insert-file-contents-literally
    (expand-file-name "images/splash.png" data-directory))
   (buffer-string))
 'png 'data)
#+end_src

* current-active-maps

#+BEGIN_SRC elisp
(length (current-active-maps))
#+END_SRC

#+RESULTS:
: 10

* current-buffer

#+BEGIN_SRC elisp
(current-buffer)
#+END_SRC

#+RESULTS:
: #<buffer elisp-demos.org>

* current-column

#+BEGIN_SRC elisp
(with-temp-buffer
  (insert "hello")
  (current-column))
#+END_SRC

#+RESULTS:
: 5

* current-cpu-time
:PROPERTIES:
:added:    29.1
:END:

#+BEGIN_SRC elisp
(current-cpu-time)
#+END_SRC

#+RESULTS:
: (66672543 . 1000000)

* current-idle-time

#+BEGIN_SRC elisp
(run-at-time 3 nil
             (lambda ()
               (sit-for 1)
               (message "=> %s" (time-to-seconds (current-idle-time)))))
#+END_SRC

#+RESULTS:
: [nil 23532 38890 487039 nil
:      (lambda nil
:        (sit-for 1)
:        (message "=> %s"
:                 (time-to-seconds
:                  (current-idle-time))))
:      nil nil 0]

* current-kill

#+BEGIN_SRC elisp
(progn (kill-new "hello")
       (list (current-kill 0 'do-not-move)
             (car kill-ring)))
#+END_SRC

#+RESULTS:
: ("hello" "hello")

* current-message

#+BEGIN_SRC elisp
(progn
  (message "Hello World")
  (current-message))
#+END_SRC

#+RESULTS:
: "Hello World"

* current-thread

#+BEGIN_SRC elisp
(current-thread)
#+END_SRC

#+RESULTS:
: #<thread 0x10061fef8>

* current-time

#+BEGIN_SRC elisp
(current-time)
#+END_SRC

#+RESULTS:
: (23532 37172 685559 0)

* current-time-string

#+BEGIN_SRC elisp
(current-time-string)
#+END_SRC

#+RESULTS:
: "Thu Nov 15 05:18:28 2018"

* current-time-zone

#+BEGIN_SRC elisp
(current-time-zone)
#+END_SRC

#+RESULTS:
: (28800 "CST")

* date-days-in-month
:PROPERTIES:
:added:    27.1
:END:

#+BEGIN_SRC elisp
(date-days-in-month 2020 2)
#+END_SRC

#+RESULTS:
: 29

* date-leap-year-p

#+BEGIN_SRC elisp
(date-leap-year-p 2018)
#+END_SRC

#+RESULTS:
: nil

* date-to-time

#+BEGIN_SRC elisp
(date-to-time "Fri, 25 Mar 2016 16:24:56 +0100")
#+END_SRC

#+RESULTS:
: (22261 22600)

* declare
:PROPERTIES:
:changes:  25.1 interactive-only is added.
:changes+:  28.1 completion and modes are added.
:END:

#+BEGIN_SRC elisp
(defun greeting ()
  (declare (interactive-only "Use `message' instead."))
  (interactive)
  (message "Hello"))
#+END_SRC

#+RESULTS:
: greeting

* declare-function

#+BEGIN_SRC elisp
(declare-function dired-jump "dired-x" (&optional other-window file-name))
#+END_SRC

* decode-char

#+BEGIN_SRC elisp
(decode-char 'unicode ?Î»)
#+END_SRC

#+RESULTS:
: 955

#+BEGIN_SRC elisp
;; æ–‡ GBK Codepoint #xCEC4
(string (decode-char 'chinese-gbk #xCEC4))
#+END_SRC

#+RESULTS:
: "æ–‡"

* decode-coding-region

#+BEGIN_SRC elisp
(with-temp-buffer
  (set-buffer-multibyte nil)
  (insert #xCE #xC4)
  (decode-coding-region (point-min) (point-max) 'chinese-gbk t))
#+END_SRC

#+RESULTS:
: #("æ–‡" 0 1
:   (charset chinese-gbk))

* decode-coding-string

#+BEGIN_SRC elisp
;; (string-to-vector (encode-coding-string "å¥½" 'chinese-gbk))
;; => [186 195]

(decode-coding-string (unibyte-string 186 195) 'chinese-gbk)

;; This does NOT work
;; (decode-coding-string (string 186 195) 'chinese-gbk)
;;
;; (multibyte-string-p (unibyte-string 186 195))
;; => nil
;; (multibyte-string-p (string 186 195))
;; => t
#+END_SRC

#+RESULTS:
: #("å¥½" 0 1
:   (charset chinese-gbk))

#+BEGIN_SRC elisp
(decode-coding-string (unibyte-string #xE5 #xA5 #xBD) 'utf-8)
#+END_SRC

#+RESULTS:
: "å¥½"

* decode-time
:PROPERTIES:
:changes:  27.1 The optional FORM argument is added.
:END:

#+BEGIN_SRC elisp
(decode-time)
#+END_SRC

#+RESULTS:
: (42 20 5 15 11 2018 4 nil 28800)

* defalias

#+BEGIN_SRC elisp :eval no
(defalias '\` (symbol-function 'backquote))
#+END_SRC

* defclass

#+BEGIN_SRC elisp
(defclass person ()
  ((name :initarg :name)
   (age :initarg :age)))

(cl-defmethod say-hi ((p person))
  (message "Hi, I'm %s and %d years old"
           (oref p :name)
           (oref p :age)))

(say-hi (person :name user-full-name :age 26))
#+END_SRC

#+RESULTS:
: "Hi, I'm Xu Chunyang and 26 years old"

* defconst

#+BEGIN_SRC elisp :eval no
(defconst foo-pi 3.141592653589793
  "The value of Pi.")
#+END_SRC

* defcustom
:PROPERTIES:
:changes:  27.1 :local is added.
:END:

#+BEGIN_SRC elisp :eval no
(defcustom magit-git-executable "git"
  "The Git executable used by Magit."
  :group 'magit-process
  :type 'string)
#+END_SRC

* defface

#+BEGIN_SRC elisp :eval no
(defface highlight
  '((((class color) (min-colors 88) (background light))
     :background "darkseagreen2")
    (((class color) (min-colors 88) (background dark))
     :background "darkolivegreen")
    (((class color) (min-colors 16) (background light))
     :background "darkseagreen2")
    (((class color) (min-colors 16) (background dark))
     :background "darkolivegreen")
    (((class color) (min-colors 8))
     :background "green" :foreground "black")
    (t :inverse-video t))
  "Basic face for highlighting."
  :group 'basic-faces)
#+END_SRC

* defgroup

#+BEGIN_SRC elisp :eval no
(defgroup magit-status nil
  "Inspect and manipulate Git repositories."
  :link '(info-link "(magit)Status Buffer")
  :group 'magit-modes)
#+END_SRC

* defimage

#+BEGIN_SRC elisp
(defimage my-splash-image
  ((:type svg :file "splash.svg")
   (:type png :file "splash.png")))
#+END_SRC

#+RESULTS:
: my-splash-image

* define-advice
:PROPERTIES:
:added:    25.1
:END:

#+BEGIN_SRC elisp :eval no
(define-advice shell-command (:after (&rest _) trim-trailing-newline)
  "Delete the annoying trailing newline after C-u M-!."
  (when (and (eq this-command 'shell-command)
             current-prefix-arg)
    (exchange-point-and-mark t)
    (when (eq (char-before) ?\n)
      (delete-char -1))))

;; (advice-remove 'shell-command #'shell-command@trim-trailing-newline)
#+END_SRC

* define-error
:PROPERTIES:
:added:    24.4
:END:

#+BEGIN_SRC elisp :eval no
(define-error 'foo-error "A new error")
#+END_SRC

* define-key

#+BEGIN_SRC elisp :eval no
(define-key (current-global-map) (kbd "C-c C-c") #'emacs-version)
#+END_SRC

* define-key-after

#+BEGIN_SRC elisp
(define-key-after
  (lookup-key shell-mode-map [menu-bar signals])
  [work] '("Work" . work-command) 'break)
#+END_SRC

#+RESULTS:
: nil

* define-minor-mode
:PROPERTIES:
:changes:  28.1 'define-minor-mode' now takes an ':interactive' argument.
:END:

#+BEGIN_SRC elisp
(define-minor-mode display-point-mode
  "Display of point position using the mode line."
  :lighter (:eval (format " %d" (point))))
#+END_SRC

#+RESULTS:
: nil

* defmacro

#+BEGIN_SRC elisp
(defmacro my-incf (var)
  `(setq ,var (1+ ,var)))

(let ((x 2))
  (my-incf x)
  x)
#+END_SRC

#+RESULTS:
: 3

* defsubst

#+BEGIN_SRC elisp :eval no
(defsubst buffer-narrowed-p ()
  "Return non-nil if the current buffer is narrowed."
  (/= (- (point-max) (point-min)) (buffer-size)))
#+END_SRC

* defun

#+BEGIN_SRC elisp
(defun add-two-numbers (a b)
  "Add A to B."
  (+ a b))

(add-two-numbers 1 2)
#+END_SRC

#+RESULTS:
: 3

* defvar

#+BEGIN_SRC elisp :eval no
(defvar foo-bar 23
  "The normal weight of a bar.")
#+END_SRC

* defvaralias

#+BEGIN_SRC elisp :eval no
(defvaralias 'messages-buffer-max-lines 'message-log-max)
#+END_SRC

* delete

#+BEGIN_SRC elisp
(let ((l (list (list 1)
               (list 2)
               (list 3)
               (list 2))))
  (setq l (delete '(2) l))
  l)
#+END_SRC

#+RESULTS:
: ((1)
:  (3))

* delete-char

#+BEGIN_SRC elisp
(with-temp-buffer
  (insert "hello\n")
  (delete-char -1)
  (buffer-string))
#+END_SRC

#+RESULTS:
: "hello"

* delete-consecutive-dups

#+BEGIN_SRC elisp
(let ((l (list 1 2 2 3 2)))
  (delete-consecutive-dups l))
#+END_SRC

#+RESULTS:
: (1 2 3 2)

* delete-dups

#+BEGIN_SRC elisp
(let ((l (list "one" "two" "one" "three")))
  (setq l (delete-dups l)))
#+END_SRC

#+RESULTS:
: ("one" "two" "three")

* delete-file

#+BEGIN_SRC elisp
(delete-file (make-temp-file "elisp-demos-"))
#+END_SRC

#+RESULTS:
: nil

* delete-overlay

#+BEGIN_SRC elisp
(with-temp-buffer
  (let ((ov (make-overlay 1 1)))
    (list (format "%S" ov)
          (delete-overlay ov)
          (format "%S" ov))))
#+END_SRC

#+RESULTS:
: ("#<overlay from 1 to 1 in  *temp*>" nil "#<overlay in no buffer>")

* delete-process

#+BEGIN_SRC elisp
;; Start the shell process if not already
(shell)

(delete-process "*shell*")
#+END_SRC

#+RESULTS:
: nil

* delq

#+BEGIN_SRC elisp
(let ((l (list 1 2 3)))
  (setq l (delq 2 l))
  l)
#+END_SRC

#+RESULTS:
: (1 3)

* derived-mode-p

#+BEGIN_SRC elisp
(with-temp-buffer
  (emacs-lisp-mode)
  (derived-mode-p 'prog-mode))
#+END_SRC

#+RESULTS:
: prog-mode

* detect-coding-region

#+BEGIN_SRC elisp
(with-temp-buffer
  (insert ?\0)
  (detect-coding-region (point-min) (point-max)))
#+END_SRC

#+RESULTS:
: (no-conversion)

* detect-coding-string

#+BEGIN_SRC elisp
(detect-coding-string (string ?\0))
#+END_SRC

#+RESULTS:
: (no-conversion)

* directory-empty-p
:PROPERTIES:
:added:    28.1
:END:

#+BEGIN_SRC elisp
(directory-empty-p "/tmp")
#+END_SRC

#+RESULTS:
: nil

* directory-file-name

#+BEGIN_SRC elisp
(directory-file-name "~/.emacs.d/")
#+END_SRC

#+RESULTS:
: "~/.emacs.d"

* directory-files

#+BEGIN_SRC elisp :results silent
(directory-files "/bin/")
#+END_SRC

#+BEGIN_SRC elisp
;; MATCH is to filter the basename (not the full path)
(directory-files user-emacs-directory 'full (rx ".el" eos))
#+END_SRC

#+RESULTS:
: ("/Users/xcy/.emacs.d/custom.el" "/Users/xcy/.emacs.d/early-init.el" "/Users/xcy/.emacs.d/init.el" "/Users/xcy/.emacs.d/package-quickstart.el" "/Users/xcy/.emacs.d/xcy.el")

* directory-files-and-attributes

#+BEGIN_SRC elisp :results silent
(directory-files-and-attributes "/bin/")
#+END_SRC

* directory-files-recursively
:PROPERTIES:
:added:    25.1
:END:

#+BEGIN_SRC elisp :results silent
(directory-files-recursively package-user-dir (rx ".txt" eos))
#+END_SRC

* directory-name-p
:PROPERTIES:
:added:    25.1
:END:

#+BEGIN_SRC elisp
(list (directory-name-p ".")
      (directory-name-p "./"))
#+END_SRC

#+RESULTS:
: (nil t)

* discard-input

#+BEGIN_SRC elisp
(progn (sleep-for 2)
       (discard-input))
#+END_SRC

#+RESULTS:
: nil

* display-backing-store

#+BEGIN_SRC elisp
(display-backing-store)
#+END_SRC

#+RESULTS:
: not-useful

* display-color-cells

#+BEGIN_SRC elisp
(display-color-cells)
#+END_SRC

#+RESULTS:
: 16777216

* display-color-p

#+BEGIN_SRC elisp
(display-color-p)
#+END_SRC

#+RESULTS:
: t

* display-graphic-p

#+BEGIN_SRC elisp
(display-graphic-p)
#+END_SRC

#+RESULTS:
: t

* display-grayscale-p

#+BEGIN_SRC elisp
(display-grayscale-p)
#+END_SRC

#+RESULTS:
: t

* display-images-p

#+BEGIN_SRC elisp
(display-images-p)
#+END_SRC

#+RESULTS:
: t

* display-mm-height

#+BEGIN_SRC elisp
(display-mm-height)
#+END_SRC

#+RESULTS:
: 180

* display-mm-width

#+BEGIN_SRC elisp
(display-mm-width)
#+END_SRC

#+RESULTS:
: 290

* display-mouse-p

#+BEGIN_SRC elisp
(display-mouse-p)
#+END_SRC

#+RESULTS:
: t

* display-pixel-height

#+BEGIN_SRC elisp
(display-pixel-height)
#+END_SRC

#+RESULTS:
: 900

* display-pixel-width

#+BEGIN_SRC elisp
(display-pixel-width)
#+END_SRC

#+RESULTS:
: 1440

* display-planes

#+BEGIN_SRC elisp
(display-planes)
#+END_SRC

#+RESULTS:
: 24

* display-popup-menus-p

#+BEGIN_SRC elisp
(display-popup-menus-p)
#+END_SRC

#+RESULTS:
: t

* display-save-under

#+BEGIN_SRC elisp
(display-save-under)
#+END_SRC

#+RESULTS:
: nil

* display-screens

#+BEGIN_SRC elisp
(display-screens)
#+END_SRC

#+RESULTS:
: 1

* display-selections-p

#+BEGIN_SRC elisp
(display-selections-p)
#+END_SRC

#+RESULTS:
: t

* display-visual-class

#+BEGIN_SRC elisp
(display-visual-class)
#+END_SRC

#+RESULTS:
: true-color

* dns-query
:PROPERTIES:
:added:    28.1
:END:

#+BEGIN_SRC elisp
(dns-query "example.com" 'NS)
#+END_SRC

#+RESULTS:
: "b.iana-servers.net"

* dns-query-asynchronous
:PROPERTIES:
:added:    28.1
:END:

#+BEGIN_SRC elisp :results silent
(dns-query-asynchronous
 "example.com"
 (lambda (result) (message "The IP Address is %s" result))
 'A)
#+END_SRC

* documentation

#+BEGIN_SRC elisp
(documentation '+)
#+END_SRC

#+RESULTS:
: "Return sum of any number of arguments, which are numbers or markers.\n\n(fn &rest NUMBERS-OR-MARKERS)"

* dolist

#+BEGIN_SRC elisp
(let (result)
  (dolist (elt '(1 2 3) result)
    (push elt result)))
#+END_SRC

#+RESULTS:
: (3 2 1)

* dolist-with-progress-reporter
:PROPERTIES:
:added:    27.1
:END:

#+BEGIN_SRC elisp :results silent
(dolist-with-progress-reporter
    (k (number-sequence 0 500))
    "Collecting some mana for Emacs..."
  (sit-for 0.01))
#+END_SRC

* dom-add-child-before

#+BEGIN_SRC elisp
(let* ((dom '(ol nil
                 (li nil "Perl")
                 (li nil "Python")
                 (li nil "PHP")))
       (python (elt (dom-by-tag dom 'li) 1)))
  (dom-add-child-before dom '(li nil "Ruby") python)
  dom)
#+END_SRC

#+RESULTS:
: (ol nil
:     (li nil "Perl")
:     (li nil "Ruby")
:     (li nil "Python")
:     (li nil "PHP"))

* dom-append-child

#+BEGIN_SRC elisp
(dom-append-child '(ol nil
                       (li nil "Perl")
                       (li nil "Python")
                       (li nil "PHP"))
                  '(li nil "Ruby"))
#+END_SRC

#+RESULTS:
: (ol nil
:     (li nil "Perl")
:     (li nil "Python")
:     (li nil "PHP")
:     (li nil "Ruby"))

* dom-attr

#+BEGIN_SRC elisp
(dom-attr '(a ((href . "https://www.gnu.org/s/emacs/")) "GNU Emacs")
          'href)
#+END_SRC

#+RESULTS:
: "https://www.gnu.org/s/emacs/"

* dom-attributes

#+BEGIN_SRC elisp
(dom-attributes '(a ((href . "https://www.gnu.org/s/emacs/")) "GNU Emacs"))
#+END_SRC

#+RESULTS:
: ((href . "https://www.gnu.org/s/emacs/"))

* dom-by-class

#+BEGIN_SRC elisp
(dom-by-class '(ol nil
                   (li ((class . "compiled")) "C")
                   (li ((class . "interpreted")) "Perl")
                   (li ((class . "interpreted")) "Python")
                   (li ((class . "interpreted")) "PHP")
                   (li ((class . "compiled")) "Java"))
              "compiled")
#+END_SRC

#+RESULTS:
: ((li
:   ((class . "compiled"))
:   "C")
:  (li
:   ((class . "compiled"))
:   "Java"))

* dom-by-id

#+BEGIN_SRC elisp
(dom-by-id '(body nil
                  (h1 nil "heading")
                  (p ((id . "output")) "Here is some output."))
           "output")
#+END_SRC

#+RESULTS:
: ((p
:   ((id . "output"))
:   "Here is some output."))

* dom-by-style

#+BEGIN_SRC elisp
(dom-by-style '(body nil
                     (h1 ((style . "color: blue")) "h1 heading")
                     (p ((style . "color: red")) "first paragraph")
                     (p ((style . "color: green")) "second paragraph"))
              (rx (or "red" "green")))
#+END_SRC

#+RESULTS:
: ((p
:   ((style . "color: red"))
:   "first paragraph")
:  (p
:   ((style . "color: green"))
:   "second paragraph"))

* dom-by-tag

#+BEGIN_SRC elisp
(dom-by-tag '(body nil
                   (nav nil
                        (ol nil
                            (li nil "Perl")
                            (li nil "Python")
                            (li nil "PHP")))
                   (h1 nil "h1 heading")
                   (p nil "paragraph"))
            'li)
#+END_SRC

#+RESULTS:
: ((li nil "Perl")
:  (li nil "Python")
:  (li nil "PHP"))

* dom-child-by-tag

#+BEGIN_SRC elisp
(dom-child-by-tag
 '(ol nil
      (li nil "Perl")
      (li nil "Python")
      (li nil "PHP"))
 'li)
#+END_SRC

#+RESULTS:
: (li nil "Perl")

* dom-children

#+BEGIN_SRC elisp
(dom-children
 '(ol nil
      (li nil "Perl")
      (li nil "Python")
      (li nil "PHP")))
#+END_SRC

#+RESULTS:
: ((li nil "Perl")
:  (li nil "Python")
:  (li nil "PHP"))

* dom-node

#+BEGIN_SRC elisp
;; <a href="https://www.gnu.org/s/emacs/">GNU Emacs</a>
(dom-node 'a '((href . "https://www.gnu.org/s/emacs/")) "GNU Emacs")
#+END_SRC

#+RESULTS:
: (a
:  ((href . "https://www.gnu.org/s/emacs/"))
:  "GNU Emacs")

* dom-non-text-children

#+BEGIN_SRC elisp
(dom-non-text-children '(div nil
                             (h1 nil "h1 heading")
                             (p nil "paragraph")
                             "some text"))
#+END_SRC

#+RESULTS:
: ((h1 nil "h1 heading")
:  (p nil "paragraph"))

* dom-parent

#+BEGIN_SRC elisp
(let* ((dom '(nav nil
                  (ol nil
                      (li nil "Perl")
                      (li nil "Python")
                      (li nil "PHP"))))
       (perl (car (dom-by-tag dom 'li))))
  (dom-parent dom perl))
#+END_SRC

#+RESULTS:
: (ol nil
:     (li nil "Perl")
:     (li nil "Python")
:     (li nil "PHP"))

* dom-pp

#+BEGIN_SRC elisp :results drawer
(with-temp-buffer
  (dom-pp '(p nil "para"))
  (buffer-string))
#+END_SRC

#+RESULTS:
:RESULTS:
(p nil
 "para")
:END:

* dom-print
:PROPERTIES:
:added:    28.1
:END:

#+BEGIN_SRC elisp :results silent
(with-temp-buffer
  (dom-print
   (with-current-buffer (url-retrieve-synchronously "http://example.com/")
     (libxml-parse-html-region url-http-end-of-headers (point-max)))
   'pretty)
  (message "%s" (buffer-string)))
#+END_SRC

* dom-remove-attribute
:PROPERTIES:
:added:    28.1
:END:

#+BEGIN_SRC elisp
(let ((dom (with-temp-buffer
             (insert "<a href='https://example.com/' target='_blank'>Example Domain</a>")
             (libxml-parse-html-region (point-min) (point-max)))))
  (dom-remove-attribute (dom-by-tag dom 'a) 'href)
  (dom-remove-attribute (dom-by-tag dom 'a) 'target)
  dom)
#+END_SRC

#+RESULTS:
: (html nil
:       (body nil
:             (a nil "Example Domain")))

* dom-remove-node

#+BEGIN_SRC elisp
(let* ((dom '(div nil
                  (h1 nil "title")
                  (p nil "para")))
       (p (car (dom-by-tag dom 'p))))
  (dom-remove-node dom p)
  dom)
#+END_SRC

#+RESULTS:
: (div nil
:      (h1 nil "title"))

* dom-search
:PROPERTIES:
:added:    27.1
:END:

#+BEGIN_SRC elisp
(dom-search '(body nil
                   (nav nil
                        (ol nil
                            (li nil "Perl")
                            (li nil "Python")
                            (li nil "PHP")))
                   (h1 nil "h1 heading")
                   (p nil "paragraph"))
            (lambda (node) (eq 'li (car node))))
#+END_SRC

#+RESULTS:
: ((li nil "Perl")
:  (li nil "Python")
:  (li nil "PHP"))

* dom-set-attribute

#+BEGIN_SRC elisp
(let ((dom '(a ((href . "https://www.gnu.org/s/emacs/")) "GNU Emacs")))
  (dom-set-attribute dom 'href "#")
  dom)
#+END_SRC

#+RESULTS:
: (a
:  ((href . "#"))
:  "GNU Emacs")

* dom-set-attributes

#+BEGIN_SRC elisp
(let ((dom '(a nil "Example Domain")))
  (dom-set-attributes dom '((href . "https://example.com/")
                            (title . "Example Domain")))
  dom)
#+END_SRC

#+RESULTS:
: (a
:  ((href . "https://example.com/")
:   (title . "Example Domain"))
:  "Example Domain")

* dom-strings

#+BEGIN_SRC elisp
(dom-strings '(body nil
                    (h1 nil "Basic Emacs commands")
                    (p nil "Type " (kbd nil "C-x C-f") " to open a file")
                    (p nil "Type " (kbd nil "C-x C-c") " to quit Emacs")))
#+END_SRC

#+RESULTS:
: ("Basic Emacs commands" "Type " "C-x C-f" " to open a file" "Type " "C-x C-c" " to quit Emacs")

* dom-tag

#+BEGIN_SRC elisp
(dom-tag '(p nil "This is a paragraph"))
#+END_SRC

#+RESULTS:
: p

* dom-text

#+BEGIN_SRC elisp
(dom-text '(a ((href . "https://www.gnu.org/s/emacs/")) "GNU Emacs"))
#+END_SRC

#+RESULTS:
: "GNU Emacs"

* dom-texts

#+BEGIN_SRC elisp
(dom-texts '(ol nil
                (li nil "Perl")
                (li nil "Python")
                (li nil "PHP"))
           ", ")
#+END_SRC

#+RESULTS:
: "Perl, Python, PHP"

* dotimes

#+BEGIN_SRC elisp :results output
(dotimes (i 5)
  (princ i))
#+END_SRC

#+RESULTS:
: "01234"

* dotimes-with-progress-reporter

#+BEGIN_SRC elisp
(dotimes-with-progress-reporter (k 500) "Collecting some mana for Emacs..."
  (sit-for 0.01))
#+END_SRC

#+RESULTS:
: nil

* downcase

#+BEGIN_SRC elisp
(downcase "Hello World")
#+END_SRC

#+RESULTS:
: "hello world"

* edit-and-eval-command

#+BEGIN_SRC elisp
(edit-and-eval-command "Please edit: " '(forward-word 1))
#+END_SRC

#+RESULTS:
: t

* eieio-class-children

#+BEGIN_SRC elisp
(defclass circle ()
  ((radius :initarg :radius))
  "A circle class.")

(defclass color-circle (circle)
  ((color :initarg :color))
  "A colorful circle class.")

(eieio-class-children 'circle)
#+END_SRC

#+RESULTS:
: (color-circle)

* eieio-class-name

#+BEGIN_SRC elisp
(defclass rabbit ()
  ((fur-color :initarg :fur-color)
   (age :initarg :age))
  "A rabbit class.")

;; FIXME: The value is incorrect, I've submitted a bug report. (2019-11-24)
(eieio-class-name 'rabbit)
#+END_SRC

#+RESULTS:
: rabbit

* eieio-class-parents

#+BEGIN_SRC elisp
(defclass circle ()
  ((radius :initarg :radius))
  "A circle class.")

(defclass color-circle (circle)
  ((color :initarg :color))
  "A colorful circle class.")

(eieio-class-parents 'color-circle)
#+END_SRC

#+RESULTS:
#+BEGIN_EXAMPLE
(#s(eieio--class circle "A circle class." nil
                 [#s(cl-slot-descriptor radius unbound t nil)]
                 #s(hash-table size 65 test eq rehash-size 1.5 rehash-threshold 0.8125 data
                               (radius 0))
                 (color-circle)
                 ((:radius . radius))
                 []
                 []
                 #s(#1 unbound)
                 (:custom-groups nil :documentation "A circle class.")))
#+END_EXAMPLE

* eieio-object-class

#+BEGIN_SRC elisp
(defclass my-class () ())
(eieio-object-class (my-class))
#+END_SRC

#+RESULTS:
: my-class

* eieio-object-name

#+BEGIN_SRC elisp
(defclass my-class () ())
(eieio-object-name (my-class))
#+END_SRC

#+RESULTS:
: "#<my-class my-class>"

* elt

#+BEGIN_SRC elisp
;; Work on list
;; (nth 2 '(1 2 3 4))
(elt '(1 2 3 4) 2)
#+END_SRC

#+RESULTS:
: 3

#+BEGIN_SRC elisp
;; Work on array
;; (aref [1 2 3 4] 2)
(elt [1 2 3 4] 2)
#+END_SRC

#+RESULTS:
: 3

#+BEGIN_SRC elisp
;; Work on string
(string (elt "1234" 2))
#+END_SRC

#+RESULTS:
: "3"

* emacs-init-time

#+BEGIN_SRC elisp
(emacs-init-time)
#+END_SRC

#+RESULTS:
: "3.9 seconds"

* emacs-pid

#+BEGIN_SRC elisp
(emacs-pid)
#+END_SRC

#+RESULTS:
: 76707

* emacs-uptime

#+BEGIN_SRC elisp
(emacs-uptime)
#+END_SRC

#+RESULTS:
: "3 hours, 3 minutes, 34 seconds"

* emacs-version

#+BEGIN_SRC elisp
(emacs-version)
#+END_SRC

#+RESULTS:
: "GNU Emacs 26.1 (build 1, x86_64-apple-darwin18.2.0, Carbon Version 158 AppKit 1671.1)\n of 2018-11-11"

* encode-char

#+BEGIN_SRC elisp
(encode-char ?a 'unicode)
#+END_SRC

#+RESULTS:
: 97

#+BEGIN_SRC elisp
;; æ–‡
;; Unicode Codepoint ?æ–‡ = #x6587
;; GBK Codepoint #xCEC4
(format "#x%X" (encode-char ?æ–‡ 'chinese-gbk))
#+END_SRC

#+RESULTS:
: "#xCEC4"

* encode-coding-region

#+BEGIN_SRC elisp
;; æ–‡
;; Unicode Codepoint #x6587, xE6 #x96 #x87
;; GBK Codepoint #xCEC4, #xCE #xC4
(with-temp-buffer
  (insert ?æ–‡)
  (mapcar #'identity (encode-coding-region (point-min) (point-max) 'chinese-gbk t)))
#+END_SRC

#+RESULTS:
: (206 196)

* encode-coding-string

#+BEGIN_SRC elisp
;; UTF 8 -> GBK
(string-to-list (encode-coding-string "æ–‡" 'chinese-gbk))
#+END_SRC

#+RESULTS:
: (206 196)

#+BEGIN_SRC elisp
;; #xE6 #x96 #x87
(mapconcat
 (lambda (c) (format "#x%X" c))
 (encode-coding-string "æ–‡" 'utf-8)
 " ")
#+END_SRC

#+RESULTS:
: "#xE6 #x96 #x87"

* encode-hex-string

#+BEGIN_SRC elisp
(encode-hex-string "abc")
#+END_SRC

#+RESULTS:
: "616263"

* encode-time

#+BEGIN_SRC elisp
(apply #'encode-time (decode-time))
#+END_SRC

#+RESULTS:
: (23532 37316)

* end-of-line

#+BEGIN_SRC elisp
(end-of-line)
#+END_SRC

#+RESULTS:
: nil

* ensure-list
:PROPERTIES:
:added:    28.1
:END:

#+BEGIN_SRC elisp
(ensure-list 42)
#+END_SRC

#+RESULTS:
: (42)

* eobp

#+BEGIN_SRC elisp
(with-temp-buffer (eobp))
#+END_SRC

#+RESULTS:
: t

* eolp

#+BEGIN_SRC elisp
(with-temp-buffer (eolp))
#+END_SRC

#+RESULTS:
: t

* eq

#+BEGIN_SRC elisp
(list (eq 'a 'a)
      (eq 1 1)
      (eq 1.0 1.0))
#+END_SRC

#+RESULTS:
: (t t nil)

* eql

#+BEGIN_SRC elisp
(eql 'foo 'foo)
#+END_SRC

#+RESULTS:
: t

#+BEGIN_SRC elisp
(list (eql 1.0 1.0)
      (eql 1 1)
      (eql 1.0 1))
#+END_SRC

#+RESULTS:
: (t t nil)

* equal-including-properties

#+BEGIN_SRC elisp
(equal-including-properties "asdf"
                            (propertize "asdf" 'asdf t))
#+END_SRC

#+RESULTS:
: nil

* erase-buffer

#+BEGIN_SRC elisp
(with-temp-buffer
  (insert "hello world\n")
  (erase-buffer)
  (buffer-string))
#+END_SRC

#+RESULTS:
: ""

* error

#+BEGIN_SRC elisp
(error "Invalid name `%s'" "A%%B")
#+END_SRC

* error-message-string

#+BEGIN_SRC elisp
(condition-case err
    (/ 1 0)
  (arith-error (error-message-string err)))
#+END_SRC

#+RESULTS:
: "Arithmetic error"

* ert-deftest

#+BEGIN_SRC elisp
(ert-deftest foo ()
  (should (> float-pi 3))
  (should-not (< float-pi 3))
  (should-error (/ 1 0) :type 'arith-error)
  (skip-unless (featurep 'dbusbind)))
#+END_SRC

#+RESULTS:
: foo

* eshell-parse-command

#+BEGIN_SRC elisp
(eshell-parse-command "ls | nl")
#+END_SRC

#+RESULTS:
: (eshell-trap-errors
:  (eshell-execute-pipeline
:   '((eshell-named-command "ls")
:     (eshell-named-command "nl"))))

* esxml-query

#+BEGIN_SRC elisp
(esxml-query
 "body > div > p > a"
 (with-current-buffer (url-retrieve-synchronously "http://example.com")
   (libxml-parse-html-region url-http-end-of-headers (point-max))))
#+END_SRC

#+RESULTS:
: (a
:  ((href . "http://www.iana.org/domains/example"))
:  "More information...")

* esxml-query-all

#+BEGIN_SRC elisp
(esxml-query-all
 "li"
 '(body nil
        (nav nil
             (ol nil
                 (li nil "Perl")
                 (li nil "Python")
                 (li nil "PHP")))
        (h1 nil "h1 heading")
        (p nil "paragraph")))
#+END_SRC

#+RESULTS:
: ((li nil "Perl")
:  (li nil "Python")
:  (li nil "PHP"))

* esxml-to-xml

#+BEGIN_SRC elisp :results value raw :wrap SRC html
((lambda (string)
   "Prettify HTML in STRING."
   (with-temp-buffer
     (insert string)
     (html-mode)
     (sgml-pretty-print (point-min) (point-max))
     (buffer-string)))
 (esxml-to-xml
  '(html nil
         (head nil
               (title nil "Example Domain")
               (meta ((charset . "utf-8"))))
         (body nil
               (h1 nil "Example Domain")
               (p nil "This domain...")
               (p nil (a ((href . "http://www.iana.org/domains/example"))
                         "More information..."))))))
#+END_SRC

#+RESULTS:
#+BEGIN_SRC html
<html>
  <head>
    <title>Example Domain
    </title>
    <meta charset="utf-8"/>
  </head>
  <body>
    <h1>Example Domain
    </h1>
    <p>This domain...
    </p>
    <p>
      <a href="http://www.iana.org/domains/example">More information...
      </a>
    </p>
  </body>
</html>
#+END_SRC

* eval

#+BEGIN_SRC elisp
(eval '(+ 1 2))
#+END_SRC

#+RESULTS:
: 3

#+BEGIN_SRC elisp
(eval '(funcall
        (let ((x 42))
          (lambda ()
            x)))
      t)
#+END_SRC

#+RESULTS:
: 42

* eval-after-load

#+BEGIN_SRC elisp
;; It is easier to use `with-eval-after-load' instead
(eval-after-load 'elisp-mode
  (lambda ()
    (setq answer 42)
    (setq beast 666)))
#+END_SRC

* eval-buffer

#+BEGIN_SRC elisp
(with-temp-buffer
  (insert "(+ 1 2)")
  (eval-buffer nil (current-buffer))
  (buffer-string))
#+END_SRC

#+RESULTS:
: "(+ 1 2)\n3\n"

* eval-minibuffer

#+BEGIN_SRC elisp
(eval-minibuffer "Enter an expression: " (format "%s" '(+ 1 2)))
#+END_SRC

#+RESULTS:
: 3

* eval-region

#+BEGIN_SRC elisp
(with-temp-buffer
  (insert "(+ 1 2)")
  (eval-region (point-min) (point-max) (current-buffer))
  (buffer-string))
#+END_SRC

#+RESULTS:
: "(+ 1 2)\n3\n"

* eval-when-compile

#+BEGIN_SRC elisp :eval no
;;; foo.el

(eval-when-compile
  (require 'cl-lib))

(defun foo ()
  (cl-incf (point)))

;;; foo.el ends here
#+END_SRC

#+BEGIN_SRC elisp :results silent
(message "1 Day has %d seconds."
         (eval-when-compile
           (* 24 60 60)))
#+END_SRC

* exec-path
:PROPERTIES:
:added:    27.1
:END:

#+BEGIN_SRC elisp :results silent
(exec-path)
#+END_SRC

* executable-find
:PROPERTIES:
:changes:  27.1 Add an optional argument REMOTE.
:END:

#+BEGIN_SRC elisp
(executable-find "git")
#+END_SRC

#+RESULTS:
: "/usr/local/bin/git"

* exp

#+BEGIN_SRC elisp
(exp 1)
#+END_SRC

#+RESULTS:
: 2.718281828459045

* expand-file-name
:PROPERTIES:
:changes:  28.1 The function will now check for null bytes.
:END:

#+BEGIN_SRC elisp
(expand-file-name "custom.el" user-emacs-directory)
#+END_SRC

#+RESULTS:
: "/Users/xcy/.emacs.d/custom.el"

* expt

#+BEGIN_SRC elisp
(expt 2 10)
#+END_SRC

#+RESULTS:
: 1024

* extract-rectangle

#+BEGIN_SRC elisp
(with-temp-buffer
  (set-mark (point))
  (insert "AAA" ?\n
          "BBB" ?\n
          "CCC")
  (rectangle-mark-mode)
  (extract-rectangle (region-beginning) (region-end)))
#+END_SRC

#+RESULTS:
: ("AAA" "BBB" "CCC")

* extract-rectangle-bounds

#+BEGIN_SRC elisp
(with-temp-buffer
  (set-mark (point))
  (insert "AAA" ?\n
          "BBB" ?\n
          "CCC")
  (rectangle-mark-mode)
  (extract-rectangle-bounds (region-beginning) (region-end)))
#+END_SRC

#+RESULTS:
: ((1 . 4)
:  (5 . 8)
:  (9 . 12))

* f-absolute?

#+BEGIN_SRC elisp
(f-absolute? ".")
#+END_SRC

#+RESULTS:
: nil

* f-ancestor-of?

#+BEGIN_SRC elisp
(f-ancestor-of? (getenv "HOME") user-init-file)
#+END_SRC

#+RESULTS:
: t

* f-append-bytes

#+BEGIN_SRC elisp
(let ((tmpfile (make-temp-file "elisp-demos-")))
  (unwind-protect
      (progn
        (f-append-bytes (unibyte-string 1 2 3) tmpfile)
        (f-append-bytes (unibyte-string 4 5 6) tmpfile)
        (string-to-list (f-read-bytes tmpfile)))
    (delete-file tmpfile)))
#+END_SRC

#+RESULTS:
: (1 2 3 4 5 6)

* f-append-text

#+BEGIN_SRC elisp
(let ((tmpfile (make-temp-file "elisp-demos-")))
  (unwind-protect
      (progn
        (f-append-text "Hello" 'utf-8 tmpfile)
        (f-append-text " World" 'utf-8 tmpfile)
        (f-read-text tmpfile 'utf-8))
    (delete-file tmpfile)))
#+END_SRC

#+RESULTS:
: "Hello World"

* f-base

#+BEGIN_SRC elisp
(f-base "/path/to/file.txt")
#+END_SRC

#+RESULTS:
: "file"

* f-child-of?

#+BEGIN_SRC elisp
(f-child-of? user-init-file user-emacs-directory)
#+END_SRC

* f-common-parent

#+BEGIN_SRC elisp
(f-common-parent '("foo/bar/baz" "foo/bar/qux" "foo/bar/mux"))
#+END_SRC

#+RESULTS:
: "foo/bar/"

* f-delete

#+BEGIN_SRC elisp
(let ((tmpfile (make-temp-file "elisp-demos-")))
  (message "%s is created" tmpfile)
  (f-delete tmpfile)
  (unless (file-exists-p tmpfile)
    (message "%s is deleted" tmpfile))
  nil)
#+END_SRC

#+RESULTS:
: nil

* f-depth

#+BEGIN_SRC elisp
(f-depth "/path/to/file")
#+END_SRC

#+RESULTS:
: 3

* f-descendant-of?

#+BEGIN_SRC elisp
(f-descendant-of? user-init-file (getenv "HOME"))
#+END_SRC

#+RESULTS:
: t

* f-directory?

#+BEGIN_SRC elisp
(f-directory? user-emacs-directory)
#+END_SRC

#+RESULTS:
: t

* f-dirname

#+BEGIN_SRC elisp
(f-dirname "/path/to/file")
#+END_SRC

#+RESULTS:
: "/path/to"

* f-empty?

#+BEGIN_SRC elisp
(let ((tmpfile (make-temp-file "elisp-demos-")))
  (unwind-protect (f-empty? tmpfile)
    (f-delete tmpfile)))
#+END_SRC

#+RESULTS:
: t

* f-executable?

#+BEGIN_SRC elisp
(f-executable? "/bin/sh")
#+END_SRC

#+RESULTS:
: t

* f-exists?

#+BEGIN_SRC elisp
(f-exists? user-emacs-directory)
#+END_SRC

#+RESULTS:
: t

* f-expand

#+BEGIN_SRC elisp
(f-expand "tmp/" "/")
#+END_SRC

#+RESULTS:
: "/tmp/"

* f-ext

#+BEGIN_SRC elisp
(f-ext "/path/to/file.txt")
#+END_SRC

#+RESULTS:
: "txt"

* f-ext?

#+BEGIN_SRC elisp
(f-ext? "init.el" "el")
#+END_SRC

#+RESULTS:
: t

* f-file?

#+BEGIN_SRC elisp
(f-file? user-init-file)
#+END_SRC

#+RESULTS:
: t

* f-filename

#+BEGIN_SRC elisp
(f-filename "/path/to/file")
#+END_SRC

#+RESULTS:
: "file"

* f-join

#+BEGIN_SRC elisp
(f-join "/" "path" "to" "file")
#+END_SRC

#+RESULTS:
: "/path/to/file"

* f-mkdir

#+BEGIN_SRC elisp
(let ((tmpdir (make-temp-name "/tmp/elisp-demos-")))
  (f-mkdir tmpdir)
  (message "%s is a directory and exists? %s" tmpdir (f-dir? tmpdir))
  (f-delete tmpdir))
#+END_SRC

#+RESULTS:
: nil

* f-no-ext

#+BEGIN_SRC elisp
(f-no-ext "/path/to/file.txt")
#+END_SRC

#+RESULTS:
: "/path/to/file"

* f-parent-of?

#+BEGIN_SRC elisp
(f-parent-of? user-emacs-directory user-init-file)
#+END_SRC

#+RESULTS:
: t

* f-read-bytes

#+BEGIN_SRC elisp
(let ((tmpfile (make-temp-file "elisp-demos-")))
  (unwind-protect
      (progn
        (f-write-bytes (unibyte-string 0 1 2 3) tmpfile)
        (string-to-list (f-read-bytes tmpfile)))
    (delete-file tmpfile)))
#+END_SRC

#+RESULTS:
: (0 1 2 3)

* f-read-text

#+BEGIN_SRC elisp
(let ((tmpfile (make-temp-file "elisp-demos-")))
  (unwind-protect
      (progn
        (f-write-text "Hello world" 'utf-8 tmpfile)
        (f-read-text tmpfile 'utf-8))
    (delete-file tmpfile)))
#+END_SRC

#+RESULTS:
: "Hello world"

* f-readable?

#+BEGIN_SRC elisp
(f-readable? user-init-file)
#+END_SRC

#+RESULTS:
: t

* f-relative

#+BEGIN_SRC elisp
(f-relative "/path/to/file.txt" "/path/to/")
#+END_SRC

#+RESULTS:
: "file.txt"

* f-relative?

#+BEGIN_SRC elisp
(f-relative? ".")
#+END_SRC

#+RESULTS:
: t

* f-root?

#+BEGIN_SRC elisp
(f-root? "/")
#+END_SRC

#+RESULTS:
: t

* f-same?

#+BEGIN_SRC elisp
(f-same? user-init-file "~/.emacs.d/init.el")
#+END_SRC

#+RESULTS:
: t

* f-short

#+BEGIN_SRC elisp
(f-short user-init-file)
#+END_SRC

#+RESULTS:
: "~/.emacs.d/init.el"

* f-size

#+BEGIN_SRC elisp
(let ((tmpfile (make-temp-file "elisp-demos-")))
  (unwind-protect
      (progn
        (f-write-bytes (unibyte-string 0 #xff) tmpfile)
        (f-size tmpfile))
    (f-delete tmpfile)))
#+END_SRC

#+RESULTS:
: 2

* f-slash

#+BEGIN_SRC elisp
(f-slash ".")
#+END_SRC

#+RESULTS:
: "./"

* f-split

#+BEGIN_SRC elisp
(f-split "/path/to/file")
#+END_SRC

#+RESULTS:
: ("/" "path" "to" "file")

* f-swap-ext

#+BEGIN_SRC elisp
(f-swap-ext "/path/to/file.txt" "org")
#+END_SRC

#+RESULTS:
: "/path/to/file.org"

* f-uniquify

#+BEGIN_SRC elisp
(f-uniquify '("/foo/bar" "/foo/baz" "/foo/quux"))
#+END_SRC

#+RESULTS:
: ("bar" "baz" "quux")

* f-uniquify-alist

#+BEGIN_SRC elisp
(f-uniquify-alist '("/foo/bar" "/foo/baz" "/foo/quux"))
#+END_SRC

#+RESULTS:
: (("/foo/bar" . "bar")
:  ("/foo/baz" . "baz")
:  ("/foo/quux" . "quux"))

* f-writable?

#+BEGIN_SRC elisp
(f-writable? user-init-file)
#+END_SRC

#+RESULTS:
: t

* f-write-bytes

#+BEGIN_SRC elisp
(let ((tmpfile (make-temp-file "elisp-demos-")))
  (unwind-protect
      (progn
        (f-write-bytes (unibyte-string 0 1 2 3) tmpfile)
        (string-to-list (f-read-bytes tmpfile)))
    (delete-file tmpfile)))
#+END_SRC

#+RESULTS:
: (0 1 2 3)

* f-write-text

#+BEGIN_SRC elisp
(let ((tmpfile (make-temp-file "elisp-demos-")))
  (unwind-protect
      (progn
        (f-write-text "Hello world" 'utf-8 tmpfile)
        (f-read-text tmpfile 'utf-8))
    (delete-file tmpfile)))
#+END_SRC

#+RESULTS:
: "Hello world"

* face-all-attributes

#+BEGIN_SRC elisp
(face-all-attributes 'bold (selected-frame))
#+END_SRC

#+RESULTS:
#+BEGIN_EXAMPLE
((:family . unspecified)
 (:foundry . unspecified)
 (:width . unspecified)
 (:height . unspecified)
 (:weight . bold)
 (:slant . unspecified)
 (:underline . unspecified)
 (:overline . unspecified)
 (:strike-through . unspecified)
 (:box . unspecified)
 (:inverse-video . unspecified)
 (:foreground . unspecified)
 (:background . unspecified)
 (:stipple . unspecified)
 (:inherit . unspecified))
#+END_EXAMPLE

* face-attribute

#+BEGIN_SRC elisp
(face-attribute 'bold :weight)
#+END_SRC

#+RESULTS:
: bold

* face-attribute-relative-p

#+BEGIN_SRC elisp
(face-attribute-relative-p :height 2.0)
#+END_SRC

#+RESULTS:
: t

* face-differs-from-default-p

#+BEGIN_SRC elisp
(face-differs-from-default-p 'region)
#+END_SRC

#+RESULTS:
: :background

* face-documentation

#+BEGIN_SRC elisp
(face-documentation 'region)
#+END_SRC

#+RESULTS:
: "Basic face for highlighting the region."

* face-equal

#+BEGIN_SRC elisp
(face-equal 'error 'warning)
#+END_SRC

#+RESULTS:
: nil

* face-id

#+BEGIN_SRC elisp
(face-id 'region)
#+END_SRC

#+RESULTS:
: 12

* face-list

#+BEGIN_SRC elisp :results silent
(face-list)
#+END_SRC

* facep

#+BEGIN_SRC elisp :results silent
(facep 'error)
#+END_SRC

* fboundp

#+BEGIN_SRC elisp
(fboundp 'font-lock-ensure)
#+END_SRC

#+RESULTS:
: t

* fceiling

#+BEGIN_SRC elisp
(fceiling 1.2)
#+END_SRC

#+RESULTS:
: 2.0

* feature-file

#+BEGIN_SRC elisp
(feature-file 'pcase)
#+END_SRC

#+RESULTS:
: "/Users/xcy/src/emacs-mac/lisp/emacs-lisp/pcase.elc"

* featurep

#+BEGIN_SRC elisp
(featurep 'xemacs)
#+END_SRC

#+RESULTS:
: nil

* ffloor

#+BEGIN_SRC elisp
(ffloor 1.2)
#+END_SRC

#+RESULTS:
: 1.0

* file-accessible-directory-p

#+BEGIN_SRC elisp
(file-accessible-directory-p user-emacs-directory)
#+END_SRC

#+RESULTS:
: t

* file-attribute-file-identifier
:PROPERTIES:
:added:    29.1
:END:

#+BEGIN_SRC elisp
(file-attribute-file-identifier (file-attributes user-init-file))
#+END_SRC

#+RESULTS:
: (1417104 16777233)

* file-attribute-modes
:PROPERTIES:
:added:    26.1
:END:

#+BEGIN_SRC elisp
(file-attribute-modes (file-attributes user-init-file))
#+END_SRC

#+RESULTS:
: "-rw-r--r--"

* file-attribute-modification-time
:PROPERTIES:
:added:    26.1
:END:

#+BEGIN_SRC elisp
(format-time-string
 "%F %T"
 (file-attribute-modification-time (file-attributes user-init-file)))
#+END_SRC

#+RESULTS:
: "2020-03-01 02:20:27"

* file-attribute-size
:PROPERTIES:
:added:    26.1
:END:

#+BEGIN_SRC elisp
(file-attribute-size (file-attributes user-init-file))
#+END_SRC

#+RESULTS:
: 201878

* file-attributes

#+BEGIN_SRC elisp
(file-attributes user-init-file)
#+END_SRC

#+RESULTS:
: (nil 1 501 20
:      (23533 25246 3637 220000)
:      (23533 25245 994959 733000)
:      (23533 25245 994959 733000)
:      150332 "-rw-r--r--" t 8617049288 16777220)

* file-dependents

#+BEGIN_SRC elisp
(file-dependents (feature-file 'cl))
#+END_SRC

#+RESULTS:
: ("/Users/xcy/.emacs.d/package-quickstart.el")

* file-directory-p

#+BEGIN_SRC elisp
(file-directory-p user-emacs-directory)
#+END_SRC

#+RESULTS:
: t

* file-equal-p

#+BEGIN_SRC elisp
(file-equal-p "~/.emacs.d/init.el" user-init-file)
#+END_SRC

#+RESULTS:
: t

* file-executable-p

#+BEGIN_SRC elisp
(file-executable-p "/bin/sh")
#+END_SRC

#+RESULTS:
: t

* file-exists-p

#+BEGIN_SRC elisp
(file-exists-p user-init-file)
#+END_SRC

#+RESULTS:
: t

* file-expand-wildcards

#+BEGIN_SRC elisp
(file-expand-wildcards "*.el")
#+END_SRC

#+RESULTS:
: ("elisp-demos-tests.el" "elisp-demos.el")

* file-in-directory-p

#+BEGIN_SRC elisp
(file-in-directory-p user-init-file user-emacs-directory)
#+END_SRC

#+RESULTS:
: t

* file-local-name
:PROPERTIES:
:added:    26.1
:END:

#+BEGIN_SRC elisp
(file-local-name "/ssh:USER@HOST:/foo/bar")
#+END_SRC

#+RESULTS:
: "/foo/bar"

* file-modes

#+BEGIN_SRC elisp
(format "%o" (file-modes user-init-file))
#+END_SRC

#+RESULTS:
: "644"

#+BEGIN_SRC elisp
;; 4 r
;; 2 w
;; 1 x

;; -rw-r--r--
;;  42 4  4
;;
;; 6   4  4

;; #o644 = 420

(let* ((modes (file-modes user-init-file))
       (modes-list ((lambda (n)
                      "Split permission number N to (r w x)."
                      (let* ((r (/ n 64))
                             (w (/ (- n (* r 64)) 8))
                             (x (- n (* r 64) (* w 8))))
                        (list r w x)))
                    modes))
       (modes-string (mapconcat
                      (lambda (number)
                        "Convert permission NUMBER to string."
                        (pcase-exhaustive number
                          (7 "rwx")
                          (6 "rw-")
                          (5 "r-x")
                          (4 "r--")
                          (3 "-wx")
                          (2 "-w-")
                          (1 "--x")
                          (0 "---")))
                      modes-list "")))
  (list :decimal modes
        :octal modes-list
        :string modes-string))
#+END_SRC

#+RESULTS:
: (:decimal 420 :octal
:           (6 4 4)
:           :string "rw-r--r--")

* file-modes-number-to-symbolic
:PROPERTIES:
:added:    28.1
:END:

#+BEGIN_SRC elisp
(file-modes-number-to-symbolic #o644)
#+END_SRC

#+RESULTS:
: "-rw-r--r--"

* file-name-absolute-p

#+BEGIN_SRC elisp
(list (file-name-absolute-p "README.md")
      (file-name-absolute-p "/path/to/README.md"))
#+END_SRC

#+RESULTS:
: (nil t)

* file-name-all-completions

#+BEGIN_SRC elisp
(file-name-all-completions "vim" "/usr/bin/")
#+END_SRC

#+RESULTS:
: ("vimtutor" "vimdiff" "vim")

* file-name-as-directory

#+BEGIN_SRC elisp
(file-name-as-directory "~")
#+END_SRC

#+RESULTS:
: "~/"

* file-name-base
:PROPERTIES:
:added:    24.3
:END:

#+BEGIN_SRC elisp
(file-name-base "/Users/xcy/.emacs.d/init.el")
#+END_SRC

#+RESULTS:
: "init"

* file-name-case-insensitive-p
:PROPERTIES:
:added:    26.1
:END:

#+BEGIN_SRC elisp
;; Some macOS systems's file system is case-insensitive
(file-name-case-insensitive-p user-init-file)
#+END_SRC

#+RESULTS:
: t

* file-name-completion

#+BEGIN_SRC elisp
(file-name-completion "em" "/usr/bin/")
#+END_SRC

#+RESULTS:
: "emacs"

* file-name-concat

#+BEGIN_SRC elisp
(file-name-concat "/tmp" "foo")
#+END_SRC

#+RESULTS:
: "/tmp/foo"

* file-name-directory

#+BEGIN_SRC elisp
(file-name-directory "/Users/xcy/.emacs.d/init.el")
#+END_SRC

#+RESULTS:
: "/Users/xcy/.emacs.d/"

* file-name-extension

#+BEGIN_SRC elisp
(file-name-extension "init.el")
#+END_SRC

#+RESULTS:
: "el"

* file-name-nondirectory

#+BEGIN_SRC elisp
(file-name-nondirectory "/Users/xcy/.emacs.d/init.el")
#+END_SRC

#+RESULTS:
: "init.el"

#+BEGIN_SRC elisp
;; Get filename of a directory
(file-name-nondirectory (directory-file-name "~/src/elisp-demos/"))
#+END_SRC

#+RESULTS:
: "elisp-demos"

* file-name-parent-directory
:PROPERTIES:
:added:    29.1
:END:

#+BEGIN_SRC elisp
(file-name-parent-directory "/path/to/file")
#+END_SRC

#+RESULTS:
: "/path/to/"

* file-name-sans-extension

#+BEGIN_SRC elisp
(file-name-sans-extension "simple.el.gz")
#+END_SRC

#+RESULTS:
: "simple.el"

* file-name-sans-versions

#+BEGIN_SRC elisp
(file-name-sans-versions "README.md~")
#+END_SRC

#+RESULTS:
: "README.md"

* file-name-split
:PROPERTIES:
:added:    29.1
:END:

#+BEGIN_SRC elisp
(file-name-split "/path/to/file")
#+END_SRC

#+RESULTS:
: ("" "path" "to" "file")

* file-name-with-extension
:PROPERTIES:
:added:    28.1
:END:

#+BEGIN_SRC elisp
(file-name-with-extension "file.php" "html")
#+END_SRC

#+RESULTS:
: "file.html"

* file-newer-than-file-p

#+BEGIN_SRC elisp
(let ((file1 (make-temp-file "elisp-demo-"))
      (file2 (make-temp-file "elisp-demo-")))
  (unwind-protect
      (file-newer-than-file-p file2 file1)
    (delete-file file1)
    (delete-file file2)))
#+END_SRC

#+RESULTS:
: t

* file-nlinks

#+BEGIN_SRC elisp
(file-nlinks "/usr/bin/vim")
#+END_SRC

#+RESULTS:
: 1

* file-notify-add-watch

#+BEGIN_SRC elisp
(file-notify-add-watch
 user-init-file
 '(change attribute-change)
 (lambda (event) (message "Event %S" event)))
#+END_SRC

#+RESULTS:
: 45

* file-ownership-preserved-p

#+BEGIN_SRC elisp
(file-ownership-preserved-p user-init-file)
#+END_SRC

#+RESULTS:
: t

* file-readable-p

#+BEGIN_SRC elisp
(file-readable-p user-init-file)
#+END_SRC

#+RESULTS:
: t

* file-regular-p

#+BEGIN_SRC elisp
(file-regular-p user-init-file)
#+END_SRC

#+RESULTS:
: t

* file-relative-name

#+BEGIN_SRC elisp
(file-relative-name user-init-file user-emacs-directory)
#+END_SRC

#+RESULTS:
: "init.el"

* file-remote-p

#+BEGIN_SRC elisp
(file-remote-p "/ssh:USER@HOST:/foo/bar")
#+END_SRC

#+RESULTS:
: "/ssh:USER@HOST:"

* file-size-human-readable
:PROPERTIES:
:changes:  27.1 Add SPACE and UNIT arguments.
:END:

#+BEGIN_SRC elisp
(file-size-human-readable 1024)
#+END_SRC

#+RESULTS:
: "1k"

* file-symlink-p

#+BEGIN_SRC elisp
(file-symlink-p "/usr/bin/ex")
#+END_SRC

#+RESULTS:
: "vim"

* file-system-info
:PROPERTIES:
:changes:  27.1 Available on all platforms, instead of just Microsoft platforms.
:END:

#+BEGIN_SRC elisp
(file-system-info user-init-file)
#+END_SRC

#+RESULTS:
: (121123069952 19899543552 15998967808)

* file-truename

#+BEGIN_SRC elisp
(file-truename "~/../../")
#+END_SRC

#+RESULTS:
: "/"

* file-writable-p

#+BEGIN_SRC elisp
(file-writable-p user-init-file)
#+END_SRC

#+RESULTS:
: t

* filepos-to-bufferpos
:PROPERTIES:
:added:    25.1
:END:

#+BEGIN_SRC elisp
(with-temp-buffer
  (insert "(Î»)")
  (filepos-to-bufferpos 1))
#+END_SRC

#+RESULTS:
: 2

* fill-common-string-prefix

#+BEGIN_SRC elisp
(fill-common-string-prefix "bar" "baz")
#+END_SRC

#+RESULTS:
: "ba"

#+BEGIN_SRC elisp
(fill-common-string-prefix "bar" "foo")
#+END_SRC

#+RESULTS:
: nil

* fillarray

#+BEGIN_SRC elisp
(let ((array (vector 1 2 3)))
  (fillarray array 0)
  array)
#+END_SRC

#+RESULTS:
: [0 0 0]

* find-class

#+BEGIN_SRC elisp
(defclass my-class () () "My Class.")
(find-class 'my-class)
#+END_SRC

#+RESULTS:
: #s(eieio--class my-class "My Class." nil
:                 []
:                 #s(hash-table size 65 test eq rehash-size 1.5 rehash-threshold 0.8125 data
:                               ())
:                 nil nil
:                 []
:                 []
:                 #s(#0)
:                 (:custom-groups nil :documentation "My Class."))

* find-coding-systems-region

#+BEGIN_SRC elisp
(with-temp-buffer
  (insert "ä¸–ç•Œï¼Œä½ å¥½")
  (length (find-coding-systems-region (point-min) (point-max))))
#+END_SRC

#+RESULTS:
: 39

* find-coding-systems-string

#+BEGIN_SRC elisp
(length (find-coding-systems-string "ä¸–ç•Œï¼Œä½ å¥½"))
#+END_SRC

#+RESULTS:
: 39

* find-definition-noselect

#+BEGIN_SRC elisp
(find-definition-noselect 'pcase nil)
#+END_SRC

#+RESULTS:
: (#<buffer pcase.el.gz> . 4220)

* find-file

#+BEGIN_SRC elisp
(find-file user-init-file)
#+END_SRC

#+RESULTS:
: #<buffer init.el>

* find-file-literally

#+BEGIN_SRC elisp
(find-file-literally user-init-file)
#+END_SRC

* find-file-noselect

#+BEGIN_SRC elisp
(find-file-noselect user-init-file)
#+END_SRC

#+RESULTS:
: #<buffer init.el>

* find-file-other-window

#+BEGIN_SRC elisp
(find-file-other-window user-init-file)
#+END_SRC

#+RESULTS:
: #<buffer init.el>

* find-file-read-only

#+BEGIN_SRC elisp
(find-file-read-only user-init-file)
#+END_SRC

#+RESULTS:
: #<buffer init.el>

* find-function-C-source

#+BEGIN_SRC elisp
(find-function-C-source 'car "data.c" nil)
#+END_SRC

#+RESULTS:
: (#<buffer data.c> . 13992)

* find-function-noselect

#+BEGIN_SRC elisp
(find-function-noselect 'pcase)
#+END_SRC

#+RESULTS:
: (#<buffer pcase.el.gz> . 4220)

* find-function-search-for-symbol

#+BEGIN_SRC elisp
(find-function-search-for-symbol
 'car nil
 (help-C-file-name (symbol-function 'car) 'subr))
#+END_SRC

#+RESULTS:
: (#<buffer data.c> . 13992)

* find-image

#+BEGIN_SRC elisp
(find-image '((:type svg :file "splash.svg")
              (:type png :file "splash.png")))
#+END_SRC

#+RESULTS:
: (image :type svg :file "/usr/local/share/emacs/26.2/etc/images/splash.svg")

* find-library-name

#+BEGIN_SRC elisp
(find-library-name "seq")
#+END_SRC

#+RESULTS:
: "/Users/xcy/src/emacs-mac/lisp/emacs-lisp/seq.el"

* find-lisp-object-file-name

#+BEGIN_SRC elisp
(find-lisp-object-file-name 'if (symbol-function 'if))
#+END_SRC

#+RESULTS:
: "src/eval.c"

* find-variable-noselect

#+BEGIN_SRC elisp
(find-variable-noselect 'emacs-version)
#+END_SRC

#+RESULTS:
: (#<buffer emacs.c> . 91318)

* flatten-tree
:PROPERTIES:
:added:    27.1
:END:

#+BEGIN_SRC elisp
(flatten-tree '(1 (2 . 3) nil (4 5 (6)) 7))
#+END_SRC

#+RESULTS:
: (1 2 3 4 5 6 7)

* float

#+BEGIN_SRC elisp
;; -> 0
(float 1)
#+END_SRC

#+RESULTS:
: 1.0

* float-time

#+BEGIN_SRC elisp
(float-time)
#+END_SRC

#+RESULTS:
: 1542230331.775671

* floatp

#+BEGIN_SRC elisp
(floatp float-pi)
#+END_SRC

#+RESULTS:
: t

* floor

#+BEGIN_SRC elisp
;; -> -âˆž
(floor 1.2)
#+END_SRC

#+RESULTS:
: 1

* fmakunbound

#+BEGIN_SRC elisp
(defun foo ()
  42)

(fmakunbound 'foo)

(fboundp 'foo)
#+END_SRC

#+RESULTS:
: nil

* following-char

#+BEGIN_SRC elisp
(with-temp-buffer
  (insert "ABC")
  (following-char))
#+END_SRC

#+RESULTS:
: 0

#+BEGIN_SRC elisp
(with-temp-buffer
  (insert "ABC")
  (goto-char (point-min))
  (string (following-char)))
#+END_SRC

#+RESULTS:
: "A"

* font-at

#+BEGIN_SRC elisp
(font-at 1)
#+END_SRC

#+RESULTS:
: #<font-object "-*-Source Code Pro-normal-italic-normal-*-13-*-*-*-m-0-iso10646-1">

* font-face-attributes

#+BEGIN_SRC elisp
(font-face-attributes (face-attribute 'default :font))
#+END_SRC

#+RESULTS:
: (:family "Source Code Pro" :height 130 :weight normal :slant normal :width normal)

* font-family-list

#+BEGIN_SRC elisp :results silent
(font-family-list)
#+END_SRC

* font-get

#+BEGIN_SRC elisp
(font-get (face-attribute 'default :font) :size)
#+END_SRC

#+RESULTS:
: 13

* font-info

#+BEGIN_SRC elisp
(font-info "Courier")
#+END_SRC

#+RESULTS:
: ["-*-Courier-normal-normal-normal-*-12-*-*-*-m-0-iso10646-1" "Courier:pixelsize=12:weight=normal:slant=normal:width=normal:spacing=100:scalable=true" 12 14 0 0 0 7 11 3 7 7 nil nil]

* font-lock-ensure
:PROPERTIES:
:added:    25.1
:END:

#+BEGIN_SRC elisp
(with-temp-buffer
  (insert ":foo")
  (delay-mode-hooks (emacs-lisp-mode))
  (font-lock-ensure)
  (buffer-string))
#+END_SRC

#+RESULTS:
: #(":foo" 0 4
:   (face font-lock-builtin-face))

* font-lock-flush
:PROPERTIES:
:added:    25.1
:END:

* fontp

#+BEGIN_SRC elisp
(fontp (face-attribute 'default :font))
#+END_SRC

#+RESULTS:
: t

* format

#+BEGIN_SRC elisp
(format "Hello, %s!" "World")
#+END_SRC

#+RESULTS:
: "Hello, World!"

#+BEGIN_SRC elisp
(apply #'format "%d (#o%o, #x%x, ?%c)"
        (make-list 4 ?A))
#+END_SRC

#+RESULTS:
: "65 (#o101, #x41, ?A)"

* format-message
:PROPERTIES:
:added:    25.1
:END:

#+BEGIN_SRC elisp
(let ((text-quoting-style 'curve))
  (format-message "The version is stored in `emacs-version'"))
#+END_SRC

#+RESULTS:
: "The version is stored in â€˜emacs-versionâ€™"

* format-mode-line

#+BEGIN_SRC elisp
(format-mode-line '(buffer-file-name "%f" "%b"))
#+END_SRC

#+RESULTS:
: "/Users/xcy/src/elisp-demos/elisp-demos.org"

* format-network-address

#+BEGIN_SRC elisp
(format-network-address [192 160 0 102 0])
#+END_SRC

#+RESULTS:
: "192.160.0.102:0"

* format-seconds

#+BEGIN_SRC elisp
(format-seconds "Emacs is %y years, %d days, %h hours, %m minutes, %s seconds old"
                ;; Initial release, 20 March 1985
                (time-to-seconds (time-subtract nil (date-to-time "1985-03-20T00:00:00Z"))))
#+END_SRC

#+RESULTS:
: "Emacs is 33 years, 247 days, 21 hours, 32 minutes, 51 seconds old"

* format-spec
:PROPERTIES:
:changes:  29.1 'format-spec' now accepts functions in the replacement.
:END:

#+BEGIN_SRC elisp
(format-spec "%a + %b = %b + %a" '((?a . 1) (?b . 2)))
#+END_SRC

#+RESULTS:
: "1 + 2 = 2 + 1"

* format-spec-make

#+BEGIN_SRC elisp
(format-spec-make ?a 1 ?b 2)
#+END_SRC

#+RESULTS:
: ((97 . 1)
:  (98 . 2))

#+BEGIN_SRC elisp
(format-spec "%a + %b = %b + %a" (format-spec-make ?a 1 ?b 2 ?s 3))
#+END_SRC

#+RESULTS:
: "1 + 2 = 2 + 1"

* format-time-string
:PROPERTIES:
:changes:  26.1 %q is supported.
:END:

#+BEGIN_SRC elisp
(format-time-string "%Y-%m-%d %H:%M:%S %z")
#+END_SRC

#+RESULTS:
: "2018-11-15 05:23:25 +0800"

* forward-line

#+BEGIN_SRC elisp
(forward-line)
#+END_SRC

#+RESULTS:
: 0

* frame-list

#+BEGIN_SRC elisp
(frame-list)
#+END_SRC

#+RESULTS:
: (#<frame /Users/xcy/src/elisp-demos/elisp-demos.org 0x1049a21e8>)

* frame-list-z-order

#+BEGIN_SRC elisp
(frame-list-z-order)
#+END_SRC

#+RESULTS:
: (#<frame /Users/xcy/src/elisp-demos/elisp-demos.org 0x1049a21e8>)

* frame-root-window

#+BEGIN_SRC elisp
(frame-root-window)
#+END_SRC

#+RESULTS:
: #<window 43>

* frame-terminal

#+BEGIN_SRC elisp
(frame-terminal)
#+END_SRC

#+RESULTS:
: #<terminal 1 on Mac>

* frexp

#+BEGIN_SRC elisp
(frexp 8)
#+END_SRC

#+RESULTS:
: (0.5 . 4)

* fround

#+BEGIN_SRC elisp
(fround 1.5)
#+END_SRC

#+RESULTS:
: 2.0

* fset

#+BEGIN_SRC elisp
(fset 'foo (lambda () 42))

(foo)
#+END_SRC

#+RESULTS:
: 42

* ftruncate

#+BEGIN_SRC elisp
(ftruncate 1.2)
#+END_SRC

#+RESULTS:
: 1.0

* func-arity
:PROPERTIES:
:added:    26.1
:END:

#+BEGIN_SRC elisp
(func-arity #'+)
#+END_SRC

#+RESULTS:
: (0 . many)

* funcall

#+BEGIN_SRC elisp
(funcall (intern "+") 1 2 3)
#+END_SRC

#+RESULTS:
: 6

* function-alias-p
:PROPERTIES:
:added:    29.1
:END:

#+BEGIN_SRC elisp
(function-alias-p 'join-line)
#+END_SRC

#+RESULTS:
: (delete-indentation)

* function-get
:PROPERTIES:
:added:    24.3
:END:

#+BEGIN_SRC elisp
(list (get 'count-matches 'modifier-cache)
      (function-get 'count-matches 'modifier-cache))
#+END_SRC

#+RESULTS:
: (nil
:  ((0 . how-many)))

* function-put
:PROPERTIES:
:added:    25.1
:END:

#+BEGIN_SRC elisp
(function-put 'count-matches 'foo "test")
#+END_SRC

#+RESULTS:
: "test"

* gap-position

#+BEGIN_SRC elisp
(gap-position)
#+END_SRC

#+RESULTS:
: 18468

* gap-size

#+BEGIN_SRC elisp
(gap-size)
#+END_SRC

#+RESULTS:
: 2520

* generate-new-buffer

#+BEGIN_SRC elisp
(generate-new-buffer "*foo*")
#+END_SRC

#+RESULTS:
: #<buffer *foo*<3>>

* generate-new-buffer-name

#+BEGIN_SRC elisp
(generate-new-buffer-name "*Messages*")
#+END_SRC

#+RESULTS:
: "*Messages*<2>"

* generic-p

#+BEGIN_SRC elisp
(defclass circle ()
  ((radius :initarg :radius))
  "A circle class.")

(cl-defmethod area ((c circle))
  "Return area of the circle C."
  (* float-pi (expt (oref c :radius) 2)))

;; C-h f area
(generic-p 'area)
#+END_SRC

#+RESULTS:
: t

* gensym

#+BEGIN_SRC elisp
(list gensym-counter
      (gensym)
      gensym-counter)
#+END_SRC

#+RESULTS:
: (11 g11 12)

* get

#+BEGIN_SRC elisp
(get 'beginning-of-buffer 'interactive-only)
#+END_SRC

#+RESULTS:
: "use `(goto-char (point-min))' instead."

* get-buffer

#+BEGIN_SRC elisp
(get-buffer "*Messages*")
#+END_SRC

#+RESULTS:
: #<buffer *Messages*>

* get-buffer-create

#+BEGIN_SRC elisp
(get-buffer-create " *foo*")
#+END_SRC

#+RESULTS:
: #<buffer  *foo*>

* get-buffer-process

#+BEGIN_SRC elisp
;; Start the shell process if not already
(shell)

(get-buffer-process "*shell*")
#+END_SRC

#+RESULTS:
: #<process shell>

* get-byte

#+BEGIN_SRC elisp
;; Î», #x3bb, #xCE #xBB
(format "#x%X" (get-byte 0 (string-as-unibyte "Î»")))
#+END_SRC

#+RESULTS:
: "#xCE"

* get-char-code-property

#+BEGIN_SRC elisp
(get-char-code-property ?A 'name)
#+END_SRC

#+RESULTS:
: "LATIN CAPITAL LETTER A"

#+BEGIN_SRC elisp
;; (= ?ä¸€ 19968)
(get-char-code-property ?ãŠ€ 'decomposition)
#+END_SRC

#+RESULTS:
: (circle 19968)

#+BEGIN_SRC elisp
(string (get-char-code-property ?\ã€Š 'paired-bracket))
#+END_SRC

#+RESULTS:
: "ã€‹"

#+BEGIN_SRC elisp
;; https://qntm.org/files/rot13/rot13.html
(rot13-string
 ;; NFD normalization, (99 97 102 233) -> (99 97 102 101 769)
 (apply #'string (mapcan
                  (lambda (char)
                    (get-char-code-property char 'decomposition))
                  "cafÃ©")))
#+END_SRC

#+RESULTS:
: "pnsrÌ"

* get-device-terminal

#+BEGIN_SRC elisp
(get-device-terminal nil)
#+END_SRC

#+RESULTS:
: #<terminal 1 on Mac>

* get-file-buffer

#+BEGIN_SRC elisp
(get-file-buffer user-init-file)
#+END_SRC

#+RESULTS:
: #<buffer init.el>

* get-free-disk-space

#+BEGIN_SRC elisp
(get-free-disk-space ".")
#+END_SRC

#+RESULTS:
: "14.9 GiB"

* get-internal-run-time

#+BEGIN_SRC elisp
(time-to-seconds (get-internal-run-time))
#+END_SRC

#+RESULTS:
: 103.553696

* get-locale-names
:PROPERTIES:
:added:    28.1
:END:

#+BEGIN_SRC elisp :results silent
(get-locale-names)
#+END_SRC

* get-process

#+BEGIN_SRC elisp
;; Start the shell process if not already
(shell)

(get-process "shell")
#+END_SRC

#+RESULTS:
: #<process shell>

* getenv

#+BEGIN_SRC elisp
(getenv "TERM")
#+END_SRC

#+RESULTS:
: "dumb"

* gethash

#+BEGIN_SRC elisp
(gethash 'x #s(hash-table data (x 1 y 2)))
#+END_SRC

#+RESULTS:
: 1

* gnutls-available-p

#+BEGIN_SRC elisp
(length (gnutls-available-p))
#+END_SRC

#+RESULTS:
: 30

* gnutls-hash-mac
:PROPERTIES:
:added:    26.1
:END:

#+BEGIN_SRC elisp
;; ~ $ echo -n "value" | openssl dgst -sha1 -hmac "key"
;; 57443a4c052350a44638835d64fd66822f813319
(mapconcat
 (lambda (char) (format "%02x" char))
 (gnutls-hash-mac 'SHA1 "key" "value")
 "")
#+END_SRC

#+RESULTS:
: "57443a4c052350a44638835d64fd66822f813319"

* gnutls-negotiate

#+BEGIN_SRC elisp
(let* ((host "example.com") (port 443)
       (buffer (generate-new-buffer "*https*"))
       (proc (make-network-process
              :name "https"
              :buffer buffer
              :host host
              :service port)))
  (display-buffer buffer)
  (gnutls-negotiate :process proc
                    :hostname host)
  (process-send-string
   proc
   "GET / HTTP/1.1\r\nHost: example.com\r\nConnection: Close\r\n\r\n"))
#+END_SRC

* gnutls-symmetric-decrypt

#+BEGIN_SRC elisp
(gnutls-symmetric-decrypt
 'RC2-40 "key12" "iv123456"
 (unibyte-string
  96 70 247 93 105 98 150 70))
#+END_SRC

#+RESULTS:
: ("VALUE121" "iv123456")

* gnutls-symmetric-encrypt

#+BEGIN_SRC elisp
(gnutls-symmetric-encrypt 'RC2-40 "key12" "iv123456" "VALUE121")
#+END_SRC

#+RESULTS:
: ("`F\367]ib\226F" "iv123456")

* goto-char

#+BEGIN_SRC elisp :results silent
(goto-char (point-min))
#+END_SRC

* group-gid

#+BEGIN_SRC elisp
(group-gid)
#+END_SRC

#+RESULTS:
: 20

* group-name
:PROPERTIES:
:added:    27.1
:END:

#+BEGIN_SRC elisp
(group-name (group-gid))
#+END_SRC

#+RESULTS:
: "staff"

* group-real-gid

#+BEGIN_SRC elisp
(group-real-gid)
#+END_SRC

#+RESULTS:
: 20

* gv-define-setter

#+BEGIN_SRC elisp :eval no
(gv-define-setter caar (val x) `(setcar (car ,x) ,val))
#+END_SRC

* gv-define-simple-setter

#+BEGIN_SRC elisp :eval no
(gv-define-simple-setter car setcar)
#+END_SRC

* hash-table-count

#+BEGIN_SRC elisp
(hash-table-count #s(hash-table data (x 1 y 2 z 3)))
#+END_SRC

#+RESULTS:
: 3

* hash-table-empty-p

#+BEGIN_SRC elisp
(hash-table-empty-p #s(hash-table))
#+END_SRC

#+RESULTS:
: t

* hash-table-keys

#+BEGIN_SRC elisp
(hash-table-keys #s(hash-table data (x 1 y 2 z 3)))
#+END_SRC

#+RESULTS:
: (x y z)

* hash-table-p

#+BEGIN_SRC elisp
(hash-table-p #s(hash-table))
#+END_SRC

#+RESULTS:
: t

* hash-table-rehash-size

#+BEGIN_SRC elisp
(hash-table-rehash-size #s(hash-table))
#+END_SRC

#+RESULTS:
: 1.5

* hash-table-rehash-threshold

#+BEGIN_SRC elisp
(hash-table-rehash-threshold #s(hash-table))
#+END_SRC

#+RESULTS:
: 0.8125

* hash-table-size

#+BEGIN_SRC elisp
(hash-table-size #s(hash-table))
#+END_SRC

#+RESULTS:
: 65

* hash-table-test

#+BEGIN_SRC elisp
(hash-table-test #s(hash-table test eq))
#+END_SRC

#+RESULTS:
: eq

* hash-table-values

#+BEGIN_SRC elisp
(hash-table-values #s(hash-table data (x 1 y 2 z 3)))
#+END_SRC

#+RESULTS:
: (1 2 3)

* hash-table-weakness

#+BEGIN_SRC elisp
(hash-table-weakness #s(hash-table))
#+END_SRC

#+RESULTS:
: nil

* helm-build-async-source

#+BEGIN_SRC elisp :results silent
(helm
 :prompt (format "%s $ find . -type f -iname " (helm-default-directory))
 :sources
 (helm-build-async-source "find"
   :candidates-process
   (lambda ()
     (let ((proc (let (process-connection-type)
                   (apply #'start-process "helm-find" helm-buffer
                          "find" "." "-type" "f"
                          (unless (string-empty-p helm-pattern)
                            (list "-iname" helm-pattern))))))
       (set-process-sentinel proc #'ignore)
       proc))
   :action #'find-file
   :nohighlight t))
#+END_SRC

* helm-build-dummy-source

#+BEGIN_SRC elisp
(helm :sources
      (helm-build-dummy-source "test"
        :filtered-candidate-transformer
        (lambda (_candidates _source)
          (mapcar
           (lambda (c) (format "%c: %d" c c))
           helm-pattern))
        :nohighlight t))
#+END_SRC

* helm-build-in-buffer-source

#+BEGIN_SRC elisp
(helm :sources (helm-build-in-buffer-source "test"
                 :data '("foo" "bar" "baz"))
      :buffer "*helm test*")
#+END_SRC

#+RESULTS:
: "foo"

#+BEGIN_SRC elisp
(helm :sources (helm-build-in-buffer-source "test"
                 :data "foo\nbar\nbaz")
      :buffer "*helm test*")
#+END_SRC

#+RESULTS:
: "baz"

* helm-build-in-file-source

#+BEGIN_SRC elisp
(helm :sources (helm-build-in-file-source "search init.el" user-init-file))
#+END_SRC

#+RESULTS:
: ";;; init.el --- Xu Chunyang's Emacs Configuration  -*- lexical-binding: t; -*-"

* helm-build-sync-source

#+BEGIN_SRC elisp
(helm
 :sources
 (helm-build-sync-source "test"
   :candidates '("foo" "bar" "baz")
   :action '(("Message" . (lambda (candidate) (message "%s selected" candidate)))
             ("Insert" . insert))))
#+END_SRC

#+RESULTS:
: "bar selected"

#+BEGIN_SRC elisp
(helm
 :sources
 (helm-build-sync-source "test"
   :candidates
   ;; (DISPLAY . REAL)
   '(("one" . 1)
     ("two" . 2)
     ("three" . 3))))
#+END_SRC

#+RESULTS:
: 1

#+BEGIN_SRC elisp :results silent
(defvar helm-elisp-demos-source
  (helm-build-sync-source "elisp demos"
    :candidates
    (lambda ()
      (with-temp-buffer
        (insert-buffer "elisp-demos.org")
        (let (headings (linum 1))
          (while (not (eobp))
            (when (looking-at (rx bol "* " (group (1+ nonl)) eol))
              (push (cons (match-string-no-properties 1) linum) headings))
            (cl-incf linum)
            (forward-line 1))
          (nreverse headings))))
    :action (helm-make-actions
             "Goto line"
             (lambda (linum)
               (switch-to-buffer "elisp-demos.org")
               (goto-line linum)))))

(helm :sources helm-elisp-demos-source)
#+END_SRC

* help-C-file-name

#+BEGIN_SRC elisp
(help-C-file-name (symbol-function 'if) 'subr)
#+END_SRC

#+RESULTS:
: "src/eval.c"

* hmac-md5

#+BEGIN_SRC elisp
(encode-hex-string (hmac-md5 "Hi There" (make-string 16 ?\x0b)))
#+END_SRC

#+RESULTS:
: "9294727a3638bb1c13f48ef8158bfc9d"

* hmac-md5-96

#+BEGIN_SRC elisp
(encode-hex-string
 (hmac-md5-96 "Test With Truncation" (make-string 16 ?\x0c)))
#+END_SRC

#+RESULTS:
: "56461ef2342edc00f9bab995"

* identity

#+BEGIN_SRC elisp
(identity 42)
#+END_SRC

#+RESULTS:
: 42

* ietf-drums-parse-date-string
:PROPERTIES:
:added:    29.1
:END:

#+BEGIN_SRC elisp
(ietf-drums-parse-date-string "Tue, 16 Jan 2024 00:02:50 +0800")
#+END_SRC

#+RESULTS:
: (50 2 0 16 1 2024 2 -1 28800)

* if

#+BEGIN_SRC elisp
(if nil 1 2)
#+END_SRC

#+RESULTS:
: 2

* if-let
:PROPERTIES:
:added:    25.1
:END:

#+BEGIN_SRC elisp
(if-let ((match-index (string-match "d" "abcd")))
    (+ match-index 2)
  "It does not match")
#+END_SRC

#+RESULTS:
: 5

* if-let*
:PROPERTIES:
:added:    26.1
:END:

#+BEGIN_SRC elisp
(if-let* ((match-index (string-match "d" "abcd")))
    (+ match-index 2)
  "It does not match")
#+END_SRC

#+RESULTS:
: 5

* ignore

#+BEGIN_SRC elisp
(ignore 42)
#+END_SRC

#+RESULTS:
: nil

* ignore-error
:PROPERTIES:
:added:    27.1
:END:

#+BEGIN_SRC elisp
(ignore-error end-of-file
  (read ""))
#+END_SRC

#+RESULTS:
: nil

* ignore-errors

#+BEGIN_SRC elisp
(ignore-errors (/ 1 0))
#+END_SRC

#+RESULTS:
: nil

* image-transforms-p
:PROPERTIES:
:added:    27.1
:END:

#+BEGIN_SRC elisp
(image-transforms-p)
#+END_SRC

#+RESULTS:
: (scale rotate90)

* image-type-available-p
:PROPERTIES:
:changes:  29.1 Support for the WebP image format.
:END:

#+BEGIN_SRC elisp
(image-type-available-p 'imagemagick)
#+END_SRC

#+RESULTS:
: t

* imap-open

#+BEGIN_SRC elisp
(let* ((server "imap.fastmail.com")
       (user "mail@xuchunyang.me")
       (pass (when-let ((auth (car (auth-source-search
                                    :host server
                                    :user user
                                    :max 1)))
                        (pass (plist-get auth :secret)))
               (funcall pass))))
  (with-current-buffer (imap-open server nil 'tls)
    (imap-authenticate user pass)
    (imap-mailbox-select "INBOX" 'read-only)
    (prog1 (message "You have %d unread emails in Inbox"
                    (length (imap-search "UNSEEN")))
      (imap-close))))
#+END_SRC

#+RESULTS:
: "You have 3 unread emails in Inbox"

* indirect-function

#+BEGIN_SRC elisp
(indirect-function #'+)
#+END_SRC

#+RESULTS:
: #<subr +>

* indirect-variable

#+BEGIN_SRC elisp
(indirect-variable 'indicate-unused-lines)
#+END_SRC

#+RESULTS:
: indicate-empty-lines

* insert

#+BEGIN_SRC elisp
(with-temp-buffer
  (insert "hello" ?\s "world" ?\n)
  (buffer-string))
#+END_SRC

#+RESULTS:
: "hello world\n"

* insert-buffer-substring

#+BEGIN_SRC elisp
(let ((src (generate-new-buffer "*source*"))
      (dst (generate-new-buffer "*destination*")))
  (princ "hello world" src)
  (prog1 (with-current-buffer dst
           (insert-buffer-substring src 1 6)
           (buffer-string))
    (kill-buffer src)
    (kill-buffer dst)))
#+END_SRC

#+RESULTS:
: "hello"

* insert-button

#+BEGIN_SRC elisp :eval no
(insert-button
 "Example"
 'face 'link
 'action (lambda (_button)
           (browse-url "http://example.com"))
 'help-echo "mouse-2, RET: Follow this link"
 'follow-link t)
#+END_SRC

* insert-directory

#+BEGIN_SRC elisp :results value drawer
(with-temp-buffer
  (insert-directory "." nil nil t)
  (buffer-string))
#+END_SRC

#+RESULTS:
:RESULTS:
Makefile
README.md
elisp-demos-tests.el
elisp-demos.el
elisp-demos.org
htmlize.el
screenshot.png
todo.org
:END:

#+BEGIN_SRC elisp :eval no
;; GNU Coreutils's ls supports --dired and insert-directory treats --dired
;; specially by adding the text property named "dired-filename" to it
(insert-directory "." "-l --dired" nil t)
#+END_SRC

* insert-file-contents

#+BEGIN_SRC elisp
(let ((temp-file (make-temp-file "elisp-demos-")))
  (unwind-protect
      (progn
        (write-region "Hello World\n" nil temp-file)
        (with-temp-buffer
          (insert-file-contents temp-file)
          (buffer-string)))
    (delete-file temp-file)))
#+END_SRC

#+RESULTS:
: "Hello World\n"

* insert-file-contents-literally

#+BEGIN_SRC elisp
;; Unicode Check Mark, âœ“, #x2713, #xE2 #x9C #x93
(write-region (string #x2713) nil "/tmp/tmp.txt")

(list (with-temp-buffer
        (insert-file-contents-literally "/tmp/tmp.txt")
        (buffer-string))
      (with-temp-buffer
        (insert-file-contents "/tmp/tmp.txt")
        (buffer-string)))
#+END_SRC

#+RESULTS:
: ("\342\234\223" "âœ“")

* insert-image

#+BEGIN_SRC elisp :eval no
(insert-image (create-image "splash.png"))
#+END_SRC

* insert-image-file

#+BEGIN_SRC elisp :eval no
(insert-image-file
 (expand-file-name "splash.png" (car image-load-path)))
#+END_SRC

* insert-into-buffer
:PROPERTIES:
:added:    28.1
:END:

#+BEGIN_SRC elisp
(with-temp-buffer
  (insert "HELLO ")
  (let ((target-buffer (current-buffer)))
    (with-temp-buffer
      (insert "WORLD")
      (insert-into-buffer target-buffer)))
  (buffer-string))
#+END_SRC

#+RESULTS:
: "HELLO WORLD"

* insert-text-button

#+BEGIN_SRC elisp :eval no
(insert-text-button
   "Example"
   'face 'link
   'action (lambda (_button)
             (browse-url "http://example.com"))
   'help-echo "mouse-2, RET: Follow this link"
   'follow-link t)
#+END_SRC

#+BEGIN_SRC elisp
(list (with-temp-buffer (insert-button      "Example") (buffer-string))
      (with-temp-buffer (insert-text-button "Example") (buffer-string)))
#+END_SRC

#+RESULTS:
: ("Example"
:  #("Example" 0 7
:    (button
:     (t)
:     category default-button)))

* integerp

#+BEGIN_SRC elisp
(integerp 42)
#+END_SRC

#+RESULTS:
: t

* interactive
:PROPERTIES:
:changes:  28.1 The 'interactive' syntax has been extended to allow listing applicable modes.
:END:

#+BEGIN_SRC elisp :eval no
(interactive "sName: \nbBuffer: \nP")
;; (list (read-string "Name: ")
;;       (read-buffer "Buffer: ")
;;       current-prefix-arg)
#+END_SRC

* intern

#+BEGIN_SRC elisp
(intern "foo")
#+END_SRC

#+RESULTS:
: foo

* intern-soft

#+BEGIN_SRC elisp
(list (intern-soft "abcde")
      (intern-soft "intern-soft"))
#+END_SRC

#+RESULTS:
: (nil intern-soft)

* interrupt-process

#+BEGIN_SRC elisp
(interrupt-process (start-process "sleep" nil "sleep" "100"))
#+END_SRC

#+RESULTS:
: #<process sleep>

* isnan

#+BEGIN_SRC elisp
(isnan 0.0e+NaN)
#+END_SRC

#+RESULTS:
: t

* iso8601-parse
:PROPERTIES:
:added:    27.1
:END:

#+BEGIN_SRC elisp
(iso8601-parse "2020-01-01T18:32:12+08:00")
#+END_SRC

#+RESULTS:
: (12 32 18 1 1 2020 nil nil 28800)

* iso8601-parse-date
:PROPERTIES:
:added:    27.1
:END:

#+BEGIN_SRC elisp
(iso8601-parse-date "2020-01-22")
#+END_SRC

#+RESULTS:
: (nil nil nil 22 1 2020 nil nil nil)

* iso8601-parse-duration
:PROPERTIES:
:added:    27.1
:END:

#+BEGIN_SRC elisp
(iso8601-parse-duration "P3Y6M4DT12H30M5S")
#+END_SRC

#+RESULTS:
: (5 30 12 4 6 3 nil nil nil)

* iso8601-parse-time

#+BEGIN_SRC elisp
(iso8601-parse-time "18:32:12")
#+END_SRC

#+RESULTS:
: (12 32 18 nil nil nil nil nil nil)

* iter-defun
:PROPERTIES:
:added:    25.1
:END:

#+BEGIN_SRC elisp :lexical t
(iter-defun foo-number-sequence (start)
  (while t
    (iter-yield start)
    (setq start (1+ start))))

(cl-loop repeat 10
         for n iter-by (foo-number-sequence 1)
         collect n)
#+END_SRC

#+RESULTS:
: (1 2 3 4 5 6 7 8 9 10)

* iter-do
:PROPERTIES:
:added:    25.1
:END:

#+BEGIN_SRC elisp :lexical t
(iter-defun foo-number-sequence (start)
  (while t
    (iter-yield start)
    (setq start (1+ start))))

(catch 'break
  (let ((count 0) result)
    (iter-do (n (foo-number-sequence 1))
      (if (< count 10)
          (push n result)
        (throw 'break (nreverse result)))
      (setq count (1+ count)))))
#+END_SRC

#+RESULTS:
: (1 2 3 4 5 6 7 8 9 10)

* iter-lambda
:PROPERTIES:
:added:    25.1
:END:

#+BEGIN_SRC elisp :lexical t
(cl-loop for n iter-by (funcall (iter-lambda ()
                                  (dotimes (i 10)
                                    (iter-yield i))))
         collect n)
#+END_SRC

#+RESULTS:
: (0 1 2 3 4 5 6 7 8 9)

#+BEGIN_SRC elisp :lexical t
(let ((iter (funcall
             (let ((m 0) (n 1))
               (iter-lambda ()
                 (while t
                   (iter-yield m)
                   (cl-psetq m n
                             n (+ m n))))))))
  (cl-loop for i below 10
           collect (iter-next iter)))
#+END_SRC

#+RESULTS:
: (0 1 1 2 3 5 8 13 21 34)

* iter-next
:PROPERTIES:
:added:    25.1
:END:

#+BEGIN_SRC elisp :lexical t
(let ((i (funcall (iter-lambda ()
                    (iter-yield 1)
                    (iter-yield 2)
                    (iter-yield 3)))))
  (list (iter-next i)
        (iter-next i)
        (iter-next i)))
#+END_SRC

#+RESULTS:
: (1 2 3)

* iter-yield
:PROPERTIES:
:added:    25.1
:END:

#+BEGIN_SRC elisp :lexical t
(let ((it (funcall (iter-lambda ()
                     (iter-yield 1)
                     2))))
  (iter-next it))
#+END_SRC

#+RESULTS:
: 1

* iter-yield-from
:PROPERTIES:
:added:    25.1
:END:

#+BEGIN_SRC elisp :lexical t
(let* ((it (funcall (iter-lambda ()
                      (iter-yield 1)
                      (iter-yield 2)
                      (iter-yield 3))))
       (it2 (funcall (iter-lambda ()
                       (iter-yield-from it)))))
  (list (iter-next it2)
        (iter-next it2)
        (iter-next it2)))
#+END_SRC

#+RESULTS:
: (1 2 3)

* json-available-p
:PROPERTIES:
:added:    28.1
:END:

#+BEGIN_SRC elisp
(json-available-p)
#+END_SRC

#+RESULTS:
: t

* json-encode

#+BEGIN_SRC elisp
(json-encode '((id . 42)
               (comment ((author . "Spike")
                         (date . "2018-11-08")))))

;; backquote
(json-encode `((content . ,(concat "Hello, " "world"))))
#+END_SRC

#+RESULTS:
: "{\"id\":42,\"comment\":[{\"author\":\"Spike\",\"date\":\"2018-11-08\"}]}"
: "{\"content\":\"Hello, world\"}"

* json-insert
:PROPERTIES:
:added:    27.1
:END:

#+BEGIN_SRC elisp
(with-temp-buffer
  (json-insert '(:id 42 :message "hello world"))
  (buffer-string))
#+END_SRC

#+RESULTS:
: "{\"id\":42,\"message\":\"hello world\"}"

* json-parse-buffer
:PROPERTIES:
:added:    27.1
:END:

#+BEGIN_SRC elisp
(with-current-buffer (url-retrieve-synchronously "https://api.github.com/status")
  (goto-char url-http-end-of-headers)
  (json-parse-buffer :object-type 'alist))
#+END_SRC

#+RESULTS:
: ((message . "GitHub lives! (2018-11-08 07:59:55 -0800) (1)"))

* json-parse-string
:PROPERTIES:
:added:    27.1
:END:

#+BEGIN_SRC elisp
(json-parse-string "{\"name\": \"Jessica\"}"
                   :object-type 'plist)
#+END_SRC

#+RESULTS:
: (:name "Jessica")

* json-pretty-print
:PROPERTIES:
:changes:  25.1 The ordering of object keys will not be changed.
:END:

#+BEGIN_SRC elisp :results raw :wrap SRC json
(with-temp-buffer
  (insert " {  \"foo\" : 12, \n\n\n \"bar\":    34}")
  (json-pretty-print (point-min) (point-max))
  (buffer-string))
#+END_SRC

#+RESULTS:
#+BEGIN_SRC json
{
  "foo": 12,
  "bar": 34
}
#+END_SRC

* json-pretty-print-ordered
:PROPERTIES:
:added:    25.1
:END:

#+BEGIN_SRC elisp
(with-temp-buffer
  (insert (json-encode '((c . 3)
                         (a . 1)
                         (b . 2))))
  (json-pretty-print-ordered (point-min) (point-max))
  (goto-char (point-min))
  (json-read))
#+END_SRC

#+RESULTS:
: ((a . 1)
:  (b . 2)
:  (c . 3))

* json-read

#+BEGIN_SRC elisp
(with-current-buffer (url-retrieve-synchronously "https://api.github.com/status")
  (goto-char url-http-end-of-headers)
  (json-read))
#+END_SRC

#+RESULTS:
: ((message . "GitHub lives! (2018-11-08 07:42:52 -0800) (1)"))

* json-read-file

#+BEGIN_SRC elisp
(write-region "{\"name\": \"Jessica\"}" nil "/tmp/tmp.json")
(json-read-file "/tmp/tmp.json")
#+END_SRC

#+RESULTS:
: ((name . "Jessica"))

* json-read-from-string

#+BEGIN_SRC elisp
(json-read-from-string "{\"name\": \"Tom\", \"age\": 13}")
#+END_SRC

#+RESULTS:
: ((name . "Tom")
:  (age . 13))

* json-serialize
:PROPERTIES:
:added:    27.1
:END:

#+BEGIN_SRC elisp
(json-serialize '(:id 42 :message "hello world"))
#+END_SRC

#+RESULTS:
: "{\"id\":42,\"message\":\"hello world\"}"

* jsonrpc-process-connection

#+BEGIN_SRC elisp
(make-network-process
 :name "JSONRPC server"
 :server t
 :host "localhost"
 :service 44444
 :log
 (lambda (_server client _message)
   (jsonrpc-process-connection
    :name (process-name client)
    :process client
    :request-dispatcher
    (lambda (_endpoint method params)
      (unless (memq method '(+ - * /))
        (signal 'jsonrpc-error
                '((jsonrpc-error-message . "Sorry, this isn't allowed")
                  (jsonrpc-error-code . -32601))))
      (apply method (append params nil))))))

(jsonrpc-process-connection
 :name "JSONRPC client"
 :process (make-network-process
           :name "JSONRPC client process"
           :host "localhost"
           :service 44444))

(jsonrpc-request
 (process-get
  (get-process "JSONRPC client process")
  'jsonrpc-connection)
 '* [3 4])
#+END_SRC

#+RESULTS:
: 12

* kbd

#+BEGIN_SRC elisp
(kbd "C-x C-f")
#+END_SRC

#+RESULTS:
: ""

* key-binding

#+BEGIN_SRC elisp
(key-binding (kbd "C-x C-s"))
#+END_SRC

#+RESULTS:
: save-buffer

* key-valid-p
:PROPERTIES:
:added:    29.1
:END:

#+BEGIN_SRC elisp
(key-valid-p "C-c C-c")
#+END_SRC

#+RESULTS:
: t

* keymap-parent

#+BEGIN_SRC elisp
(let ((map (make-sparse-keymap)))
  (set-keymap-parent map text-mode-map)
  (eq text-mode-map (keymap-parent map)))
#+END_SRC

#+RESULTS:
: t

* keymapp

#+BEGIN_SRC elisp
(keymapp (current-global-map))
#+END_SRC

#+RESULTS:
: t

* keywordp

#+BEGIN_SRC elisp
(keywordp :foo)
#+END_SRC

#+RESULTS:
: t

* kill-buffer

#+BEGIN_SRC elisp
(kill-buffer (generate-new-buffer "*test*"))
#+END_SRC

#+RESULTS:
: t

* kill-emacs

#+BEGIN_SRC elisp :eval no
(kill-emacs 0)
#+END_SRC

* kill-new

#+BEGIN_SRC elisp
(kill-new "This message will be copied")
#+END_SRC

#+RESULTS:
: "This message will be copied"

* lambda

#+BEGIN_SRC elisp
(lambda (x) (+ x 100))
#+END_SRC

#+RESULTS:
: (lambda
:   (x)
:   (+ x 100))

* last

#+BEGIN_SRC elisp
(last '(1 2 3))
#+END_SRC

#+RESULTS:
: (3)

* last-buffer

#+BEGIN_SRC elisp
(last-buffer)
#+END_SRC

#+RESULTS:
: #<buffer magit: elisp-demos>

* lax-plist-get

#+BEGIN_SRC elisp
(lax-plist-get '("foo" 1 "bar" 2) "bar")
#+END_SRC

#+RESULTS:
: 2

* lax-plist-put

#+BEGIN_SRC elisp
(let ((plist (list "a" 1 "b" 2)))
  (setq plist (lax-plist-put plist "b" 200)))
#+END_SRC

#+RESULTS:
: ("a" 1 "b" 200)

* ldexp

#+BEGIN_SRC elisp
(ldexp 0.5 4)
#+END_SRC

#+RESULTS:
: 8.0

* length

#+BEGIN_SRC elisp
(length '(1 2 3))
#+END_SRC

#+RESULTS:
: 3

#+BEGIN_SRC elisp
(length [1 2 3])
#+END_SRC

#+RESULTS:
: 3

#+BEGIN_SRC elisp
;; Return the number of characters
(length "123")
#+END_SRC

#+RESULTS:
: 3

* length<
:PROPERTIES:
:added:    28.1
:END:

#+BEGIN_SRC elisp
(length< obarray 99999)
#+END_SRC

#+RESULTS:
: t

* length=
:PROPERTIES:
:added:    28.1
:END:

#+BEGIN_SRC elisp
(length= [1 3 5] 3)
#+END_SRC

#+RESULTS:
: t

* length>
:PROPERTIES:
:added:    28.1
:END:

#+BEGIN_SRC elisp
(length> load-history 100)
#+END_SRC

* let

#+BEGIN_SRC elisp
(let ((x 42))
  x)
#+END_SRC

#+RESULTS:
: 42

* let*

#+BEGIN_SRC elisp
(let* ((x 1)
       (y (+ x 100)))
  y)
#+END_SRC

#+RESULTS:
: 101

* let-alist
:PROPERTIES:
:added:    25.1
:END:

#+BEGIN_SRC elisp
(let-alist '((id . 1234)
             (payload
              (url . "https://example.com")
              (title . "Example Domain")
              (content . "This domain is...")))
  (list :id .id
        :url .payload.url))
#+END_SRC

#+RESULTS:
: (:id 1234 :url "https://example.com")

* letrec
:PROPERTIES:
:added:    24.1
:END:

#+BEGIN_SRC elisp
(letrec ((len (lambda (list)
                (if list
                    (1+ (funcall len (cdr list)))
                  0))))
  (funcall len '(a b c)))
#+END_SRC

#+RESULTS:
: 3

* libxml-available-p
:PROPERTIES:
:added:    27.1
:END:

#+BEGIN_SRC elisp
(libxml-available-p)
#+END_SRC

#+RESULTS:
: t

* libxml-parse-html-region

#+BEGIN_SRC elisp
(with-temp-buffer
  (insert "<html><body><h1>Heading 1</h1><p>...</p></body></html>")
  (libxml-parse-html-region (point-min) (point-max)))
#+END_SRC

#+RESULTS:
: (html nil
:       (body nil
:             (h1 nil "Heading 1")
:             (p nil "...")))

#+BEGIN_SRC elisp :results silent
(with-current-buffer (url-retrieve-synchronously "http://example.com")
  (libxml-parse-html-region url-http-end-of-headers (point-max)))
#+END_SRC

* libxml-parse-xml-region

#+BEGIN_SRC elisp
(with-temp-buffer
  (insert "<note>
  <to>Tove</to>
  <from>Jani</from>
  <heading>Reminder</heading>
  <body>Don't forget me this weekend!</body></note>")
  (libxml-parse-xml-region (point-min) (point-max)))
#+END_SRC

#+RESULTS:
: (note nil
:       (to nil "Tove")
:       (from nil "Jani")
:       (heading nil "Reminder")
:       (body nil "Don't forget me this weekend!"))

* line-beginning-position

#+BEGIN_SRC elisp
(line-beginning-position)
#+END_SRC

#+RESULTS:
: 25771

* line-end-position

#+BEGIN_SRC elisp
(line-end-position)
#+END_SRC

#+RESULTS:
: 25980

* line-number-at-pos
:PROPERTIES:
:changes:  26.1 The ABSOLUTE argument is added.
:END:

#+BEGIN_SRC elisp
(with-temp-buffer
  (insert "foo\n"
          "bar\n"
          "baz\n")
  (line-number-at-pos))
#+END_SRC

#+RESULTS:
: 4

* list

#+BEGIN_SRC elisp
(list 1 2 3)
#+END_SRC

#+RESULTS:
: (1 2 3)

* list-system-processes

#+BEGIN_SRC elisp :results silent
(list-system-processes)
#+END_SRC

* listp

#+BEGIN_SRC elisp
;; normal list
(listp '(1 2 3))
#+END_SRC

#+RESULTS:
: t

#+BEGIN_SRC elisp
;; empty list (aka nil)
(listp '())
#+END_SRC

#+RESULTS:
: t

#+BEGIN_SRC elisp
;; cons cell
(listp '(1 . 2))
#+END_SRC

#+RESULTS:
: t

* lm-authors

#+BEGIN_SRC elisp
(lm-authors (find-library-name "magit"))
#+END_SRC

#+RESULTS:
: (("Marius Vollmer" . "marius.vollmer@gmail.com"))

* lm-commentary

#+BEGIN_SRC elisp :results drawer
(lm-commentary (find-library-name "cl-lib"))
#+END_SRC

#+RESULTS:
:RESULTS:
;;; Commentary:

;; These are extensions to Emacs Lisp that provide a degree of
;; Common Lisp compatibility, beyond what is already built-in
;; in Emacs Lisp.
;;
;; This package was written by Dave Gillespie; it is a complete
;; rewrite of Cesar Quiroz's original cl.el package of December 1986.
;;
;; Bug reports, comments, and suggestions are welcome!

;; This file contains the portions of the Common Lisp extensions
;; package which should always be present.


:END:

* lm-header

#+BEGIN_SRC elisp
(lm-with-file (find-library-name "elisp-demos")
  (lm-header "package-requires"))
#+END_SRC

#+RESULTS:
: "((emacs \"24.4\"))"

* lm-homepage

#+BEGIN_SRC elisp
(lm-homepage (find-library-name "magit"))
#+END_SRC

#+RESULTS:
: "https://github.com/magit/magit"

* lm-maintainer

#+BEGIN_SRC elisp
(lm-maintainer (find-library-name "magit"))
#+END_SRC

#+RESULTS:
: ("Jonas Bernoulli" . "jonas@bernoul.li")

* lm-summary

#+BEGIN_SRC elisp
(lm-summary (find-library-name "cl-lib"))
#+END_SRC

#+RESULTS:
: "Common Lisp extensions for Emacs"

* load-average

#+BEGIN_SRC elisp
(load-average)
#+END_SRC

#+RESULTS:
: (108 117 122)

* locale-info

#+BEGIN_SRC elisp
(locale-info 'days)
#+END_SRC

#+RESULTS:
: ["Sunday" "Monday" "Tuesday" "Wednesday" "Thursday" "Friday" "Saturday"]

* locale-translate

#+BEGIN_SRC elisp
(locale-translate "slovene")
#+END_SRC

#+RESULTS:
: "sl_SI.ISO-8859-2"

* locate-dominating-file

#+BEGIN_SRC elisp
(locate-dominating-file "." ".git")
#+END_SRC

#+RESULTS:
: "~/src/elisp-demos/"

* locate-file

#+BEGIN_SRC elisp
(locate-file "init.el" '("~/.emacs.d/"))
#+END_SRC

#+RESULTS:
: "/Users/xcy/.emacs.d/init.el"

* locate-library

#+BEGIN_SRC elisp
(locate-library "pcase")
#+END_SRC

#+RESULTS:
: "/Users/xcy/src/emacs-mac/lisp/emacs-lisp/pcase.elc"

#+BEGIN_SRC elisp
(locate-library "pcase.el")
#+END_SRC

#+RESULTS:
: "/Users/xcy/src/emacs-mac/lisp/emacs-lisp/pcase.el"

* locate-user-emacs-file

#+BEGIN_SRC elisp
(locate-user-emacs-file "custom.el")
#+END_SRC

#+RESULTS:
: "~/.emacs.d/custom.el"

* log

#+BEGIN_SRC elisp
(log 8 2)
#+END_SRC

#+RESULTS:
: 3.0

* logand

#+BEGIN_SRC elisp
(logand #B1110
        #B1101)
#+END_SRC

#+RESULTS:
: 12

* logb

#+BEGIN_SRC elisp
(logb 8)
#+END_SRC

#+RESULTS:
: 3

* logcount
:PROPERTIES:
:added:    27.1
:END:

#+BEGIN_SRC elisp
(logcount #B101011)
#+END_SRC

#+RESULTS:
: 4

* logior

#+BEGIN_SRC elisp
(logior #B1100
        #B0101)
#+END_SRC

#+RESULTS:
: 13

* lognot

#+BEGIN_SRC elisp
(lognot #B101)
#+END_SRC

#+RESULTS:
: -6

* logxor

#+BEGIN_SRC elisp
(logxor #B1100
        #B0101)
#+END_SRC

#+RESULTS:
: 9

* looking-at

#+BEGIN_SRC elisp
(with-temp-buffer
  (insert "hello\n")
  (goto-char (point-min))
  (looking-at "^hello$"))
#+END_SRC

#+RESULTS:
: t

* looking-at-p

#+BEGIN_SRC elisp
(with-temp-buffer
  (insert "hello\n")
  (goto-char (point-min))
  (looking-at-p "^hello$"))
#+END_SRC

#+RESULTS:
: t

* looking-back

#+BEGIN_SRC elisp
(with-temp-buffer
  (insert "hello")
  (looking-back "^hello$" (line-beginning-position)))
#+END_SRC

#+RESULTS:
: t

* lookup-key

#+BEGIN_SRC elisp
(lookup-key (current-global-map) (kbd "C-x C-c"))
#+END_SRC

#+RESULTS:
: save-buffers-kill-terminal

* lsh
:PROPERTIES:
:changes:  29.1 Calling 'lsh' now elicits a byte-compiler warning.
:END:

#+BEGIN_SRC elisp
(lsh #B111 1)
#+END_SRC

#+RESULTS:
: 14

* macroexpand

#+BEGIN_SRC elisp
(macroexpand '(when t 0 42))
#+END_SRC

#+RESULTS:
: (if t
:     (progn 0 42))

* macroexpand-all

#+BEGIN_SRC elisp
(macroexpand-all
 '(when-let ((buffer (get-buffer "*Help*")))
    (setf (point) 1)))
#+END_SRC

#+RESULTS:
: (let*
:     ((buffer
:       (and t
:            (get-buffer "*Help*"))))
:   (if buffer
:       (goto-char 1)
:     nil))

* macrop
:PROPERTIES:
:added:    24.4
:END:

#+BEGIN_SRC elisp
(macrop 'when)
#+END_SRC

#+RESULTS:
: t

* mail-header-parse-address-lax
:PROPERTIES:
:added:    28.1
:END:

#+BEGIN_SRC elisp
(mail-header-parse-address-lax "Xu Chunyang <xuchunyang56@gmail.com>")
#+END_SRC

#+RESULTS:
: ("xuchunyang56@gmail.com" . "Xu Chunyang")

* mail-header-parse-addresses-lax
:PROPERTIES:
:added:    28.1
:END:

#+BEGIN_SRC elisp
(mail-header-parse-addresses-lax "foo <foo@example.com>, bar@gnu.org")
#+END_SRC

#+RESULTS:
: (("foo@example.com" . "foo")
:  ("bar@gnu.org"))

* make-bool-vector

#+BEGIN_SRC elisp
(vconcat (make-bool-vector 5 t))
#+END_SRC

#+RESULTS:
: [t t t t t]

* make-char-table

#+BEGIN_SRC elisp
;; Make a new empty syntax table
(syntax-table-p
 (make-char-table 'syntax-table nil))
#+END_SRC

#+RESULTS:
: t

* make-comint

#+BEGIN_SRC elisp
(make-comint "Janet" "janet" nil "-s")
#+END_SRC

#+RESULTS:
: #<buffer *Janet*>

* make-comint-in-buffer

#+BEGIN_SRC elisp
(make-comint-in-buffer "Janet" "*Janet*" "janet" nil "-s")
#+END_SRC

#+RESULTS:
: #<buffer *Janet*>

* make-directory

#+BEGIN_SRC elisp
;; mkdir -p
(make-directory "/tmp/elisp-demos/create/a/new/dir" 'parents)
#+END_SRC

#+RESULTS:
: nil

* make-hash-table

#+BEGIN_SRC elisp
(make-hash-table)
#+END_SRC

#+RESULTS:
: #s(hash-table size 65 test eql rehash-size 1.5 rehash-threshold 0.8125 data
: ())

* make-instance

#+BEGIN_SRC elisp
(defclass my-book ()
  ((title :initarg :title :type string)
   (pages :initarg :pages :type integer))
  "A book class.")

;; These two are the same, and the `my-book' function uses `make-instance' under
;; the ground
(list (make-instance 'my-book :title "Practical Vim" :pages 487)
      (my-book                :title "Practical Vim" :pages 487))
#+END_SRC

#+RESULTS:
: (#s(my-book "Practical Vim" 487)
:  #s(my-book "Practical Vim" 487))

* make-keymap

#+BEGIN_SRC elisp :results silent
(make-keymap)
#+END_SRC

* make-list

#+BEGIN_SRC elisp
(make-list 3 'pigs)
#+END_SRC

#+RESULTS:
: (pigs pigs pigs)

* make-nearby-temp-file
:PROPERTIES:
:added:    26.1
:END:

#+BEGIN_SRC elisp
(let ((default-directory "/ssh:root@192.168.8.1:"))
  (make-nearby-temp-file "foo-"))
#+END_SRC

#+RESULTS:
: "/ssh:root@192.168.8.1:/tmp/foo-Mf9ZSa"

* make-network-process

#+BEGIN_SRC elisp :results silent
;; HTTP client
(let ((proc (make-network-process :name "example"
                                  :buffer "*example.com*"
                                  :host "example.com"
                                  :service 80)))
  (process-send-string proc (concat "HEAD / HTTP/1.1\n"
                                    "Host: example.com\n"
                                    "\n"))
  (accept-process-output proc)
  (with-current-buffer (process-buffer proc)
    (buffer-string)))
#+END_SRC

#+BEGIN_SRC elisp
;; TCP server
(make-network-process
 :name "time-server"
 :buffer "*time-server*"
 :server t
 :service 3000
 :sentinel
 (lambda (process event)
   (cond
    ;; "open from 127.0.0.1\n"
    ((string-prefix-p "open from" event)
     (process-send-string process (concat (current-time-string) "\n"))
     (process-send-eof process))
    ((string= "connection broken by remote peer\n" event)
     (kill-buffer (process-buffer process))))))

;; ~ $ nc localhost 3000
;; Wed Jan  1 10:19:30 2020
#+END_SRC

#+RESULTS:
: #<process time-server>

#+BEGIN_SRC elisp :results value raw :wrap EXAMPLE
;; UNIX domain socket client (as Emacsclient)
(let ((buffer "*server-client-test*"))
  (make-network-process
   :service (expand-file-name server-name server-socket-dir)
   :family 'local
   :name "server-client-test"
   :buffer buffer)
  (with-current-buffer buffer
    (process-send-string
     nil
     (concat "-eval "
             (server-quote-arg (format "%S" '(+ 1 2)))
             "\n"))
    (accept-process-output)
    (buffer-string)))
#+END_SRC

#+RESULTS:
#+BEGIN_EXAMPLE
-emacs-pid 67329
-print 3

Process server-client-test connection broken by remote peer
#+END_EXAMPLE

* make-obsolete-variable

#+BEGIN_SRC elisp :eval no
(make-obsolete-variable 'display-buffer-function
                        'display-buffer-alist "24.3")
#+END_SRC

* make-overlay

#+BEGIN_SRC elisp
(with-temp-buffer (make-overlay 1 1))
#+END_SRC

#+RESULTS:
: #<overlay in no buffer>

* make-process
:PROPERTIES:
:added:    25.1
:changes:  29.1 'make-process' has been extended to support ptys when ':stderr' is set.
:END:

#+BEGIN_SRC elisp :results drawer
(with-temp-buffer
  (make-process
   :name "Date"
   :buffer (current-buffer)
   :command '("date" "+%Y-%m-%d-%s")
   :connection-type 'pipe)
  (sit-for 0.1)
  (buffer-string))
#+END_SRC

#+RESULTS:
:RESULTS:
2019-01-21-1548057165

Process Date finished
:END:

* make-progress-reporter

#+BEGIN_SRC elisp
(let ((progress-reporter
       (make-progress-reporter "Collecting mana for Emacs..."
                               0  500)))
  (dotimes (k 500)
    (sit-for 0.01)
    (progress-reporter-update progress-reporter k))
  (progress-reporter-done progress-reporter))
#+END_SRC

#+RESULTS:
: "Collecting mana for Emacs...done"

* make-record
:PROPERTIES:
:added:    26.1
:END:

#+BEGIN_SRC elisp
(make-record 'foo 9 'Z)
#+END_SRC

#+RESULTS:
: #s(foo Z Z Z Z Z Z Z Z Z)

* make-ring

#+BEGIN_SRC elisp
(make-ring 3)
#+END_SRC

#+RESULTS:
: (0 0 .
:    [nil nil nil])

* make-separator-line
:PROPERTIES:
:added:    28.1
:END:

#+BEGIN_SRC elisp
(make-separator-line)
#+END_SRC

#+RESULTS:
: #("\n" 0 1
:   (face
:    (:inherit separator-line :extend t)))

* make-sparse-keymap

#+BEGIN_SRC elisp
(let ((map (make-sparse-keymap)))
  (define-key map "n" #'next-line)
  (define-key map "p" #'previous-line)
  map)
#+END_SRC

#+RESULTS:
: (keymap
:  (112 . previous-line)
:  (110 . next-line))

* make-string
:PROPERTIES:
:changes:  27.1 The optional MULTIBYTE argument is added.
:END:

#+BEGIN_SRC elisp
(make-string 5 ?x)
#+END_SRC

#+RESULTS:
: "xxxxx"

* make-symbol

#+BEGIN_SRC elisp
(make-symbol "foo")
#+END_SRC

#+RESULTS:
: foo

* make-syntax-table

#+BEGIN_SRC elisp
;; Create a new syntax table base on Emacs Lisp's
(syntax-table-p
 (make-syntax-table emacs-lisp-mode-syntax-table))
#+END_SRC

#+RESULTS:
: t

* make-temp-file
:PROPERTIES:
:changes:  26.1 The TEXT argument is added.
:END:

#+BEGIN_SRC elisp
(make-temp-file "elisp-demos-")
#+END_SRC

#+RESULTS:
: "/var/folders/7f/s191h4q97p90374yw15ssrs00000gn/T/elisp-demos-iOSgE2"

* make-temp-name

#+BEGIN_SRC elisp
(make-temp-name "elisp-demos-")
#+END_SRC

#+RESULTS:
: "elisp-demos-hF3633"

* make-thread
:PROPERTIES:
:added:    26.1
:END:

#+BEGIN_SRC elisp
(make-thread
 (lambda ()
   (while t
     (forward-char 1)
     (sit-for 0.1))))
#+END_SRC

#+RESULTS:
: #<thread 0x178fd5a30>

* make-vector

#+BEGIN_SRC elisp
(make-vector 3 'Z)
#+END_SRC

#+RESULTS:
: [Z Z Z]

* map-apply

#+BEGIN_SRC elisp
(map-apply (lambda (idx elt)
             (list idx elt))
           [a b c])
#+END_SRC

#+RESULTS:
: ((0 a)
:  (1 b)
:  (2 c))

#+BEGIN_SRC elisp
(map-apply (lambda (k v)
             (cons k v))
           #s(hash-table data (x 1 y 2)))
#+END_SRC

#+RESULTS:
: ((x . 1)
:  (y . 2))

* map-char-table

#+BEGIN_SRC elisp
(let (result)
  (map-char-table
   (lambda (range value)
     ;; copy `range', see https://github.com/Wilfred/helpful/issues/210
     (push (list (format "%S" range) value) result))
   printable-chars)
  result)
#+END_SRC

#+RESULTS:
: (("(160 . 4194175)" t)
:  ("(32 . 126)" t))

#+BEGIN_SRC elisp
;; How many different kinds of parentheses Emacs knows?
;; () [] {} etc
(let (parens)
  (map-char-table
   (lambda (k v)
     (when (memq (car v) '(4 5))
       (push (cdr v) parens)))
   (syntax-table))
  (/ (length parens) 2))
#+END_SRC

#+RESULTS:
: 53

* map-charset-chars

#+BEGIN_SRC elisp
(let ((count 0))
  (map-charset-chars
   (lambda (range _arg)
     (pcase-let ((`(,from . ,to) range))
       (setq count (+ count (- to from)))))
   'chinese-gbk)
  count)
#+END_SRC

#+RESULTS:
: 45718

* map-contains-key
:PROPERTIES:
:changes:  27.1 'map-contains-key' now returns a boolean rather than the key.
:END:

#+BEGIN_SRC elisp
(map-contains-key '((x . 1) (y . 2)) 'y)
#+END_SRC

#+RESULTS:
: t

* map-copy

#+BEGIN_SRC elisp
(map-copy [a b c])
#+END_SRC

#+RESULTS:
: [a b c]

* map-delete

#+BEGIN_SRC elisp
(let ((alist (list (cons 'x 1)
                   (cons 'y 2)
                   (cons 'z 3))))
  ;; `setq' is necessary otherwise `alist' is unchanged in this case
  (setq alist (map-delete alist 'x))
  alist)
#+END_SRC

#+RESULTS:
: ((y . 2)
:  (z . 3))

* map-do

#+BEGIN_SRC elisp
(let (result)
  (map-do (lambda (k v) (push (* k v) result))
          '((1 . 2)
            (3 . 4)
            (5 . 6)))
  (nreverse result))
#+END_SRC

#+RESULTS:
: (2 12 30)

* map-elt

#+BEGIN_SRC elisp
(map-elt '((x . 1) (y . 2)) 'y)
#+END_SRC

#+RESULTS:
: 2

#+BEGIN_SRC elisp
(map-elt #s(hash-table data (x 1 y 2)) 'y)
#+END_SRC

#+RESULTS:
: 2

#+BEGIN_SRC elisp
(map-elt [1 2 3] 1)
#+END_SRC

#+RESULTS:
: 2

* map-empty-p

#+BEGIN_SRC elisp
(map-empty-p '())
#+END_SRC

#+RESULTS:
: t

* map-every-p

#+BEGIN_SRC elisp
(map-every-p (lambda (key val)
               (= (* key key) val))
             '((1 . 1)
               (2 . 4)
               (3 . 9)
               (4 . 16)))
#+END_SRC

#+RESULTS:
: t

* map-filter

#+BEGIN_SRC elisp
(map-filter (lambda (index _item) (cl-evenp index))
            [a b c d])
#+END_SRC

#+RESULTS:
: ((0 . a)
:  (2 . c))

* map-insert

#+BEGIN_SRC elisp
(map-insert '((x . 1) (y . 2)) 'z 3)
#+END_SRC

#+RESULTS:
: ((z . 3)
:  (x . 1)
:  (y . 2))

* map-into

#+BEGIN_SRC elisp
(map-into #s(hash-table data (x 1 y 2)) 'list)
#+END_SRC

#+RESULTS:
: ((x . 1)
:  (y . 2))

* map-keymap

#+BEGIN_SRC elisp
(let (result)
  (map-keymap
   (lambda (event function)
     (push (cons event function) result))
   (let ((keymap (make-sparse-keymap)))
     (define-key keymap "n" #'next-line)
     (define-key keymap "p" #'previous-line)
     keymap))
  result)
#+END_SRC

#+RESULTS:
: ((110 . next-line)
:  (112 . previous-line))

* map-keys

#+BEGIN_SRC elisp
(map-keys '((a . 1) (b . ((c . 2)))))
#+END_SRC

#+RESULTS:
: (a b)

* map-keys-apply

#+BEGIN_SRC elisp
(map-keys-apply #'identity '((a) (b) (c)))
#+END_SRC

#+RESULTS:
: (a b c)

* map-length

#+BEGIN_SRC elisp
(map-length [a b c])
#+END_SRC

#+RESULTS:
: 3

* map-let

#+BEGIN_SRC elisp
(map-let (one three) '((one . 1)
                       (two . 2)
                       (three . 3))
  (list :one one
        :three three))
#+END_SRC

#+RESULTS:
: (:one 1 :three 3)

#+BEGIN_SRC elisp
(map-let (('one x)  ('three z)) '((one . 1)
                                  (two . 2)
                                  (three . 3))
  (list x z))
#+END_SRC

#+RESULTS:
: (1 3)

* map-merge

#+BEGIN_SRC elisp
(map-merge 'list #s(hash-table data (x 1 y 2)) '((z . 3)))
#+END_SRC

#+RESULTS:
: ((z . 3)
:  (x . 1)
:  (y . 2))

* map-merge-with

#+BEGIN_SRC elisp
(map-merge-with 'list
                (lambda (v1 v2) (list v1 v2))
                #s(hash-table data (x 1 y 2))
                '((x . 3)
                  (y . 4)
                  (z . 5)))
#+END_SRC

#+RESULTS:
: ((z . 5)
:  (x 1 3)
:  (y 2 4))

* map-nested-elt

#+BEGIN_SRC elisp
(map-nested-elt '((post . ((title . "some title"))))
                '(post title))
#+END_SRC

#+RESULTS:
: "some title"

* map-pairs

#+BEGIN_SRC elisp
(map-pairs [1 2 3])
#+END_SRC

#+RESULTS:
: ((0 . 1)
:  (1 . 2)
:  (2 . 3))

* map-put

#+BEGIN_SRC elisp
(let ((alist (list (cons 0 3)
                   (cons 1 4)
                   (cons 2 5))))
  (map-put alist 0 300)
  alist)
#+END_SRC

#+RESULTS:
: ((0 . 300)
:  (1 . 4)
:  (2 . 5))

* map-remove

#+BEGIN_SRC elisp
(map-remove (lambda (index item) (cl-evenp index))
            [a b c d])
#+END_SRC

#+RESULTS:
: ((1 . b)
:  (3 . d))

* map-some

#+BEGIN_SRC elisp
(map-some (lambda (k v)
            (= k v))
          '((1 . 2)
            (3 . 4)
            (5 . 5)))
#+END_SRC

#+RESULTS:
: t

* map-values

#+BEGIN_SRC elisp
(map-values '((a . 1) (b . 2)))
#+END_SRC

#+RESULTS:
: (1 2)

* map-values-apply

#+BEGIN_SRC elisp
(map-values-apply #'identity [a b c])
#+END_SRC

#+RESULTS:
: (a b c)

* mapatoms

#+BEGIN_SRC elisp
(let (commands)
  (mapatoms
   (lambda (symbol)
     (when (commandp symbol)
       (push symbol commands))))
  (message "There are %d Emacs commands" (length commands)))
#+END_SRC

#+RESULTS:
: "There are 7101 Emacs commands"

* mapc

#+BEGIN_SRC elisp :results output
(mapc #'princ '(1 2 3))
#+END_SRC

#+RESULTS:
: "123"

* mapcan
:PROPERTIES:
:added:    26.1
:END:

#+BEGIN_SRC elisp
(mapcan
 (lambda (pair)
   (list (car pair) (cdr pair)))
 '((x . 1) (y . 2) (z . 3)))
#+END_SRC

#+RESULTS:
: (x 1 y 2 z 3)

#+BEGIN_SRC elisp
(mapcan (lambda (x) (and (numberp x) (list x)))
        '(a 1 b c 3 4 d 5))
#+END_SRC

#+RESULTS:
: (1 3 4 5)

* mapcar

#+BEGIN_SRC elisp
(mapcar #'1+ '(1 2 3))
#+END_SRC

#+RESULTS:
: (2 3 4)

* mapconcat
:PROPERTIES:
:changes:  29.1 Third 'mapconcat' argument SEPARATOR is now optional.
:END:

#+BEGIN_SRC elisp
(mapconcat #'identity '("abc" "def" "ghi") ", ")
#+END_SRC

#+RESULTS:
: "abc, def, ghi"

* maphash

#+BEGIN_SRC elisp
(let (alist)
  (maphash (lambda (key val)
             (push (cons key val) alist))
           #s(hash-table data (x 1 y 2)))
  (nreverse alist))
#+END_SRC

#+RESULTS:
: ((x . 1)
:  (y . 2))

* mapp

#+BEGIN_SRC elisp
(mapp '((a 1) (b 2)))
#+END_SRC

#+RESULTS:
: t

* match-buffers

#+BEGIN_SRC elisp
(match-buffers '(major-mode . lisp-interaction-mode))
#+END_SRC

#+RESULTS:
: (#<buffer *scratch*>)

* match-data

#+BEGIN_SRC elisp
(when (string-match "[0-9]+" "<2018-11-30>")
  (match-data))
#+END_SRC

#+RESULTS:
: (1 5)

* match-string

#+BEGIN_SRC elisp
(let ((string "Today is <2018-11-09>")
      (regexp (rx (group (= 4 num)) "-"
                  (group (= 2 num)) "-"
                  (group (= 2 num)))))
  (when (string-match regexp string)
    (list :year (match-string 1 string)
          :month (match-string 2 string)
          :day (match-string 3 string))))
#+END_SRC

#+RESULTS:
: (:year "2018" :month "11" :day "09")

* match-string-no-properties

#+BEGIN_SRC elisp
(let ((string (propertize "hello" 'face 'bold)))
  (string-match ".*" string)
  (list (match-string 0 string)
        (match-string-no-properties 0 string)))
#+END_SRC

#+RESULTS:
: (#("hello" 0 5
:    (face bold))
:  "hello")

* max

#+BEGIN_SRC elisp
(max 1 3 2.5)
#+END_SRC

#+RESULTS:
: 3

* max-char
:PROPERTIES:
:changes:  29.1 The optional UNICODE argument is added.
:END:

#+BEGIN_SRC elisp
(max-char)
#+END_SRC

#+RESULTS:
: 4194303

* md5

#+BEGIN_SRC elisp
(md5 "hello")
#+END_SRC

#+RESULTS:
: "5d41402abc4b2a76b9719d911017c592"

* member

#+BEGIN_SRC elisp
(member '(2) '((1) (2)))
#+END_SRC

#+RESULTS:
: ((2))

* member-ignore-case

#+BEGIN_SRC elisp
(member-ignore-case "foo" '("bar" "Foo"))
#+END_SRC

#+RESULTS:
: ("Foo")

* memq

#+BEGIN_SRC elisp
(memq 'b '(a b c b a))
#+END_SRC

#+RESULTS:
: (b c b a)

* memql

#+BEGIN_SRC elisp
(memql 1.2 '(1.1 1.2 1.3))
#+END_SRC

#+RESULTS:
: (1.2 1.3)

* merge-face-attribute

#+BEGIN_SRC elisp
(merge-face-attribute :height 2.0 3.0)
#+END_SRC

#+RESULTS:
: 6.0

* message

#+BEGIN_SRC elisp
(message "Hi, %s!" "Tyke")
#+END_SRC

#+RESULTS:
: "Hi, Tyke!"

* min

#+BEGIN_SRC elisp
(min -4 1)
#+END_SRC

#+RESULTS:
: -4

* minibuffer-window

#+BEGIN_SRC elisp
(minibuffer-window)
#+END_SRC

#+RESULTS:
: #<window 4 on  *Minibuf-0*>

* minibuffer-with-setup-hook

#+BEGIN_SRC elisp
(minibuffer-with-setup-hook
    (lambda () (insert "hello world"))
  (read-string "Enter something: "))
#+END_SRC

#+RESULTS:
: "hello world"

* minibufferp

#+BEGIN_SRC elisp
(minibufferp)
#+END_SRC

#+RESULTS:
: nil

* mm-default-file-encoding

#+BEGIN_SRC elisp
(mm-default-file-encoding "index.html")
#+END_SRC

#+RESULTS:
: "text/html"

* mm-url-encode-multipart-form-data

#+BEGIN_SRC elisp :results silent
(mm-url-encode-multipart-form-data
 '(("username" . "john")
   ("password" . "secret")))
#+END_SRC

* mod

#+BEGIN_SRC elisp
(mod 5.5 2.5)
#+END_SRC

#+RESULTS:
: 0.5

* modify-syntax-entry

#+BEGIN_SRC elisp
(with-temp-buffer
  (insert "BEG (a) <b> [c] {d} END")
  (goto-char (point-min))
  (set-syntax-table
   (let ((table (make-char-table 'syntax-table)))
     ;; <> and {} are parenthesis, others aren't
     (modify-syntax-entry ?\< "(>" table)
     (modify-syntax-entry ?\> ")<" table)
     (modify-syntax-entry ?\{ "(}" table)
     (modify-syntax-entry ?\} "){" table)
     table))
  (goto-char (scan-lists (point) 1 0))
  (insert "|")
  (goto-char (scan-lists (point) 1 0))
  (insert "|")
  (buffer-string))
#+END_SRC

#+RESULTS:
: "BEG (a) <b>| [c] {d}| END"

* move-overlay

#+BEGIN_SRC elisp
(with-temp-buffer
  (let ((ov (make-overlay 1 1)))
    (insert "hello")
    (format "%S" (move-overlay ov 1 6))))
#+END_SRC

#+RESULTS:
: "#<overlay from 1 to 6 in  *temp*>"

* multibyte-char-to-unibyte

#+BEGIN_SRC elisp
(multibyte-char-to-unibyte #x3FFF80)
#+END_SRC

#+RESULTS:
: 128

* multibyte-string-p

#+BEGIN_SRC elisp
(list (multibyte-string-p "lambda")
      (multibyte-string-p "Î»"))
#+END_SRC

#+RESULTS:
: (nil t)

#+BEGIN_SRC elisp
;; This is strange
(list (multibyte-string-p "hello")
      (multibyte-string-p (symbol-name 'hello)))
#+END_SRC

#+RESULTS:
: (nil t)

* narrow-to-region

#+BEGIN_SRC elisp
(with-temp-buffer
  (insert "hello world")
  (narrow-to-region 1 6)
  (buffer-string))
#+END_SRC

#+RESULTS:
: "hello"

* native-comp-available-p
:PROPERTIES:
:added:    28.1
:END:

#+BEGIN_SRC elisp
(native-comp-available-p)
#+END_SRC

#+RESULTS:
: nil

* natnump

#+BEGIN_SRC elisp
(natnump 0)
#+END_SRC

#+RESULTS:
: t

* nbutlast

#+BEGIN_SRC elisp
(let ((list (list 1 2 3 4 5)))
  (nbutlast list 2)
  list)
#+END_SRC

#+RESULTS:
: (1 2 3)

* nconc

#+BEGIN_SRC elisp
(let ((x (list 1 2))
      (y '(3 4)))
  (nconc x y)
  x)
#+END_SRC

#+RESULTS:
: (1 2 3 4)

* netrc-credentials

#+BEGIN_SRC elisp :results silent
(netrc-credentials "api.github.com")
#+END_SRC

* netrc-parse

#+BEGIN_SRC elisp :results silent
(netrc-parse)
#+END_SRC

* network-interface-info

#+BEGIN_SRC elisp
(network-interface-info "en0")
#+END_SRC

#+RESULTS:
: ([192 168 0 102 0]
:  [192 168 0 255 0]
:  [255 255 255 0 0]
:  (18 .
:      [72 215 5 181 112 87])
:  (simplex multicast notrailers running broadcast up))

* network-interface-list
:PROPERTIES:
:changes:  27.1 Return IPv4 and IPv6 addresses.
:END:

#+BEGIN_SRC elisp
(network-interface-list)
#+END_SRC

#+RESULTS:
: (("en0" .
:   [192 168 0 102 0])
:  ("lo0" .
:   [127 0 0 1 0]))

* network-lookup-address-info
:PROPERTIES:
:added:    27.1
:END:

#+BEGIN_SRC elisp
(network-lookup-address-info "example.com")
#+END_SRC

#+RESULTS:
: ([93 184 216 34 0])

* next-frame

#+BEGIN_SRC elisp
(next-frame)
#+END_SRC

#+RESULTS:
: #<frame /Users/xcy/src/elisp-demos/elisp-demos.org 0x1049a21e8>

* next-overlay-change

#+BEGIN_SRC elisp
(with-temp-buffer
  (insert "hello")
  (make-overlay 4 5)
  (make-overlay 2 3)
  (next-overlay-change 1))
#+END_SRC

#+RESULTS:
: 2

* next-property-change

#+BEGIN_SRC elisp
(next-property-change 0 "hello")
#+END_SRC

#+RESULTS:
: nil

#+BEGIN_SRC elisp
(next-property-change 0 (concat "hello" (propertize "world" 'world t)))
#+END_SRC

#+RESULTS:
: 5

* ngettext
:PROPERTIES:
:added:    27.1
:END:

#+BEGIN_SRC elisp
(ngettext "mouse" "mice" 3)
#+END_SRC

#+RESULTS:
: "mice"

* nlistp

#+BEGIN_SRC elisp
(nlistp [])
#+END_SRC

#+RESULTS:
: t

* not

#+BEGIN_SRC elisp
(list (not (> 1 2))
      (not (< 1 2)))
#+END_SRC

#+RESULTS:
: (t nil)

* nreverse

#+BEGIN_SRC elisp
(let ((x (list 1 2 3 4)))
  (setq x (nreverse x))
  x)
#+END_SRC

#+RESULTS:
: (4 3 2 1)

* ntake
:PROPERTIES:
:added:    29.1
:END:

#+BEGIN_SRC elisp
(let ((l (list 1 2 3 4)))
  (ntake 2 l)
  l)
#+END_SRC

#+RESULTS:
: (1 2)

* nth

#+BEGIN_SRC elisp
(nth 2 '(1 2 3 4))
#+END_SRC

#+RESULTS:
: 3

* nthcdr

#+BEGIN_SRC elisp
(nthcdr 2 '(1 2 3 4))
#+END_SRC

#+RESULTS:
: (3 4)

* null

#+BEGIN_SRC elisp
(null '(1 2 3))
#+END_SRC

#+RESULTS:
: nil

#+BEGIN_SRC elisp
(null '())
#+END_SRC

#+RESULTS:
: t

* num-processors
:PROPERTIES:
:added:    28.1
:END:

#+BEGIN_SRC elisp
(num-processors)
#+END_SRC

#+RESULTS:
: 8

* number-sequence

#+BEGIN_SRC elisp
(number-sequence 1 10)
#+END_SRC

#+RESULTS:
: (1 2 3 4 5 6 7 8 9 10)

#+BEGIN_SRC elisp
(number-sequence 1 10 2)
#+END_SRC

#+RESULTS:
: (1 3 5 7 9)

#+BEGIN_SRC elisp
(number-sequence 10 1 -1)
#+END_SRC

#+RESULTS:
: (10 9 8 7 6 5 4 3 2 1)

* number-to-string

#+BEGIN_SRC elisp
(prin1-to-string 256)
#+END_SRC

#+RESULTS:
: "256"

* numberp

#+BEGIN_SRC elisp
(numberp 42)
#+END_SRC

#+RESULTS:
: t

* obarray-get

#+BEGIN_SRC elisp
(let ((ob (obarray-make)))
  (obarray-put ob "foo")
  (obarray-get ob "foo"))
#+END_SRC

#+RESULTS:
: foo

* obarray-make

#+BEGIN_SRC elisp
(obarray-make 5)
#+END_SRC

#+RESULTS:
: [0 0 0 0 0]

* obarray-map

#+BEGIN_SRC elisp
(let ((ob (obarray-make)))
  (obarray-put ob "x")
  (obarray-put ob "y")
  (obarray-put ob "z")
  (let (syms)
    (obarray-map
     (lambda (sym)
       (push sym syms))
     ob)
    syms))
#+END_SRC

#+RESULTS:
: (x y z)

* obarray-put

#+BEGIN_SRC elisp
(let ((ob (obarray-make)))
  (obarray-put ob "foo"))
#+END_SRC

#+RESULTS:
: foo

* obarray-remove

#+BEGIN_SRC elisp
(let ((ob (obarray-make)))
  (obarray-put    ob "foo")
  (obarray-remove ob "foo")
  (obarray-get    ob "foo"))
#+END_SRC

#+RESULTS:
: nil

* obarray-size

#+BEGIN_SRC elisp
(obarray-size (obarray-make 5))
#+END_SRC

#+RESULTS:
: 5

* obarrayp

#+BEGIN_SRC elisp
(obarrayp (obarray-make 5))
#+END_SRC

#+RESULTS:
: t

* object-intervals
:PROPERTIES:
:added:    28.1
:END:

#+BEGIN_SRC elisp
(object-intervals (propertize "Hello" 'face 'italic 'foobar 42))
#+END_SRC

#+RESULTS:
: ((0 5
:     (face italic foo 42)))

* open-gnutls-stream

#+BEGIN_SRC elisp
(with-current-buffer (generate-new-buffer "*tls-buffer*")
  (open-gnutls-stream "tls"
                      (current-buffer)
                      "example.com"
                      "https")
  (process-send-string
   nil
   "GET / HTTP/1.1\r\nHost: example.com\r\nConnection: Close\r\n\r\n")
  (display-buffer (current-buffer)))
#+END_SRC

#+RESULTS:
: #<window 59 on *https://example.com*<8>>

* open-network-stream

#+BEGIN_SRC elisp :results silent
;; curl -I example.com
(let* ((buffer (get-buffer-create "*test*"))
       (process (open-network-stream "example" buffer
                                     "example.com" 80
                                     :type 'plain)))
  (process-send-string process (concat "HEAD / HTTP/1.1\n"
                                       "Host: example.com\n"
                                       "\n"))
  (accept-process-output process)
  (with-current-buffer buffer
    (substring-no-properties (buffer-string))))
#+END_SRC

* or

#+BEGIN_SRC elisp
(or nil nil 1 2)
#+END_SRC

#+RESULTS:
: 1

* oref

#+BEGIN_SRC elisp
(defclass my-rabbit ()
  ((color :initform "white"))
  "A rabbit class.")

(oref (my-rabbit) color)
#+END_SRC

#+RESULTS:
: "white"

* oref-default

#+BEGIN_SRC elisp
(defclass my-car ()
  ((wheels :type integer
           :initform 4
           :allocation :class)))

(oref-default my-car wheels)
#+END_SRC

#+RESULTS:
: 4

* org-babel-edit-distance

#+BEGIN_SRC elisp
(org-babel-edit-distance "kitten" "sitting")
#+END_SRC

#+RESULTS:
: 3

* org-element-map

#+BEGIN_SRC elisp
(with-temp-buffer
  (insert "* TODO Hack org-mode   :org: \n"
          "* TODO Hack emacs      :emacs: \n"
          "* TODO Cut hair        :life: \n")
  (org-element-map (org-element-parse-buffer) 'headline
    (lambda (hl)
      (org-element-property :tags hl))))
#+END_SRC

#+RESULTS:
: (("org")
:  ("emacs")
:  ("life"))

* org-element-property

#+BEGIN_SRC elisp
(with-temp-buffer
  (insert "* TODO Hack org-mode :org:")
  (delay-mode-hooks (org-mode))
  (org-element-property :title (org-element-at-point)))
#+END_SRC

#+RESULTS:
: "Hack org-mode"

* org-entry-get

#+BEGIN_SRC elisp
(with-temp-buffer
  (insert "* TODO Hack org-mode")
  (delay-mode-hooks (org-mode))
  (org-entry-get (point-min) "ITEM"))
#+END_SRC

#+RESULTS:
: "Hack org-mode"

* org-entry-properties

#+BEGIN_SRC elisp
(with-temp-buffer
  (insert "* TODO Hack org-mode")
  (delay-mode-hooks (org-mode))
  (org-entry-properties (point-min)))
#+END_SRC

#+RESULTS:
: (("CATEGORY" . "???")
:  ("BLOCKED" . "")
:  ("FILE")
:  ("PRIORITY" . "B")
:  ("TODO" . "TODO")
:  ("ITEM" . "Hack org-mode"))

* org-export-number-to-roman

#+BEGIN_SRC elisp
(org-export-number-to-roman 3456)
#+END_SRC

#+RESULTS:
: "MMMCDLVI"

* org-heading-components

#+BEGIN_SRC elisp
(with-temp-buffer
  (insert "* TODO Hack org-mode")
  (delay-mode-hooks (org-mode))
  (org-heading-components))
#+END_SRC

#+RESULTS:
: (1 1 "TODO" nil "Hack org-mode" nil)

* org-map-entries

#+BEGIN_SRC elisp
(with-temp-buffer
  (insert "* DONE Shave\n"
          "* TODO Shower\n"
          "* DONE Breakfast\n"
          "* TODO Sleep\n")
  (delay-mode-hooks (org-mode))
  (let (todos)
    (org-map-entries
     (lambda ()
       (push (org-entry-get (point) "ITEM") todos))
     "/+TODO")
    (nreverse todos)))
#+END_SRC

#+RESULTS:
: ("Shower" "Sleep")

* oset

#+BEGIN_SRC elisp
(defclass my-fish ()
  ((size))
  "A fish class.")

(let ((obj (my-fish)))
  (oset obj size 10 )
  obj)
#+END_SRC

#+RESULTS:
: #s(my-fish 10)

* oset-default

#+BEGIN_SRC elisp
(defclass my-car ()
  ((wheels :type integer
           :initform 4
           :allocation :class)))

(let ((car1 (my-car))
      (car2 (my-car)))
  (oset-default my-car wheels 2)
  (list (oref car1 wheels)
        (oref car2 wheels)))
#+END_SRC

#+RESULTS:
: (2 2)

* other-buffer

#+BEGIN_SRC elisp
(other-buffer)
#+END_SRC

#+RESULTS:
: #<buffer init.el>

* overlay-buffer

#+BEGIN_SRC elisp
(with-temp-buffer
  (let ((ov (make-overlay 1 1)))
    (format "%s" (overlay-buffer ov))))
#+END_SRC

#+RESULTS:
: " *temp*"

* overlay-end

#+BEGIN_SRC elisp
(with-temp-buffer
  (insert "hello")
  (let ((ov (make-overlay 1 6)))
    (overlay-end ov)))
#+END_SRC

#+RESULTS:
: 6

* overlay-get

#+BEGIN_SRC elisp
(with-temp-buffer
  (let ((ov (make-overlay 1 1)))
    (overlay-put ov 'happy t)
    (overlay-get ov 'happy)))
#+END_SRC

#+RESULTS:
: t

* overlay-lists
:PROPERTIES:
:changes:  29.1 The function returns one unified list of overlays.
:END:

#+BEGIN_SRC elisp
(overlay-lists)
#+END_SRC

#+RESULTS:
: (nil)

* overlay-properties

#+BEGIN_SRC elisp
(with-temp-buffer
  (let ((ov (make-overlay 1 1)))
    (overlay-put ov 'happy t)
    (overlay-put ov 'hungry t)
    (overlay-properties ov)))
#+END_SRC

#+RESULTS:
: (hungry t happy t)

* overlay-put

#+BEGIN_SRC elisp
(with-temp-buffer
  (insert "hello")
  (let ((ov (make-overlay (point-min) (point-max))))
    (overlay-put ov 'face 'bold)))
#+END_SRC

#+RESULTS:
: bold

* overlay-recenter
:PROPERTIES:
:changes:  29.1 The function 'overlay-recenter' is now a no-op.
:END:

#+BEGIN_SRC elisp
(overlay-recenter (point-max))
#+END_SRC

#+RESULTS:
: nil

* overlay-start

#+BEGIN_SRC elisp
(with-temp-buffer
  (let ((ov (make-overlay 1 1)))
    (overlay-start ov)))
#+END_SRC

#+RESULTS:
: 1

* overlayp

#+BEGIN_SRC elisp
(with-temp-buffer (overlayp (make-overlay 1 1)))
#+END_SRC

#+RESULTS:
: t

* overlays-at

#+BEGIN_SRC elisp
(with-temp-buffer
  (insert "hello")
  (make-overlay 1 2)
  (make-overlay 1 5)
  (format "%S" (overlays-at 1)))
#+END_SRC

#+RESULTS:
: "(#<overlay from 1 to 5 in  *temp*> #<overlay from 1 to 2 in  *temp*>)"

* overlays-in

#+BEGIN_SRC elisp
(with-temp-buffer
  (insert "hello")
  ;;       12345
  (make-overlay 1 2)
  (make-overlay 2 4)
  (make-overlay 3 5)
  (format "%S" (overlays-in 3 4)))
#+END_SRC

#+RESULTS:
: "(#<overlay from 3 to 5 in  *temp*> #<overlay from 2 to 4 in  *temp*>)"

* package-get-version
:PROPERTIES:
:added:    27.1
:END:

#+BEGIN_SRC elisp
(with-current-buffer (find-file-noselect (locate-library "magit.el"))
  (package-get-version))
#+END_SRC

#+RESULTS:
: "20200828.1757"

* parse-colon-path

#+BEGIN_SRC elisp
(parse-colon-path "/usr/bin:/bin:/usr/sbin:/sbin")
#+END_SRC

#+RESULTS:
: ("/usr/bin/" "/bin/" "/usr/sbin/" "/sbin/")

* parse-iso8601-time-string
:PROPERTIES:
:added:    25.1
:END:

#+BEGIN_SRC elisp
(parse-iso8601-time-string "2020-03-25T01:53:53+08:00")
#+END_SRC

#+RESULTS:
: (24186 18737)

* parse-time-string

#+BEGIN_SRC elisp
;; RFC 2822
(parse-time-string "2018-11-15")
#+END_SRC

#+RESULTS:
: (nil nil nil 15 11 2018 nil nil nil)

* pcase
:PROPERTIES:
:added:    24.1
:changes:  25.1 New UPatterns 'quote', 'app', 'cl-struct', 'eieio', 'seq', 'map'.
:changes+: 25.1 New vector QPattern.
:changes+: 26.1 The rx pattern is added.
:changes+: 28.1 The 'pred' pattern can now take the form '(pred (not FUN))'.
:changes+: 28.1 Added 'cl-type' pattern.
:END:

#+BEGIN_SRC elisp :results silent
(pcase (read)
  ;; 42
  (42
   (message "forty-two"))
  ;; other numbers
  ((and (pred numberp) n)
   (message "Number: %d" n))
  ;; string
  ((and (pred stringp) s)
   (message "String: %S" s))
  ;; 'hello (symbol)
  ('hello
   (message "World"))
  ;; default
  (x (message "=> %S" x)))
#+END_SRC

#+begin_src elisp :results silent
;; pred
(pcase (random 3)
  ((pred zerop)           "zero")
  ((pred (lambda (n) (= n 1))) "one")
  ((pred (= 2))           "two"))
#+end_src

#+begin_src elisp :results silent
;; app
(pcase (random 3)
  ((app identity 0) "zero")
  ((app (lambda (n) n) 1) "one")
  ((app (identity) 2) "two"))
#+end_src

#+begin_src elisp :results silent
;; let
(pcase (read-number "Number: ")
  ((and 42 (let msg "forty-two"))
   msg))
#+end_src

#+begin_src elisp
;; rx
(pcase (format-time-string "%Y-%m-%d")
  ;; 2020-03-07
  ((rx (let y (= 4 num)) "-"
       (let m (= 2 num)) "-"
       (let d (= 2 num)))
   (list :year y
         :month m
         :day d)))
#+end_src

#+RESULTS:
: (:year "2020" :month "03" :day "07")

* pcase-defmacro
:PROPERTIES:
:added:    25.1
:END:

#+BEGIN_SRC elisp
(pcase-defmacro my-alist (&rest patterns)
  (cl-loop for pat in patterns
           collect `(app (alist-get ',pat) ,pat) into aux
           finally return `(and ,@aux)))

(pcase '((a . 1) (b . 2) (c . 3) (d . 4))
  ((my-alist a b c d) (list a b c d)))
#+END_SRC

#+RESULTS:
: (1 2 3 4)

* pcase-dolist
:PROPERTIES:
:added:    24.1
:END:

#+BEGIN_SRC elisp
(let (res)
  (pcase-dolist (`(,key . ,val) '((one . 1)
                                  (two . 2)
                                  (three . 3)
                                  (four . 4)))
    (push (cons val key) res))
  (nreverse res))
#+END_SRC

#+RESULTS:
: ((1 . one)
:  (2 . two)
:  (3 . three)
:  (4 . four))

* pcase-exhaustive
:PROPERTIES:
:added:    25.1
:END:

#+BEGIN_SRC elisp
(condition-case nil
    (pcase-exhaustive 'bar
      ('foo 123))
  (error
   "Got no match error"))
#+END_SRC

#+RESULTS:
: "Got no match error"

* pcase-lambda
:PROPERTIES:
:added:    25.1
:END:

#+BEGIN_SRC elisp
(funcall
 (pcase-lambda (`(,car . ,cdr))
   (append cdr (list car)))
 '(1 2 3 4))
#+END_SRC

#+RESULTS:
: (2 3 4 1)

* pcase-let
:PROPERTIES:
:added:    24.1
:END:

#+BEGIN_SRC elisp
(pcase-let ((`(,_ ,_ ,uid ,gid)
             (file-attributes user-init-file)))
  (list uid gid))
#+END_SRC

#+RESULTS:
: (501 20)

* pcase-let*
:PROPERTIES:
:added:    24.1
:END:

#+BEGIN_SRC elisp
(pcase-let* ((`[,x ,y] [1 2])
             (`(,a ,b) (list y x)))
  (list a b))
#+END_SRC

#+RESULTS:
: (2 1)

* pcase-setq
:PROPERTIES:
:added:    28.1
:END:

#+BEGIN_SRC elisp
(let (a b)
  (pcase-setq `((,a) [(,b)]) '((1) [(2)]))
  (list a b))
#+END_SRC

#+RESULTS:
: (1 2)

* plist-get
:PROPERTIES:
:changes:  29.1 The optional PREDICATE argument is added.
:END:

#+BEGIN_SRC elisp
(plist-get '(:a 1 :b 2 :c 3) :b)
#+END_SRC

#+RESULTS:
: 2

* plist-member
:PROPERTIES:
:changes:  29.1 The optional PREDICATE argument is added.
:END:

#+BEGIN_SRC elisp
(plist-member '(:x nil) :x)
#+END_SRC

#+RESULTS:
: (:x nil)

#+BEGIN_SRC elisp
(plist-member '(:x nil) :y)
#+END_SRC

#+RESULTS:
: nil

* plist-put
:PROPERTIES:
:changes:  29.1 The optional PREDICATE argument is added.
:END:

#+BEGIN_SRC elisp
(let ((plist (list :a 1 :b 2)))
  (setq plist (plist-put plist :b 200)))
#+END_SRC

#+RESULTS:
: (:a 1 :b 200)

* point

#+BEGIN_SRC elisp
(point)
#+END_SRC

#+RESULTS:
: 7899

* point-max

#+BEGIN_SRC elisp
(point-max)
#+END_SRC

#+RESULTS:
: 14180

* point-min

#+BEGIN_SRC elisp
(point-min)
#+END_SRC

#+RESULTS:
: 1

* pop

#+BEGIN_SRC elisp
(let ((l '(1 2 3)))
  (pop l)
  l)
#+END_SRC

#+RESULTS:
: (2 3)

* popup-cascade-menu

#+BEGIN_SRC elisp
(popup-cascade-menu '(("Foo" "Baz") "Bar"))
#+END_SRC

#+RESULTS:
: "Baz"

* popup-make-item

#+BEGIN_SRC elisp
(popup-menu* (list (popup-make-item "Yes" :value t)
                   (popup-make-item "No" :value nil)))
#+END_SRC

#+RESULTS:
: t

* popup-menu*

#+BEGIN_SRC elisp
(popup-menu* '("Foo" "Bar" "Baz"))
#+END_SRC

#+RESULTS:
: "Foo"

* popup-tip

#+BEGIN_SRC elisp
(popup-tip "This is a tooltip.")
#+END_SRC

#+RESULTS:
: t

* pos-bol
:PROPERTIES:
:added:    29.1
:END:

#+BEGIN_SRC elisp
(pos-bol)
#+END_SRC

#+RESULTS:
: 182190

* pos-eol
:PROPERTIES:
:added:    29.1
:END:

#+BEGIN_SRC elisp
(pos-eol)
#+END_SRC

#+RESULTS:
: 182305

* pos-tip-show

#+BEGIN_SRC elisp
(pos-tip-show "Hello World!")
#+END_SRC

#+RESULTS:
: (8 . 425)

* pos-tip-show-no-propertize

#+BEGIN_SRC elisp
(pos-tip-show-no-propertize "Hello World!")
#+END_SRC

#+RESULTS:
: (8 . 578)

* position-bytes

#+BEGIN_SRC elisp
(with-temp-buffer
  ;; multibyte char is enabled by default, to turn off, use
  ;; (set-buffer-multibyte nil)
  (insert "Î»")
  (list (point) (position-bytes (point))))
#+END_SRC

#+RESULTS:
: (2 3)

* pp

#+BEGIN_SRC elisp :results output
(pp (lambda (a y) (+ x y)))
#+END_SRC

#+RESULTS:
: "(lambda\n  (a y)\n  (+ x y))\n"

* pp-emacs-lisp-code

#+BEGIN_SRC elisp
(with-temp-buffer
  (pp-emacs-lisp-code '(lambda (a b) (+ a b)))
  (buffer-string))
#+END_SRC

#+RESULTS:
: "(lambda (a b)\n  (+ a b))\n"

* previous-frame

#+BEGIN_SRC elisp
(previous-frame)
#+END_SRC

#+RESULTS:
: #<frame /Users/xcy/src/elisp-demos/elisp-demos.org 0x1049a21e8>

* previous-overlay-change

#+BEGIN_SRC elisp
(with-temp-buffer
  (insert "hello")
  (make-overlay 4 5)
  (make-overlay 2 3)
  (previous-overlay-change 6))
#+END_SRC

#+RESULTS:
: 5

* prin1
:PROPERTIES:
:changes:  29.1 'prin1' doesn't always escape "." and "?" in symbols any more.
:changes:  29.1 The optional OVERRIDES argument is added.
:END:

#+BEGIN_SRC elisp :results output
(prin1 "hello")
#+END_SRC

#+RESULTS:
: "\"hello\""

* prin1-char

#+BEGIN_SRC elisp
(prin1-char 97)
#+END_SRC

#+RESULTS:
: "?a"

* prin1-to-string
:PROPERTIES:
:changes:  29.1 The optional OVERRIDES argument is added.
:END:

#+BEGIN_SRC elisp
(list (prin1-to-string 'symbol)
      (prin1-to-string "string")
      (prin1-to-string 42))
#+END_SRC

#+RESULTS:
: ("symbol" "\"string\"" "42")

* princ

#+BEGIN_SRC elisp :results output
(princ "hello")
#+END_SRC

#+RESULTS:
: "hello"

* print

#+BEGIN_SRC elisp :results output
(print "hello")
#+END_SRC

#+RESULTS:
: "\n\"hello\"\n"

* process-attributes

#+BEGIN_SRC elisp
(process-attributes 1)
#+END_SRC

#+RESULTS:
#+BEGIN_EXAMPLE
((etime 8 3971 635846 0)
 (start 23808 53217 185321 0)
 (nice . 0)
 (tpgid . 0)
 (pgrp . 1)
 (ppid . 0)
 (state . "R")
 (comm . "launchd")
 (group . "wheel")
 (egid . 0)
 (user . "root")
 (euid . 0))
#+END_EXAMPLE

* process-buffer

#+BEGIN_SRC elisp
;; Start the shell process if not already
(shell)

(process-buffer (get-process "shell"))
#+END_SRC

#+RESULTS:
: #<buffer *shell*>

* process-coding-system

#+BEGIN_SRC elisp
;; Start the shell process if not already
(shell)

(process-coding-system (get-process "shell"))
#+END_SRC

#+RESULTS:
: (utf-8-unix . utf-8-unix)

* process-command

#+BEGIN_SRC elisp
;; Start the shell process if not already
(shell)

(process-command (get-process "shell"))
#+END_SRC

#+RESULTS:
: ("/bin/zsh" "-i")

* process-contact

#+BEGIN_SRC elisp
;; Start the shell process if not already
(shell)

(process-contact (get-process "shell"))
#+END_SRC

#+RESULTS:
: t

* process-exit-status

#+BEGIN_SRC elisp
;; Start the shell process if not already
(shell)

(process-exit-status (get-process "shell"))
#+END_SRC

#+RESULTS:
: 0

* process-get

#+BEGIN_SRC elisp
;; Start the shell process if not already
(shell)

(process-put (get-process "shell") 'bar 456)
(process-get (get-process "shell") 'bar)
#+END_SRC

#+RESULTS:
: 456

* process-id

#+BEGIN_SRC elisp
;; Start the shell process if not already
(shell)

(process-id (get-process "shell"))
#+END_SRC

#+RESULTS:
: 44050

* process-lines
:PROPERTIES:
:added:    24.4
:END:

#+BEGIN_SRC elisp
(process-lines "seq" "3")
#+END_SRC

#+RESULTS:
: ("1" "2" "3")

* process-lines-ignore-status
:PROPERTIES:
:added:    28.1
:END:

#+BEGIN_SRC elisp
(process-lines-ignore-status "grep")
#+END_SRC

#+RESULTS:
: ("usage: grep [-abcdDEFGHhIiJLlMmnOopqRSsUVvwXxZz] [-A num] [-B num] [-C[num]]" "	[-e pattern] [-f file] [--binary-files=value] [--color=when]" "	[--context[=num]] [--directories=action] [--label] [--line-buffered]" "	[--null] [pattern] [file ...]")

* process-list

#+BEGIN_SRC elisp
(process-list)
#+END_SRC

#+RESULTS:
: (#<process shell> #<process atomic-chrome-httpd> #<process websocket server on port 64292> #<process server>)

* process-live-p

#+BEGIN_SRC elisp
;; Start the shell process if not already
(shell)

(process-live-p (get-process "shell"))
#+END_SRC

#+RESULTS:
: (run open listen connect stop)

* process-mark

#+BEGIN_SRC elisp
;; Start the shell process if not already
(shell)

(process-mark (get-process "shell"))
#+END_SRC

#+RESULTS:
: #<marker at 21 in *shell*>

* process-name

#+BEGIN_SRC elisp
;; Start the shell process if not already
(shell)

(process-name (get-buffer-process "*shell*"))
#+END_SRC

#+RESULTS:
: "shell"

* process-plist

#+BEGIN_SRC elisp
;; Start the shell process if not already
(shell)

(process-put (get-process "shell") 'foo 123)
(process-put (get-process "shell") 'bar 456)

(process-plist (get-process "shell"))
#+END_SRC

#+RESULTS:
: (foo 123 bar 456)

* process-put

#+BEGIN_SRC elisp
;; Start the shell process if not already
(shell)

(process-put (get-process "shell") 'foo 123)
(process-get (get-process "shell") 'foo)
#+END_SRC

#+RESULTS:
: 123

* process-query-on-exit-flag

#+BEGIN_SRC elisp
;; Start the shell process if not already
(shell)

(process-query-on-exit-flag (get-process "shell"))
#+END_SRC

#+RESULTS:
: t

* process-running-child-p

#+BEGIN_SRC elisp
;; Start the shell process if not already
(shell)

(process-running-child-p (get-process "shell"))
#+END_SRC

#+RESULTS:
: nil

#+BEGIN_SRC elisp
;; Start the shell process if not already
(shell)

(process-send-string (get-process "shell") "bash\n")
;; wait for bash
(sit-for 1)

(process-running-child-p (get-process "shell"))
#+END_SRC

#+RESULTS:
: 44214

* process-send-eof

#+BEGIN_SRC elisp
;; Start the shell process if not already
(shell)

(process-send-eof (get-process "shell"))
#+END_SRC

#+RESULTS:
: #<process shell>

* process-send-region

#+BEGIN_SRC elisp
;; Start the shell process if not already
(shell)

(with-temp-buffer
  (insert "date\n")
  (process-send-region (get-process "shell") (point-min) (point-max)))
#+END_SRC

#+RESULTS:
: nil

* process-send-string

#+BEGIN_SRC elisp
;; Start the shell process if not already
(shell)

(process-send-string (get-process "shell") "date\n")
#+END_SRC

#+RESULTS:
: nil

* process-status

#+BEGIN_SRC elisp
;; Start the shell process if not already
(shell)

(process-status "shell")
#+END_SRC

#+RESULTS:
: run

* process-tty-name

#+BEGIN_SRC elisp
;; Start the shell process if not already
(shell)

(process-tty-name (get-process "shell"))
#+END_SRC

#+RESULTS:
: "/dev/ttys001"

* process-type

#+BEGIN_SRC elisp
;; Start the shell process if not already
(shell)

(process-type (get-process "shell"))
#+END_SRC

#+RESULTS:
: real

* prog1

#+BEGIN_SRC elisp
(prog1 1 2 3)
#+END_SRC

#+RESULTS:
: 1

* prog2

#+BEGIN_SRC elisp
(prog2 1 2 3)
#+END_SRC

#+RESULTS:
: 2

* progn

#+BEGIN_SRC elisp
(progn 1 2 3)
#+END_SRC

#+RESULTS:
: 3

* proper-list-p
:PROPERTIES:
:added:    27.1
:END:

#+BEGIN_SRC elisp
(proper-list-p '(1 2 3))
#+END_SRC

#+RESULTS:
: 3

#+BEGIN_SRC elisp
(proper-list-p '(1 2 . 3))
#+END_SRC

#+RESULTS:
: nil

* propertize

#+BEGIN_SRC elisp
(propertize "Hello" 'face 'italic)
#+END_SRC

#+RESULTS:
: #("Hello" 0 5
:   (face italic))

* provided-mode-derived-p
:PROPERTIES:
:added:    26.1
:END:

#+BEGIN_SRC elisp
(provided-mode-derived-p 'lisp-interaction-mode 'prog-mode)
#+END_SRC

#+RESULTS:
: prog-mode

* pulse-momentary-highlight-one-line

#+BEGIN_SRC elisp :results silent
(pulse-momentary-highlight-one-line (point))
#+END_SRC

* pulse-momentary-highlight-region

#+BEGIN_SRC elisp :results silent
(pulse-momentary-highlight-region (line-beginning-position) (line-end-position))
#+END_SRC

* puny-decode-domain
:PROPERTIES:
:added:    26.1
:END:

#+BEGIN_SRC elisp
(puny-decode-domain "xn--bcher-kva.tld")
#+END_SRC

#+RESULTS:
: "bÃ¼cher.tld"

* puny-decode-string
:PROPERTIES:
:added:    26.1
:END:

#+BEGIN_SRC elisp
(puny-decode-string "xn--bcher-kva")
#+END_SRC

#+RESULTS:
: "bÃ¼cher"

* puny-encode-domain
:PROPERTIES:
:added:    26.1
:END:

#+BEGIN_SRC elisp
(puny-encode-domain "bÃ¼cher.tld")
#+END_SRC

* puny-encode-string
:PROPERTIES:
:added:    26.1
:END:

#+BEGIN_SRC elisp
(puny-encode-string "bÃ¼cher")
#+END_SRC

#+RESULTS:
: "xn--bcher-kva"

* push

#+BEGIN_SRC elisp
(let ((l '(1 2)))
  (push 3 l)
  l)
#+END_SRC

#+RESULTS:
: (3 1 2)

* put

#+BEGIN_SRC elisp
(put 'fly 'verb 'transitive)
#+END_SRC

#+RESULTS:
: transitive

* put-text-property

#+BEGIN_SRC elisp
(with-temp-buffer
  (insert "x1")
  (put-text-property 2 3 'display '(raise 0.5))
  (message "%s" (buffer-string))
  (sit-for 3))
#+END_SRC

#+RESULTS:
: t

* puthash

#+BEGIN_SRC elisp
(let ((table (make-hash-table)))
  (puthash 'x 1 table)
  (puthash 'y 2 table)
  table)
#+END_SRC

#+RESULTS:
: #s(hash-table size 65 test eql rehash-size 1.5 rehash-threshold 0.8125 data
: (x 1 y 2))

* queue-all

#+BEGIN_SRC elisp
(let ((q (queue-create)))
  (queue-enqueue q 1)
  (queue-enqueue q 2)
  (queue-enqueue q 3)
  (queue-prepend q 0)
  (queue-all q))
#+END_SRC

#+RESULTS:
: (0 1 2 3)

* queue-clear

#+BEGIN_SRC elisp
(let ((q (queue-create)))
  (queue-enqueue q 1)
  (queue-enqueue q 2)
  (queue-enqueue q 3)
  (queue-clear q)
  q)
#+END_SRC

#+RESULTS:
: #s(queue nil nil)

* queue-create

#+BEGIN_SRC elisp
;; FIFO (first in, first out)
(let ((q (queue-create)))
  (queue-enqueue q 1)
  (queue-enqueue q 2)
  (queue-enqueue q 3)
  (list (queue-dequeue q)
        (queue-dequeue q)
        (queue-dequeue q)))
#+END_SRC

#+RESULTS:
: (1 2 3)

#+BEGIN_SRC elisp
;; FILO (first in, last out)
(let ((q (queue-create)))
  (queue-prepend q 1)
  (queue-prepend q 2)
  (queue-prepend q 3)
  (list (queue-dequeue q)
        (queue-dequeue q)
        (queue-dequeue q)))
#+END_SRC

#+RESULTS:
: (3 2 1)

* queue-first

#+BEGIN_SRC elisp
(let ((q (queue-create)))
  (queue-enqueue q 1)
  (queue-enqueue q 2)
  (queue-enqueue q 3)
  (queue-first q))
#+END_SRC

#+RESULTS:
: 1

* queue-last

#+BEGIN_SRC elisp
(let ((q (queue-create)))
  (queue-enqueue q 1)
  (queue-enqueue q 2)
  (queue-enqueue q 3)
  (queue-last q))
#+END_SRC

#+RESULTS:
: 3

* queue-length

#+BEGIN_SRC elisp
(let ((q (queue-create)))
  (queue-enqueue q 1)
  (queue-enqueue q 2)
  (queue-enqueue q 3)
  (queue-prepend q 0)
  (queue-length q))
#+END_SRC

#+RESULTS:
: 4

* quote

#+BEGIN_SRC elisp
(quote (+ 1 2))
#+END_SRC

#+RESULTS:
: (+ 1 2)

#+BEGIN_SRC elisp
;; (quote (quote foo))
''foo
#+END_SRC

#+RESULTS:
: 'foo

* radix-tree-count

#+BEGIN_SRC elisp
(let ((tree ()))
  (setq tree (radix-tree-insert tree "application" t))
  (setq tree (radix-tree-insert tree "appetizer" t))
  (setq tree (radix-tree-insert tree "applicative" t))
  (setq tree (radix-tree-insert tree "apple" t))
  (radix-tree-count tree))
#+END_SRC

#+RESULTS:
: 4

* radix-tree-from-map

#+BEGIN_SRC elisp
(radix-tree-from-map '(("application" . t)
                       ("appetizer" . t)
                       ("applicative" . t)
                       ("apple" . t)))
#+END_SRC

#+RESULTS:
: (("app"
:   ("l"
:    ("icati"
:     ("on" . t)
:     ("ve" . t))
:    ("e" . t))
:   ("etizer" . t)))

* radix-tree-insert
:PROPERTIES:
:added:    26.1
:END:

#+BEGIN_SRC elisp
(let ((tree ()))
  (setq tree (radix-tree-insert tree "application" t))
  (setq tree (radix-tree-insert tree "appetizer" t))
  (setq tree (radix-tree-insert tree "applicative" t))
  (setq tree (radix-tree-insert tree "apple" t))
  tree)
#+END_SRC

#+RESULTS:
: (("app"
:   ("l"
:    ("icati"
:     ("on" . t)
:     ("ve" . t))
:    ("e" . t))
:   ("etizer" . t)))

* radix-tree-iter-mappings

#+BEGIN_SRC elisp
(let (tree words)
  (setq tree (radix-tree-insert tree "application" t))
  (setq tree (radix-tree-insert tree "appetizer" t))
  (setq tree (radix-tree-insert tree "applicative" t))
  (setq tree (radix-tree-insert tree "apple" t))
  (radix-tree-iter-mappings
   (radix-tree-subtree tree "app")
   (lambda (k v) (push (concat "app" k) words)))
  words)
#+END_SRC

#+RESULTS:
: ("appetizer" "apple" "applicative" "application")

* radix-tree-iter-subtrees

#+BEGIN_SRC elisp
(let (tree words)
  (setq tree (radix-tree-insert tree "application" t))
  (setq tree (radix-tree-insert tree "appetizer" t))
  (setq tree (radix-tree-insert tree "applicative" t))
  (setq tree (radix-tree-insert tree "apple" t))
  (cl-labels ((mapping
               (tree prefix)
               (radix-tree-iter-subtrees
                tree
                (lambda (p s)
                  (let ((nprefix (concat prefix p)))
                    (pcase s
                      ((radix-tree-leaf _v) (push nprefix words))
                      (_ (mapping s nprefix))))))))
    (mapping tree ""))
  words)
#+END_SRC

#+RESULTS:
: ("appetizer" "apple" "applicative" "application")

* radix-tree-lookup

#+BEGIN_SRC elisp
(let ((tree ()))
  (setq tree (radix-tree-insert tree "application" 1))
  (setq tree (radix-tree-insert tree "appetizer"   2))
  (setq tree (radix-tree-insert tree "applicative" 3))
  (setq tree (radix-tree-insert tree "apple"       4))
  (radix-tree-lookup tree "apple"))
#+END_SRC

#+RESULTS:
: 4

* radix-tree-prefixes

#+BEGIN_SRC elisp
(let ((tree ()))
  (setq tree (radix-tree-insert tree "apply" t))
  (setq tree (radix-tree-insert tree "applies" t))
  (setq tree (radix-tree-insert tree "applied" t))
  (setq tree (radix-tree-insert tree "applying" t))
  (radix-tree-prefixes tree "applying"))
#+END_SRC

#+RESULTS:
: (("applying" . t)
:  ("apply" . t))

* radix-tree-subtree

#+BEGIN_SRC elisp
(let ((tree ()))
  (setq tree (radix-tree-insert tree "application" 1))
  (setq tree (radix-tree-insert tree "appetizer"   2))
  (setq tree (radix-tree-insert tree "applicative" 3))
  (setq tree (radix-tree-insert tree "apple"       4))
  (radix-tree-subtree tree "appl"))
#+END_SRC

#+RESULTS:
: (("icati"
:   ("on" . 1)
:   ("ve" . 3))
:  ("e" . 4))

* random

#+BEGIN_SRC elisp
;; [0, 3)
(random 3)
#+END_SRC

#+RESULTS:
: 1

* rassoc

#+BEGIN_SRC elisp
(rassoc '(2) '(("one" 1)
               ("two" 2)
               ("three" 3)))
#+END_SRC

#+RESULTS:
: ("two" 2)

* rassq

#+BEGIN_SRC elisp
(rassq 'tyke '((tom . jerry) (spike . tyke)))
#+END_SRC

#+RESULTS:
: (spike . tyke)

* rassq-delete-all

#+BEGIN_SRC elisp
(let ((alist (list (cons 1 2)
                   (cons 3 4)
                   (cons 5 6)
                   (cons 7 2))))
  (setq alist (rassq-delete-all 2 alist)))
#+END_SRC

#+RESULTS:
: ((3 . 4)
:  (5 . 6))

* re-search-forward

#+BEGIN_SRC elisp
(with-temp-buffer
  (insert "# Intro\n"
          "# Usage\n"
          "# License\n")
  (goto-char (point-min))
  (let ((matches '()))
    (while (re-search-forward "^# \\(.+\\)$" nil t)
      (push (match-string 1) matches))
    (nreverse matches)))
#+END_SRC

#+RESULTS:
: ("Intro" "Usage" "License")

* read

#+BEGIN_SRC elisp
(read "42")
#+END_SRC

#+RESULTS:
: 42

* read-char-choice
:PROPERTIES:
:added:    24.1
:END:

#+BEGIN_SRC elisp
(read-char-choice "Delete foo.txt? [Type y/n/q] " '(?y ?n ?q))
#+END_SRC

#+RESULTS:
: 121

* read-color

#+BEGIN_SRC elisp
(read-color)
#+END_SRC

#+RESULTS:
: "green"

* read-from-minibuffer

#+BEGIN_SRC elisp
(read-from-minibuffer "Enter your name: ")
#+END_SRC

#+RESULTS:
: "xuchunyang"

* read-from-string

#+BEGIN_SRC elisp
(read-from-string "(setq x \"hello\") (setq y 5)")
#+END_SRC

#+RESULTS:
: ((setq x "hello")
:  . 16)

* read-kbd-macro

#+BEGIN_SRC elisp
(read-kbd-macro "C-x C-f")
#+END_SRC

#+RESULTS:
: ""

#+BEGIN_SRC elisp
(read-kbd-macro "C-x C-f" 'need-vector)
#+END_SRC

#+RESULTS:
: [24 6]

* read-minibuffer

#+BEGIN_SRC elisp
(read-minibuffer "Enter an expression: " (format "%s" '(+ 1 2)))
#+END_SRC

#+RESULTS:
: (+ 1 2)

* read-multiple-choice
:PROPERTIES:
:added:    26.1
:changes:  29.1 The optional SHOW-HELP and LONG-FORM arguments are added.
:END:

#+BEGIN_SRC elisp
(read-multiple-choice "Continue connecting?"
                      '((?a "always")
                        (?s "session only")
                        (?n "no")))
#+END_SRC

#+RESULTS:
: (97 "always")

* read-no-blanks-input

#+BEGIN_SRC elisp
(read-no-blanks-input "Username (space and tab are not allowed): ")
#+END_SRC

#+RESULTS:
: "xuchunyang"

* read-passwd

#+BEGIN_SRC elisp
(read-passwd "Your password: ")
#+END_SRC

#+RESULTS:
: "123456"

* read-quoted-char

#+BEGIN_SRC elisp
(read-quoted-char "What character (octal)")
#+END_SRC

#+RESULTS:
: 120

#+BEGIN_SRC elisp
(let ((read-quoted-char-radix 16))
  ;; ðŸ˜ƒ #x1f603
  (string (read-quoted-char "What character (hexadecimal)")))
#+END_SRC

#+RESULTS:
: "ðŸ˜ƒ"

* read-regexp

#+BEGIN_SRC elisp
(read-regexp "Search for regexp: ")
#+END_SRC

#+RESULTS:
: "^\\* "

* read-string

#+BEGIN_SRC elisp
(read-string "Enter your name: ")
#+END_SRC

* readablep
:PROPERTIES:
:added:    29.1
:END:

#+BEGIN_SRC elisp
(readablep (current-buffer))
#+END_SRC

#+RESULTS:
: nil

* recent-keys
:PROPERTIES:
:changes:  25.1 The optional INCLUDE-CMDS argument is added.
:END:

#+BEGIN_SRC elisp
(length (recent-keys))
#+END_SRC

#+RESULTS:
: 158

* record
:PROPERTIES:
:added:    26.1
:END:

#+BEGIN_SRC elisp
(record 'foo 23 [bar baz] "rats")
#+END_SRC

#+RESULTS:
: #s(foo 23
:        [bar baz]
:        "rats")

* recordp
:PROPERTIES:
:added:    26.1
:END:

#+BEGIN_SRC elisp
(recordp #s(a))
#+END_SRC

#+RESULTS:
: t

* recursive-edit

#+BEGIN_SRC elisp
(defun stop-watch ()
  "Start a stop watch, type \\[exit-recursive-edit] to stop it."
  (interactive)
  (let ((t1 (current-time)))
    (message
     "%s"
     (substitute-command-keys
      "Type \\[exit-recursive-edit] to exit the stop watch"))
    (recursive-edit)
    (message
     "%f seconds passed"
     (float-time (time-subtract (current-time) t1)))))
#+END_SRC

#+RESULTS:
: stop-watch

* regexp-opt

#+BEGIN_SRC elisp
(regexp-opt '("foo" "bar" "baz"))
#+END_SRC

#+RESULTS:
: "\\(?:ba[rz]\\|foo\\)"

* regexp-opt-charset

#+BEGIN_SRC elisp
(regexp-opt-charset '(?a ?b ?c ?d ?e))
#+END_SRC

#+RESULTS:
: "[a-e]"

* regexp-opt-depth

#+BEGIN_SRC elisp
(regexp-opt-depth "\\(foo\\)\\(bar\\)\\(?:baz\\)")
#+END_SRC

#+RESULTS:
: 2

* regexp-quote

#+BEGIN_SRC elisp
(regexp-quote "^The cat$")
#+END_SRC

#+RESULTS:
: "\\^The cat\\$"

* region-bounds
:PROPERTIES:
:added:    26.1
:END:

#+BEGIN_SRC elisp
(with-temp-buffer
  (set-mark (point))
  (insert "hello")
  (region-bounds))
#+END_SRC

#+RESULTS:
: ((1 . 6))

#+BEGIN_SRC elisp
(with-temp-buffer
  (set-mark (point))
  (insert "AAA" ?\n
          "BBB" ?\n
          "CCC")
  (rectangle-mark-mode)
  (region-bounds))
#+END_SRC

#+RESULTS:
: ((1 . 4)
:  (5 . 8)
:  (9 . 12))

* region-noncontiguous-p
:PROPERTIES:
:added:    25.1
:END:

#+BEGIN_SRC elisp
(with-temp-buffer
  (set-mark (point))
  (insert "AAA" ?\n
          "BBB" ?\n
          "CCC")
  (rectangle-mark-mode)
  (region-noncontiguous-p))
#+END_SRC

#+RESULTS:
: t

* remhash

#+BEGIN_SRC elisp
(let ((table (make-hash-table)))
  (puthash 'x 1 table)
  (puthash 'y 2 table)
  (remhash 'x table)
  table)
#+END_SRC

#+RESULTS:
: #s(hash-table size 65 test eql rehash-size 1.5 rehash-threshold 0.8125 data
: ( y 2))

* remove

#+BEGIN_SRC elisp
(remove "a" '("a" "b" "c" "a"))
#+END_SRC

#+RESULTS:
: ("b" "c")

* remove-hook
:PROPERTIES:
:changes:  28.1 'remove-hook' is now an interactive command.
:END:

#+BEGIN_SRC elisp :eval no
(remove-hook 'lisp-interaction-mode-hook #'prettify-symbols-mode)
#+END_SRC

* remove-overlays

#+BEGIN_SRC elisp
(with-temp-buffer
  (let ((ov (make-overlay 1 1)))
    (overlay-put ov 'happy t)
    (remove-overlays 1 1 'happy t)
    (format "%S" ov)))
#+END_SRC

#+RESULTS:
: "#<overlay in no buffer>"

* remq

#+BEGIN_SRC elisp
(let ((l (list 1 2 3 2)))
  (remq 2 l))
#+END_SRC

#+RESULTS:
: (1 3)

* replace-buffer-contents
:PROPERTIES:
:added:    26.1
:changes:  27.1 The optional argument MAX-SECS and MAX-COSTS are added.
:END:

#+BEGIN_SRC elisp :results drawer
(with-temp-buffer
  (insert "a\nb\nc\n")
  (let ((sh-buf (generate-new-buffer " *temp*")))
    (call-process-region nil nil "nl" nil sh-buf)
    (replace-buffer-contents sh-buf)
    (kill-buffer sh-buf))
  (buffer-string))
#+END_SRC

#+RESULTS:
:RESULTS:
     1	a
     2	b
     3	c
:END:

* replace-match

#+BEGIN_SRC elisp
(with-temp-buffer
  (insert "65 83 68 70")
  (goto-char (point-min))
  (while (re-search-forward "[0-9]+" nil t)
    (replace-match
     ;; "65" => ?A => "A"
     (string (read (match-string 0)))
     'fixedcase
     'literal))
  (buffer-string))
#+END_SRC

#+RESULTS:
: "A S D F"

* replace-regexp-in-region
:PROPERTIES:
:added:    28.1
:END:

#+BEGIN_SRC elisp
(with-temp-buffer
  (insert "#1 #2 #3")
  (list
   (replace-regexp-in-region "[0-9]" "XX" (point-min))
   (buffer-string)))
#+END_SRC

#+RESULTS:
: (2 "#XX #XX #3")

* replace-regexp-in-string

#+BEGIN_SRC elisp
(replace-regexp-in-string "-" ", " "foo-bar-baz")
#+END_SRC

#+RESULTS:
: "foo, bar, baz"

#+BEGIN_SRC elisp
(replace-regexp-in-string
 "[0-9][0-9]\\'"
 (lambda (substring)
   (let ((suffixes
          ;; https://en.wikipedia.org/wiki/Ordinal_indicator
          (append '("st" "nd" "rd") (make-list 17 "th")
                  '("st" "nd" "rd") (make-list 7 "th")
                  '("st"))))
     (concat substring (elt suffixes (string-to-number substring)))))
 "2018 Nov 07")
#+END_SRC

#+RESULTS:
: "2018 Nov 07th"

* replace-region-contents
:PROPERTIES:
:added:    27.1
:END:

#+BEGIN_SRC elisp
(with-temp-buffer
  (insert "hello")
  (replace-region-contents (point-min) (point-max) (lambda () '"world"))
  (buffer-string))
#+END_SRC

#+RESULTS:
: "world"

* replace-string-in-region
:PROPERTIES:
:added:    28.1
:END:

#+BEGIN_SRC elisp
(with-temp-buffer
  (insert "ABBA")
  (replace-string-in-region "A" "a" (point-min))
  (buffer-string))
#+END_SRC

#+RESULTS:
: "aBBa"

* request

#+BEGIN_SRC elisp
(let (json)
  (request
   "https://api.github.com/status"
   :parser #'json-read
   :success (cl-function
             (lambda (&key data &allow-other-keys)
               (setq json data)))
   :sync t)
  json)
#+END_SRC

#+RESULTS:
: ((message . "GitHub lives! (2018-12-01 23:36:08 -0800) (1)"))

* require

#+BEGIN_SRC elisp
(require 'pcase)
#+END_SRC

#+RESULTS:
: pcase

* reverse

#+BEGIN_SRC elisp
(let* ((old '(1 2 3))
       (new (reverse x)))
  (list old new))
#+END_SRC

#+RESULTS:
: ((1 2 3)
:  (3 2 1))

* rfc1843-decode-string

#+BEGIN_SRC elisp
(with-temp-buffer
  (decode-coding-string
   (apply #'unibyte-string
          ;; FIXME: is `string-to-list' the best?
          (string-to-list
           (rfc1843-decode-string "~{<:Ky2;S{#,NpJ)l6HK!#~}")))
   'chinese-gbk))
#+END_SRC

#+RESULTS:
: #("å·±æ‰€ä¸æ¬²ï¼Œå‹¿æ–½æ–¼äººã€‚" 0 10
:   (charset chinese-gbk))

* rfc2104-hash

#+BEGIN_SRC elisp
(rfc2104-hash 'md5 64 16 "passwd" "Hi There")
#+END_SRC

#+RESULTS:
: "63c4c79cd364581232da80ca38adf486"

* ring-convert-sequence-to-ring

#+BEGIN_SRC elisp
(ring-convert-sequence-to-ring '(a b c))
#+END_SRC

#+RESULTS:
: (0 3 .
:    [c b a])

* ring-copy

#+BEGIN_SRC elisp
(ring-copy (make-ring 3))
#+END_SRC

#+RESULTS:
: (0 0 .
:    [nil nil nil])

* ring-elements

#+BEGIN_SRC elisp
(let ((ring (make-ring 10)))
  (ring-insert ring 1)
  (ring-insert ring 2)
  (ring-insert ring 3)
  (ring-elements ring))
#+END_SRC

#+RESULTS:
: (3 2 1)

* ring-empty-p

#+BEGIN_SRC elisp
(ring-empty-p (make-ring 3))
#+END_SRC

#+RESULTS:
: t

* ring-insert

#+BEGIN_SRC elisp
(let ((ring (make-ring 3)))
  (ring-insert ring 1)
  (ring-insert ring 2)
  (ring-insert ring 3)
  ring)
#+END_SRC

#+RESULTS:
: (0 3 .
:    [1 2 3])

* ring-insert-at-beginning

#+BEGIN_SRC elisp
(let ((ring (make-ring 3)))
  (ring-insert ring 1)
  (ring-insert ring 2)
  (ring-insert-at-beginning ring 0)
  ring)
#+END_SRC

#+RESULTS:
: (2 3 .
:    [1 2 0])

* ring-length

#+BEGIN_SRC elisp
(let ((ring (make-ring 3)))
  (ring-insert ring "hello")
  (ring-length ring))
#+END_SRC

#+RESULTS:
: 1

* ring-p

#+BEGIN_SRC elisp
(ring-p (make-ring 3))
#+END_SRC

#+RESULTS:
: t

* ring-ref

#+BEGIN_SRC elisp
(let ((ring (make-ring 3)))
  (ring-insert ring 1)
  (ring-insert ring 2)
  (ring-insert ring 3)
  (ring-ref ring 0))
#+END_SRC

#+RESULTS:
: 3

* ring-remove

#+BEGIN_SRC elisp
(let ((ring (make-ring 3)))
  (ring-insert ring 1)
  (ring-insert ring 2)
  (ring-insert ring 3)
  (ring-remove ring)
  ring)
#+END_SRC

#+RESULTS:
: (0 2 .
:    [2 3 nil])

* ring-resize
:PROPERTIES:
:added:    27.1
:END:

#+BEGIN_SRC elisp
(let ((r (make-ring 2)))
  (ring-insert r "a")
  (ring-insert r "b")
  (ring-resize r 5)
  (ring-insert r "c")
  r)
#+END_SRC

#+RESULTS:
: (0 3 .
:    ["a" "b" "c" nil nil])

* ring-size

#+BEGIN_SRC elisp
(ring-size (make-ring 3))
#+END_SRC

#+RESULTS:
: 3

* rot13

#+BEGIN_SRC elisp
(rot13 "HELLO")
#+END_SRC

#+RESULTS:
: "URYYB"

* rot13-region

#+BEGIN_SRC elisp
(with-temp-buffer
  (insert "HELLO")
  (rot13-region (point-min) (point-max))
  (buffer-string))
#+END_SRC

#+RESULTS:
: "URYYB"

* rot13-string

#+BEGIN_SRC elisp
(rot13-string "HELLO")
#+END_SRC

#+RESULTS:
: "URYYB"

* round

#+BEGIN_SRC elisp
(list (round 1.2)
      (round 1.5))
#+END_SRC

#+RESULTS:
: (1 2)

* run-at-time

#+BEGIN_SRC elisp
(run-at-time 3 nil #'about-emacs)
#+END_SRC

#+RESULTS:
: [nil 23532 38462 672975 nil about-emacs nil nil 0]

* run-with-idle-timer

#+BEGIN_SRC elisp
(run-with-idle-timer 3 nil (lambda () (message "Your Emacs is idle for 3 seconds")))
#+END_SRC

#+RESULTS:
: [nil 0 3 0 nil
:      (lambda nil
:        (message "Your Emacs is idle for 3 seconds"))
:      nil idle 0]

* rx
:PROPERTIES:
:changes:  27.1 Add literal.
:END:

#+BEGIN_SRC elisp
;; To match <2018-11-07>
(rx "<" (group (in ?- "0-9")) ">")
#+END_SRC

#+RESULTS:
: "<\\([-0-9]\\)>"

* rx-to-string

#+BEGIN_SRC elisp
;; `rx' is a macro and can't compute regexp at run-time, that is, once the macro
;; is expanded, the result is static, not only byte-compiler but also
;; load/require/eval-buffer/etc expands macro eagerly.  By the way, We don't
;; consider `eval' even if it works, it is simply bad
;; (eval '(rx (eval (buffer-name))))
(rx-to-string `(and bos ,(buffer-name) eos))
#+END_SRC

#+RESULTS:
: "\\(?:\\`elisp-demos\\.org\\'\\)"

* s-append

#+BEGIN_SRC elisp
(s-append "abc" "def")
#+END_SRC

#+RESULTS:
: "defabc"

* s-blank?

#+BEGIN_SRC elisp
(s-blank? " ")
#+END_SRC

#+RESULTS:
: nil

* s-capitalize

#+BEGIN_SRC elisp
(s-capitalize "HELLO WORLD")
#+END_SRC

#+RESULTS:
: "Hello world"

* s-capitalized-words

#+BEGIN_SRC elisp
(s-capitalized-words "hello_world")
#+END_SRC

#+RESULTS:
: "Hello world"

* s-capitalized?

#+BEGIN_SRC elisp
(s-capitalized? "Capitalized")
#+END_SRC

#+RESULTS:
: t

* s-center

#+BEGIN_SRC elisp
(s-center 5 "a")
#+END_SRC

#+RESULTS:
: "  a  "

* s-chomp

#+BEGIN_SRC elisp
(list (s-chomp "no newlines\n")
      (s-chomp "no newlines\r\n")
      (s-chomp "some newlines\n\n"))
#+END_SRC

#+RESULTS:
: ("no newlines" "no newlines" "some newlines\n")

* s-chop-prefix

#+BEGIN_SRC elisp
(s-chop-prefix "/tmp/" "/tmp/file.js")
#+END_SRC

#+RESULTS:
: "file.js"

* s-chop-prefixes

#+BEGIN_SRC elisp
(s-chop-prefixes '("/tmp" "/my/") "/tmp/my/file.js")
#+END_SRC

#+RESULTS:
: "file.js"

* s-chop-suffix

#+BEGIN_SRC elisp
(s-chop-suffix "-test.js" "penguin-test.js")
#+END_SRC

#+RESULTS:
: "penguin"

* s-chop-suffixes

#+BEGIN_SRC elisp
(s-chop-suffixes '(".gz" ".el") "simple.el.gz")
#+END_SRC

#+RESULTS:
: "simple"

* s-collapse-whitespace

#+BEGIN_SRC elisp
(s-collapse-whitespace "only   one space   please")
#+END_SRC

#+RESULTS:
: "only one space please"

* s-concat

#+BEGIN_SRC elisp
(s-concat "hello" " " "world")
#+END_SRC

#+RESULTS:
: "hello world"

* s-contains?

#+BEGIN_SRC elisp
(s-contains? "file" "lib/file.js")
#+END_SRC

#+RESULTS:
: t

* s-count-matches

#+BEGIN_SRC elisp
(s-count-matches "a" "aba")
#+END_SRC

#+RESULTS:
: 2

* s-dashed-words

#+BEGIN_SRC elisp
(s-dashed-words "foo bar baz")
#+END_SRC

#+RESULTS:
: "foo-bar-baz"

* s-downcase

#+BEGIN_SRC elisp
(s-downcase "EMACS")
#+END_SRC

#+RESULTS:
: "emacs"

* s-ends-with?

#+BEGIN_SRC elisp
(s-ends-with? ".md" "readme.md")
#+END_SRC

#+RESULTS:
: t

* s-equals?

#+BEGIN_SRC elisp
(s-equals? "abc" "abc")
#+END_SRC

#+RESULTS:
: t

* s-format

#+BEGIN_SRC elisp
(s-format
 "help ${name}! I'm ${malady}"
 'aget
 '(("name" . "nic")
   ("malady" . "on fire")))
#+END_SRC

#+RESULTS:
: "help nic! I'm on fire"

* s-index-of

#+BEGIN_SRC elisp
(s-index-of "def" "abcdef")
#+END_SRC

#+RESULTS:
: 3

* s-join

#+BEGIN_SRC elisp
(s-join "-" '("a" "b" "c"))
#+END_SRC

#+RESULTS:
: "a-b-c"

* s-left

#+BEGIN_SRC elisp
(s-left 3 "lib/file.js")
#+END_SRC

#+RESULTS:
: "lib"

* s-less?

#+BEGIN_SRC elisp
(s-less? "abc" "abd")
#+END_SRC

#+RESULTS:
: t

* s-lex-format

#+BEGIN_SRC elisp
(let ((x 1))
  (s-lex-format "x is ${x}"))
#+END_SRC

#+RESULTS:
: "x is 1"

* s-lines

#+BEGIN_SRC elisp
(s-lines "abc\ndef\nghi")
#+END_SRC

#+RESULTS:
: ("abc" "def" "ghi")

* s-lower-camel-case

#+BEGIN_SRC elisp
(s-lower-camel-case "foo bar baz")
#+END_SRC

#+RESULTS:
: "fooBarBaz"

* s-lowercase?

#+BEGIN_SRC elisp
(s-lowercase? "file")
#+END_SRC

#+RESULTS:
: t

* s-match

#+BEGIN_SRC elisp
(s-match
 (rx (group (= 4 num)) "-"
     (group (= 2 num)) "-"
     (group (= 2 num)))
 "Today is <2018-11-26>")
#+END_SRC

#+RESULTS:
: ("2018-11-26" "2018" "11" "26")

* s-match-strings-all

#+BEGIN_SRC elisp
(s-match-strings-all "ab." "abXabY")
#+END_SRC

#+RESULTS:
: (("abX")
:  ("abY"))

* s-matched-positions-all

#+BEGIN_SRC elisp
(s-matched-positions-all "[0-9]" "a0b1")
#+END_SRC

#+RESULTS:
: ((1 . 2)
:  (3 . 4))

* s-matches?

#+BEGIN_SRC elisp
(s-matches? "^[0-9]+$" "123")
#+END_SRC

#+RESULTS:
: t

* s-mixedcase?

#+BEGIN_SRC elisp
(s-mixedcase? "Emacs")
#+END_SRC

#+RESULTS:
: t

* s-numeric?

#+BEGIN_SRC elisp
(s-numeric? "123")
#+END_SRC

#+RESULTS:
: t

* s-pad-left

#+BEGIN_SRC elisp
(s-pad-left 3 "0" "3")
#+END_SRC

#+RESULTS:
: "003"

* s-pad-right

#+BEGIN_SRC elisp
(s-pad-right 10 "." "hello")
#+END_SRC

#+RESULTS:
: "hello....."

* s-prepend

#+BEGIN_SRC elisp
(s-prepend "abc" "def")
#+END_SRC

#+RESULTS:
: "abcdef"

* s-presence

#+BEGIN_SRC elisp
(s-presence " ")
#+END_SRC

#+RESULTS:
: " "

* s-present?

#+BEGIN_SRC elisp
(s-present? " ")
#+END_SRC

#+RESULTS:
: t

* s-repeat

#+BEGIN_SRC elisp
(s-repeat 3 "No")
#+END_SRC

#+RESULTS:
: "NoNoNo"

* s-replace

#+BEGIN_SRC elisp
(s-replace "file" "nope" "lib/file.js")
#+END_SRC

#+RESULTS:
: "lib/nope.js"

* s-replace-all

#+BEGIN_SRC elisp
(s-replace-all '(("Vim" . "Emacs")
                 ("Emacs" . "Vim"))
               "Vim and Emacs")
#+END_SRC

#+RESULTS:
: "Emacs and Vim"

* s-reverse

#+BEGIN_SRC elisp
(s-reverse "abc")
#+END_SRC

#+RESULTS:
: "cba"

* s-right

#+BEGIN_SRC elisp
(s-right 3 "lib/file.js")
#+END_SRC

#+RESULTS:
: ".js"

* s-shared-end

#+BEGIN_SRC elisp
(s-shared-end "bar" "var")
#+END_SRC

#+RESULTS:
: "ar"

* s-shared-start

#+BEGIN_SRC elisp
(s-shared-start "bar" "baz")
#+END_SRC

#+RESULTS:
: "ba"

* s-slice-at

#+BEGIN_SRC elisp
(s-slice-at "/" "/path/to/file")
#+END_SRC

#+RESULTS:
: ("/path" "/to" "/file")

* s-snake-case

#+BEGIN_SRC elisp
(s-snake-case "foo-bar-baz")
#+END_SRC

#+RESULTS:
: "foo_bar_baz"

* s-split

#+BEGIN_SRC elisp
(s-split "/" "/path/to/file" 'omit-nulls)
#+END_SRC

#+RESULTS:
: ("path" "to" "file")

* s-split-up-to

#+BEGIN_SRC elisp
(s-split-up-to "/" "/path/to/file" 2 'omit-nulls)
#+END_SRC

#+RESULTS:
: ("path" "to/file")

* s-split-words

#+BEGIN_SRC elisp
(s-split-words "hello_world")
#+END_SRC

#+RESULTS:
: ("hello" "world")

* s-starts-with?

#+BEGIN_SRC elisp
(s-starts-with? "lib/" "lib/file.js")
#+END_SRC

#+RESULTS:
: t

* s-titleize

#+BEGIN_SRC elisp
(s-titleize "hello world")
#+END_SRC

#+RESULTS:
: "Hello World"

* s-titleized-words

#+BEGIN_SRC elisp
(s-titleized-words "foo_bar_baz")
#+END_SRC

#+RESULTS:
: "Foo Bar Baz"

* s-trim

#+BEGIN_SRC elisp
(s-trim " hello ")
#+END_SRC

#+RESULTS:
: "hello"

* s-trim-left

#+BEGIN_SRC elisp
(s-trim-left " hello ")
#+END_SRC

#+RESULTS:
: "hello "

* s-trim-right

#+BEGIN_SRC elisp
(s-trim-right " hello ")
#+END_SRC

#+RESULTS:
: " hello"

* s-truncate

#+BEGIN_SRC elisp
(s-truncate 14 "This is too long")
#+END_SRC

#+RESULTS:
: "This is too..."

* s-upcase

#+BEGIN_SRC elisp
(s-upcase "emacs")
#+END_SRC

#+RESULTS:
: "EMACS"

* s-upper-camel-case

#+BEGIN_SRC elisp
(s-upper-camel-case "foo bar baz")
#+END_SRC

#+RESULTS:
: "FooBarBaz"

* s-uppercase?

#+BEGIN_SRC elisp
(s-uppercase? "EMACS")
#+END_SRC

#+RESULTS:
: t

* s-with

#+BEGIN_SRC elisp
(s-with "  hello  " s-trim s-upcase)
#+END_SRC

#+RESULTS:
: "HELLO"

* s-word-initials

#+BEGIN_SRC elisp
(s-word-initials "foo bar baz")
#+END_SRC

#+RESULTS:
: "fbb"

* s-word-wrap

#+BEGIN_SRC elisp
(s-word-wrap 10 "This is too long")
#+END_SRC

#+RESULTS:
: "This is\ntoo long"

* s-wrap

#+BEGIN_SRC elisp
(s-wrap "foo" "<" ">")
#+END_SRC

#+RESULTS:
: "<foo>"

* safe-length

#+BEGIN_SRC elisp
(safe-length '(1 2 3))
#+END_SRC

#+RESULTS:
: 3

* same-class-p

#+BEGIN_SRC elisp
(defclass my-class () ())
(same-class-p (my-class) 'my-class)
#+END_SRC

#+RESULTS:
: t

* save-current-buffer

#+BEGIN_SRC elisp
(list (current-buffer)
      (save-current-buffer
        (set-buffer "*Messages*")
        (current-buffer))
      (current-buffer))
#+END_SRC

#+RESULTS:
: (#<buffer elisp-demos.org> #<buffer *Messages*> #<buffer elisp-demos.org>)

* save-excursion

#+BEGIN_SRC elisp
(save-excursion
  (goto-char (point-min)))
#+END_SRC

#+RESULTS:
: 1

* save-match-data

#+BEGIN_SRC elisp
(list
 (string-match "hello" "hello world")
 (match-data)
 (save-match-data
   (string-match "world" "hello world")
   (match-data))
 (match-data))
#+END_SRC

#+RESULTS:
: (0
:  (0 5)
:  (6 11)
:  (0 5))

* save-restriction

#+BEGIN_SRC elisp
(with-temp-buffer
  (insert "hello world")
  (narrow-to-region 1 6)
  (list (buffer-narrowed-p)
        (save-restriction
          (widen)
          (buffer-narrowed-p))
        (buffer-narrowed-p)))

#+END_SRC

#+RESULTS:
: (t nil t)

* scan-lists

#+BEGIN_SRC elisp
(with-temp-buffer
  (with-syntax-table emacs-lisp-mode-syntax-table
    (insert "(list (a) (b) (c) (d))")
    (goto-char (scan-lists (point-min) 4 -1))
    (insert "|")
    (buffer-string)))
#+END_SRC

#+RESULTS:
: "(list (a) (b) (c)| (d))"

* scan-sexps

#+BEGIN_SRC elisp
(with-temp-buffer
  (with-syntax-table emacs-lisp-mode-syntax-table
    (insert "a b c d")
    (goto-char (scan-sexps (point-min) 3))
    (insert "|")
    (buffer-string)))
#+END_SRC

#+RESULTS:
: "a b c| d"

* seconds-to-string
:PROPERTIES:
:added:    25.1
:END:

#+BEGIN_SRC elisp
(seconds-to-string 150)
#+END_SRC

#+RESULTS:
: "2.50m"

* seconds-to-time

#+BEGIN_SRC elisp
(current-time-string
 (seconds-to-time (* (+ (* 50 365) 12) (* 24 60 60)))
 t)
#+END_SRC

#+RESULTS:
: "Wed Jan  1 00:00:00 2020"

* secure-hash

#+BEGIN_SRC elisp
(secure-hash 'md5 "hello")
#+END_SRC

#+RESULTS:
: "5d41402abc4b2a76b9719d911017c592"

#+BEGIN_SRC elisp
(mapconcat
 (lambda (n) (format "%x" n))
 (secure-hash 'md5 "hello" nil nil 'binary)
 "")
#+END_SRC

#+RESULTS:
: "5d41402abc4b2a76b9719d911017c592"

* secure-hash-algorithms
:PROPERTIES:
:added:    26.1
:END:

#+BEGIN_SRC elisp
(secure-hash-algorithms)
#+END_SRC

#+RESULTS:
: (md5 sha1 sha224 sha256 sha384 sha512)

* select-frame-set-input-focus

#+BEGIN_SRC elisp
(select-frame-set-input-focus (next-frame))
#+END_SRC

#+RESULTS:
: nil

* selected-frame

#+BEGIN_SRC elisp
(selected-frame)
#+END_SRC

#+RESULTS:
: #<frame /Users/xcy/src/elisp-demos/elisp-demos.org 0x1049a21e8>

* selected-window

#+BEGIN_SRC elisp
(selected-window)
#+END_SRC

#+RESULTS:
: #<window 25 on elisp-demos.org>

* selected-window-group

#+BEGIN_SRC elisp
(selected-window-group)
#+END_SRC

#+RESULTS:
: (#<window 42 on elisp-demos.org> #<window 44 on elisp-demos.org>)

* seq-concatenate

#+BEGIN_SRC elisp
(seq-concatenate 'list '(1 2) '(3 4) [5 6])
#+END_SRC

#+RESULTS:
: (1 2 3 4 5 6)

* seq-contains

#+BEGIN_SRC elisp
(seq-contains '(symbol1 symbol2) 'symbol1)
#+END_SRC

#+RESULTS:
: symbol1

* seq-contains-p
:PROPERTIES:
:added:    27.1
:END:

#+BEGIN_SRC elisp
(seq-contains-p '(1 2 3) 3)
#+END_SRC

#+RESULTS:
: t

* seq-count

#+BEGIN_SRC elisp
(seq-count (lambda (elt) (> elt 0)) [-1 2 0 3 -2])
#+END_SRC

#+RESULTS:
: 2

* seq-difference

#+BEGIN_SRC elisp
(seq-difference '(2 3 4 5) [1 3 5 6 7])
#+END_SRC

#+RESULTS:
: (2 4)

* seq-do

#+BEGIN_SRC elisp :results output
(seq-do #'princ '(1 2 3))
#+END_SRC

#+RESULTS:
: "123"

* seq-doseq

#+BEGIN_SRC elisp :results output
(seq-doseq (i [1 2 3])
  (princ i))
#+END_SRC

#+RESULTS:
: "123"

* seq-drop

#+BEGIN_SRC elisp
(seq-drop [1 2 3 4 5 6] 3)
#+END_SRC

#+RESULTS:
: [4 5 6]

* seq-drop-while

#+BEGIN_SRC elisp
(seq-drop-while
 (lambda (elt) (> elt 0))
 '(1 2 3 -1 -2))
#+END_SRC

#+RESULTS:
: (-1 -2)

* seq-elt

#+BEGIN_SRC elisp
(seq-elt [1 2 3 4] 2)
#+END_SRC

#+RESULTS:
: 3

* seq-empty-p

#+BEGIN_SRC elisp
(seq-map #'seq-empty-p '([] () ""))
#+END_SRC

#+RESULTS:
: (t t t)

* seq-every-p

#+BEGIN_SRC elisp
(seq-every-p #'numberp [2 4 6])
#+END_SRC

#+RESULTS:
: t

* seq-filter

#+BEGIN_SRC elisp
(seq-filter (lambda (elt) (> elt 0)) [1 -1 3 -3 5])
#+END_SRC

#+RESULTS:
: (1 3 5)

#+BEGIN_SRC elisp
(seq-filter #'numberp '(a 1 b c 3 4 d 5))
#+END_SRC

#+RESULTS:
: (1 3 4 5)

* seq-find

#+BEGIN_SRC elisp
(seq-find #'numberp ["abc" 1 nil])
#+END_SRC

#+RESULTS:
: 1

* seq-first
:PROPERTIES:
:added:    27.1
:END:

#+BEGIN_SRC elisp
(string (seq-first "hello"))
#+END_SRC

#+RESULTS:
: "h"

* seq-group-by

#+BEGIN_SRC elisp
(seq-group-by #'integerp '(1 2.1 3 2 3.2))
#+END_SRC

#+RESULTS:
: ((t 1 3 2)
:  (nil 2.1 3.2))

* seq-intersection

#+BEGIN_SRC elisp
(seq-intersection [2 3 4 5] [1 3 5 6 7])
#+END_SRC

#+RESULTS:
: (3 5)

* seq-into

#+BEGIN_SRC elisp
(seq-into [1 2 3] 'list)
#+END_SRC

#+RESULTS:
: (1 2 3)

* seq-keep
:PROPERTIES:
:added:    29.1
:END:

#+BEGIN_SRC elisp
(seq-keep (lambda (n)
            (and (cl-evenp n)
                 (* 2 n)))
          (number-sequence 1 5))
#+END_SRC

#+RESULTS:
: (4 8)

* seq-length

#+BEGIN_SRC elisp
(seq-length [0 1 2 3])
#+END_SRC

#+RESULTS:
: 4

* seq-let

#+BEGIN_SRC elisp
(seq-let (a _ c) '(1 2 3 4)
  (list a c))
#+END_SRC

#+RESULTS:
: (1 3)

* seq-map

#+BEGIN_SRC elisp
(seq-map #'1+ '(1 2 3))
#+END_SRC

#+RESULTS:
: (2 3 4)

* seq-map-indexed
:PROPERTIES:
:added:    26.1
:END:

#+BEGIN_SRC elisp
(seq-map-indexed
 (lambda (elt idx)
   (list idx elt))
 '(a b c))
#+END_SRC

#+RESULTS:
: ((0 a)
:  (1 b)
:  (2 c))

* seq-mapcat

#+BEGIN_SRC elisp
(seq-mapcat #'seq-reverse '((3 2 1) (6 5 4)))
#+END_SRC

#+RESULTS:
: (1 2 3 4 5 6)

#+BEGIN_SRC elisp
;; See also 26.1's `mapcan' and `cl-mapcan'
(seq-mapcat
 (lambda (x)
   (and (car x) (cdr x)))
 '((t   1 2)
   (nil 3 4)
   (t   5 6)
   (nil 7 8)))
#+END_SRC

#+RESULTS:
: (1 2 5 6)

* seq-mapn

#+BEGIN_SRC elisp
(seq-mapn #'+ '(2 4 6) '(20 40 60))
#+END_SRC

#+RESULTS:
: (22 44 66)

* seq-max

#+BEGIN_SRC elisp
(seq-max [1 3 2])
#+END_SRC

#+RESULTS:
: 3

* seq-min

#+BEGIN_SRC elisp
(seq-min [3 1 2])
#+END_SRC

#+RESULTS:
: 1

* seq-partition

#+BEGIN_SRC elisp
(seq-partition '(0 1 2 3 4 5 6 7) 3)
#+END_SRC

#+RESULTS:
: ((0 1 2)
:  (3 4 5)
:  (6 7))

* seq-position

#+BEGIN_SRC elisp
(seq-position '(a b c) 'b)
#+END_SRC

#+RESULTS:
: 1

* seq-positions
:PROPERTIES:
:added:    29.1
:END:

#+BEGIN_SRC elisp
(seq-positions '(a b c a) 'a #'eq)
#+END_SRC

#+RESULTS:
: (0 3)

* seq-random-elt
:PROPERTIES:
:added:    26.1
:END:

#+BEGIN_SRC elisp
(seq-random-elt [1 2 3 4])
#+END_SRC

#+RESULTS:
: 3

* seq-reduce

#+BEGIN_SRC elisp
(seq-reduce #'+ (number-sequence 1 100) 0)
#+END_SRC

#+RESULTS:
: 5050

* seq-remove

#+BEGIN_SRC elisp
(seq-remove (lambda (elt) (> elt 0)) [1 -1 3 -3 5])
#+END_SRC

#+RESULTS:
: (-1 -3)

* seq-remove-at-position
:PROPERTIES:
:added:    29.1
:END:

#+BEGIN_SRC elisp
(seq-remove-at-position (list 1 2 3) 1)
#+END_SRC

#+RESULTS:
: (1 3)

* seq-rest
:PROPERTIES:
:added:    27.1
:END:

#+BEGIN_SRC elisp
(seq-rest "hello")
#+END_SRC

#+RESULTS:
: "ello"

* seq-reverse

#+BEGIN_SRC elisp
(seq-reverse (list 1 2 3))
#+END_SRC

#+RESULTS:
: (3 2 1)

* seq-set-equal-p
:PROPERTIES:
:added:    26.1
:END:

#+BEGIN_SRC elisp
(seq-set-equal-p "good" "dog")
#+END_SRC

#+RESULTS:
: t

* seq-some

#+BEGIN_SRC elisp
(seq-some #'numberp ["abc" 1 nil])
#+END_SRC

#+RESULTS:
: t

* seq-sort

#+BEGIN_SRC elisp
(seq-sort #'< '(1 3 2))
#+END_SRC

#+RESULTS:
: (1 2 3)

* seq-sort-by
:PROPERTIES:
:added:    26.1
:END:

#+BEGIN_SRC elisp
(seq-sort-by #'seq-length #'> ["a" "ab" "abc"])
#+END_SRC

#+RESULTS:
: ["abc" "ab" "a"]

* seq-split
:PROPERTIES:
:added:    29.1
:END:

#+BEGIN_SRC elisp
(seq-split (number-sequence 1 5) 2)
#+END_SRC

#+RESULTS:
: ((1 2)
:  (3 4)
:  (5))

* seq-subseq

#+BEGIN_SRC elisp
(seq-subseq '(1 2 3 4 5) 1)
#+END_SRC

#+RESULTS:
: (2 3 4 5)

* seq-take

#+BEGIN_SRC elisp
(seq-take '(1 2 3 4) 3)
#+END_SRC

#+RESULTS:
: (1 2 3)

* seq-take-while

#+BEGIN_SRC elisp
(seq-take-while
 (lambda (elt)
   (> elt 0))
 '(1 2 3 -1 -2))
#+END_SRC

#+RESULTS:
: (1 2 3)

* seq-union
:PROPERTIES:
:added:    28.1
:END:

#+BEGIN_SRC elisp
(seq-union [1 2] [2 4])
#+END_SRC

#+RESULTS:
: (1 2 4)

* seq-uniq

#+BEGIN_SRC elisp
(seq-uniq '(1 2 2 1 3))
#+END_SRC

#+RESULTS:
: (1 2 3)

* seqp

#+BEGIN_SRC elisp
(seqp [1 2])
#+END_SRC

#+RESULTS:
: t

* sequencep

#+BEGIN_SRC elisp
(and (sequencep '(1 2 3))
     (sequencep [1 2 3])
     (sequencep "123"))
#+END_SRC

#+RESULTS:
: t

* server-eval-at

#+BEGIN_SRC elisp
(shell-command "emacs-24.4 -Q --daemon=foo")
(prog1 (server-eval-at "foo" 'emacs-version)
  (server-eval-at "foo" '(kill-emacs)))
#+END_SRC

#+RESULTS:
: "24.4.1"

* server-quote-arg

#+BEGIN_SRC elisp
(server-quote-arg "'(+ 1 2)")
#+END_SRC

#+RESULTS:
: "'(+&_1&_2)"

* server-unquote-arg

#+BEGIN_SRC elisp
(server-unquote-arg "'(+&_1&_2)")
#+END_SRC

#+RESULTS:
: "'(+ 1 2)"

* set

#+BEGIN_SRC elisp
(let ((x 1))
  (set 'x 42)
  x)
#+END_SRC

#+RESULTS:
: 42

* set-binary-mode
:PROPERTIES:
:added:    25.1
:END:

#+BEGIN_SRC elisp
;; Flush standard output
(set-binary-mode 'stdout nil)
#+END_SRC

* set-buffer

#+BEGIN_SRC elisp
(progn (set-buffer "*Messages*")
       (current-buffer))
#+END_SRC

#+RESULTS:
: #<buffer *Messages*>

* set-buffer-modified-p

#+BEGIN_SRC elisp
(set-buffer-modified-p (buffer-modified-p))
#+END_SRC

#+RESULTS:
: nil

* set-buffer-multibyte

#+BEGIN_SRC elisp
(with-temp-buffer
  (set-buffer-multibyte nil)
  (insert "Î»")
  (multibyte-string-p (buffer-string)))
#+END_SRC

#+RESULTS:
: nil

* set-face-attribute

#+BEGIN_SRC elisp
(set-face-attribute 'default nil :font "Source Code Pro-13")
#+END_SRC

#+RESULTS:
: nil

* set-file-modes

#+BEGIN_SRC elisp
(let ((file (make-temp-file "elisp-demos-")))
  (unwind-protect
      (progn (set-file-modes file #o644)
             (format "%o" (file-modes file)))
    (delete-file file)))
#+END_SRC

#+RESULTS:
: "644"

* set-keymap-parent

#+BEGIN_SRC elisp :results silent
(let ((map (make-sparse-keymap)))
  (set-keymap-parent map special-mode-map)
  map)
#+END_SRC

* set-process-plist

#+BEGIN_SRC elisp
;; Start the shell process if not already
(shell)

(set-process-plist (get-process "shell") '(foo 123 bar 456))

(process-plist (get-process "shell"))
#+END_SRC

#+RESULTS:
: (foo 123 bar 456)

* set-process-query-on-exit-flag

#+BEGIN_SRC elisp
;; Start the shell process if not already
(shell)

(set-process-query-on-exit-flag (get-process "shell") nil)
#+END_SRC

#+RESULTS:
: nil

* set-process-sentinel

#+BEGIN_SRC elisp
(set-process-sentinel
 (start-process "sleep" nil "sleep" "3")
 (lambda (process event)
   (message "Process: %s had the event '%s'" process event)))
#+END_SRC

#+RESULTS:
: (lambda
:   (process event)
:   (message "Process: %s had the event '%s'" process event))

* set-syntax-table

#+BEGIN_SRC elisp
(with-temp-buffer
  (vector
   (string (char-syntax ?\{))
   (progn
     ;; {} is not a pair of parens in Emacs Lisp
     (set-syntax-table emacs-lisp-mode-syntax-table)
     (string (char-syntax ?\{)))))
#+END_SRC

#+RESULTS:
: ["(" "_"]

* set-transient-map
:PROPERTIES:
:changes:  29.1 New arguments MESSAGE and TIMEOUT of 'set-transient-map'.
:END:

#+BEGIN_SRC elisp :eval no
(set-transient-map
 (let ((map (make-sparse-keymap)))
   (define-key map "a" (lambda () (interactive) (message "=> a")))
   (define-key map "b" (lambda () (interactive) (message "=> b")))
   map))
#+END_SRC

#+BEGIN_SRC elisp :lexical t
(defun counter ()
  (interactive)
  (let* ((i 0)
         (msg (lambda () (message "Use <up> and <down> to adjust: i = %d" i))))
    (funcall msg)
    (set-transient-map
     (let ((map (make-sparse-keymap)))
       (define-key map [up] (lambda () (interactive) (cl-incf i) (funcall msg)))
       (define-key map [down] (lambda () (interactive) (cl-decf i) (funcall msg)))
       map)
     (lambda ()
       (member (this-command-keys-vector) '([up] [down])))
     (lambda ()
       (message "Exiting: i = %d" i)))))
#+END_SRC

#+RESULTS:
: counter

* set-window-margins

#+BEGIN_SRC elisp
(set-window-margins (selected-window) 40 40)
#+END_SRC

#+RESULTS:
: t

* setcar

#+BEGIN_SRC elisp
(let ((x (cons 1 2)))
  (setcar x 100)
  x)
#+END_SRC

#+RESULTS:
: (100 . 2)

* setcdr

#+BEGIN_SRC elisp
(let ((x (cons 1 2)))
  (setcdr x 200)
  x)
#+END_SRC

#+RESULTS:
: (1 . 200)

* setenv

#+BEGIN_SRC elisp
(setenv "EMACS_VERSION" emacs-version)
#+END_SRC

#+RESULTS:
: "26.1"

* setf

#+BEGIN_SRC elisp
(let ((numbers (list 1 2 3)))
  (setf (elt numbers 1) 200)
  numbers)

#+END_SRC

#+RESULTS:
: (1 200 3)

* setplist

#+BEGIN_SRC elisp
(setplist 'foo '(a 1 b (2 3) c nil))
#+END_SRC

#+RESULTS:
: (a 1 b
:    (2 3)
:    c nil)

* setq

#+BEGIN_SRC elisp
(let ((x 0))
  (setq x 42)
  x)
#+END_SRC

#+RESULTS:
: 42

* sha1

#+BEGIN_SRC elisp
(sha1 "hello")
#+END_SRC

#+RESULTS:
: "aaf4c61ddcc5e8a2dabede0f3b482cd9aea9434d"

* shell-command-to-string

#+BEGIN_SRC elisp
(shell-command-to-string "echo hello world")
#+END_SRC

#+RESULTS:
: "hello world\n"

* shell-quote-argument
:PROPERTIES:
:changes:  29.1 The optional argument POSIX is added.
:END:

#+BEGIN_SRC elisp
(shell-quote-argument "Library/Application Support")
#+END_SRC

#+RESULTS:
: "Library/Application\\ Support"

* should

#+BEGIN_SRC elisp
(should (= (expt 2 10) 1024))
#+END_SRC

#+RESULTS:
: t

* should-error

#+BEGIN_SRC elisp
(should-error (/ 1 0) :type 'arith-error)
#+END_SRC

#+RESULTS:
: (arith-error)

* signal

#+BEGIN_SRC elisp
(signal 'wrong-type-argument '(numberp "string"))
#+END_SRC

* signal-process

#+BEGIN_SRC elisp
;; Start the shell process if not already
(shell)

(signal-process (get-process "shell") 'SIGHUP)
#+END_SRC

* sin

#+BEGIN_SRC elisp
(sin (/ float-pi 2))
#+END_SRC

#+RESULTS:
: 1.0

* sit-for

#+BEGIN_SRC elisp
(sit-for 3)
#+END_SRC

#+RESULTS:
: t

* sleep-for

#+BEGIN_SRC elisp
(sleep-for 3)
#+END_SRC

#+RESULTS:
: nil

* slot-boundp

#+BEGIN_SRC elisp
(defclass person ()
  ((name :initarg :name
         :initform user-full-name)
   (birthday :initarg :birthday))
  "A person class.")

(list (slot-boundp (person) :name)
      (slot-boundp (person) :birthday))
#+END_SRC

#+RESULTS:
: (t nil)

* slot-exists-p

#+BEGIN_SRC elisp
(defclass circle ()
  ((radius :initarg :radius))
  "A circle class.")

(list (slot-exists-p 'circle 'radius)
      (slot-exists-p (circle :radius 10) 'radius))
#+END_SRC

#+RESULTS:
: (0 0)

* sort

#+BEGIN_SRC elisp
(let ((num '(1 3 2 6 5 4 0)))
  (sort num #'<))
#+END_SRC

#+RESULTS:
: (0 1 2 3 4 5 6)

#+BEGIN_SRC elisp
;; Make a sorted copy without destroying the original
(let* ((num '(1 3 2 6 5 4 0))
       (sorted (sort (copy-sequence num) #'<)))
  (list :num num :sorted sorted))
#+END_SRC

#+RESULTS:
: (:num
:  (1 3 2 6 5 4 0)
:  :sorted
:  (0 1 2 3 4 5 6))

* sort-columns

#+BEGIN_SRC elisp :results drawer
(with-temp-buffer
  (insert
   "\
a 1. one
b 3. three
c 4. four
d 2. two")
  (sort-columns nil 3 34)
  (buffer-string))
#+END_SRC

#+RESULTS:
:results:
a 1. one
d 2. two
b 3. three
c 4. four
:end:

* sort-fields

#+BEGIN_SRC elisp :results drawer
(with-temp-buffer
  (insert "\
- fig
- banana
- apple
- cucumber")
  (sort-fields 2 (point-min) (point-max))
  (buffer-string))
#+END_SRC

#+RESULTS:
:results:
- apple
- banana
- cucumber
- fig
:end:

* sort-numeric-fields

#+BEGIN_SRC elisp :results drawer
(with-temp-buffer
  (insert "\
- 13
- 0xf (15)
- 100
- 010 (8)")
  (sort-numeric-fields 2 (point-min) (point-max))
  (buffer-string))
#+END_SRC

#+RESULTS:
:results:
- 010 (8)
- 13
- 0xf (15)
- 100
:end:

* sort-regexp-fields

#+BEGIN_SRC elisp
(with-temp-buffer
  (insert "d, a, c, b,")
  (sort-regexp-fields nil ".," "\\&" (point-min) (point-max))
  (buffer-string))
#+END_SRC

#+RESULTS:
: "a, b, c, d,"

* sort-subr

#+BEGIN_SRC elisp :results drawer
(with-temp-buffer
  (insert "\
1 + 2 + 3
123
0 * 100
2 ^ 10
10 * 100")
  (goto-char (point-min))
  (sort-subr nil
             #'forward-line #'end-of-line
             ;; Compute the sort key
             (lambda ()
               (string-to-number
                (calc-eval
                 (buffer-substring (line-beginning-position)
                                   (line-end-position))))))
  (buffer-string))
#+END_SRC

#+RESULTS:
:RESULTS:
0 * 100
1 + 2 + 3
123
10 * 100
2 ^ 10
:END:

* soundex

#+BEGIN_SRC elisp
(soundex "Rubin")
#+END_SRC

#+RESULTS:
: "R150"

* special-form-p
:PROPERTIES:
:added:    24.4
:END:

#+BEGIN_SRC elisp
(list
 :if   (special-form-p 'if)
 :when (special-form-p 'when))
#+END_SRC

#+RESULTS:
: (:if t :when nil)

* special-variable-p
:PROPERTIES:
:added:    24.1
:END:

#+BEGIN_SRC elisp
(special-variable-p 'emacs-version)
#+END_SRC

#+RESULTS:
: t

* split-string

#+BEGIN_SRC elisp
(split-string "The   quick brown fox." " +")
#+END_SRC

#+RESULTS:
: ("The" "quick" "brown" "fox.")

* split-string-and-unquote

#+BEGIN_SRC elisp
(split-string-and-unquote "-o \"foo bar.txt\"")
#+END_SRC

#+RESULTS:
: ("-o" "foo bar.txt")

* split-string-shell-command
:PROPERTIES:
:added:    28.1
:END:

#+BEGIN_SRC elisp
(split-string-shell-command "ls -a -l '/'")
#+END_SRC

#+RESULTS:
: ("ls" "-a" "-l" "/")

* sqlite-available-p
:PROPERTIES:
:added:    29.1
:END:

#+BEGIN_SRC elisp
(sqlite-available-p)
#+END_SRC

#+RESULTS:
: t

* sqlite-close
:PROPERTIES:
:added:    29.1
:END:

#+BEGIN_SRC elisp
(sqlite-close (sqlite-open))
#+END_SRC

#+RESULTS:
: t

* sqlite-columns
:PROPERTIES:
:added:    29.1
:END:

#+BEGIN_SRC elisp
(sqlite-columns (sqlite-select (sqlite-open) "SELECT 1 + 2, ? * ?" [3 4] 'set))
#+END_SRC

#+RESULTS:
: ("1 + 2" "? * ?")

* sqlite-execute
:PROPERTIES:
:added:    29.1
:END:

#+BEGIN_SRC elisp
(let ((db (sqlite-open)))
  (sqlite-execute
   db
   "CREATE TABLE users (id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT NOT NULL)")
  (sqlite-execute db "INSERT INTO users (name) VALUES (?), (?)" ["Tom" "Jerry"])
  (sqlite-select db "SELECT * FROM users"))
#+END_SRC

#+RESULTS:
: ((1 "Tom")
:  (2 "Jerry"))

* sqlite-more-p
:PROPERTIES:
:added:    29.1
:END:

#+BEGIN_SRC elisp
(sqlite-more-p (sqlite-select (sqlite-open) "SELECT 1 + 2" nil 'set))
#+END_SRC

#+RESULTS:
: t

* sqlite-next
:PROPERTIES:
:added:    29.1
:END:

#+BEGIN_SRC elisp
(let ((db (sqlite-open)))
  (sqlite-execute db "CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT)")
  (sqlite-execute db "INSERT INTO users (name) VALUES (?), (?), (?)"
                  (list "alice" "bob" "calb"))
  (let ((statement (sqlite-select db "SELECT * FROM users" nil 'set))
        (rows nil))
    (while-let ((row (sqlite-next statement)))
      (push row rows))
    (nreverse rows)))
#+END_SRC

#+RESULTS:
: ((1 "alice")
:  (2 "bob")
:  (3 "calb"))

* sqlite-open
:PROPERTIES:
:added:    29.1
:END:

#+BEGIN_SRC elisp
(let ((db (sqlite-open)))
  (prog1 db
    (sqlite-close db)))
#+END_SRC

#+RESULTS:
: #<sqlite db=0x0 name=:memory:3>

* sqlite-pragma
:PROPERTIES:
:added:    29.1
:END:

#+BEGIN_SRC elisp
(sqlite-pragma (sqlite-open) "auto_vacuum = FULL")
#+END_SRC

* sqlite-rollback
:PROPERTIES:
:added:    29.1
:END:

#+BEGIN_SRC elisp
(let ((db (sqlite-open)))
  (sqlite-transaction db)
  (sqlite-execute db "CREATE TABLE users (name TEXT)")

  ;; Rollback the transaction, undoing the table creation.
  (sqlite-rollback db)

  (sqlite-execute db "CREATE TABLE users (id INTEGER PRIMRY KEY, name TEXT)")
  (sqlite-commit db))
#+END_SRC

#+RESULTS:
: nil

* sqlite-select
:PROPERTIES:
:added:    29.1
:END:

#+BEGIN_SRC elisp
(let ((db (sqlite-open)))
  (sqlite-select db "SELECT ? + ?" '(1 2)))
#+END_SRC

#+RESULTS:
: ((3))

* sqlite-transaction
:PROPERTIES:
:added:    29.1
:END:

#+BEGIN_SRC elisp
(let* ((file (make-temp-file "elisp-demos-" nil ".db"))
       (db1 (sqlite-open file))
       (db2 (sqlite-open file)))
  (sqlite-transaction db1)
  (sqlite-execute db1 "CREATE TABLE users (name TEXT)")
  (sqlite-commit db1) ; Commit to make 'users' table visible to other connections.

  ;; Ensure db1 commits before db2's operations to see the latest changes.
  (sqlite-execute db2 "INSERT INTO users (name) VALUES (?), (?)" ["Tom" "Jerry"]))
#+END_SRC

#+RESULTS:
: 2

* sqlite-version
:PROPERTIES:
:added:    29.1
:END:

#+BEGIN_SRC elisp
(sqlite-version)
#+END_SRC

#+RESULTS:
: "3.39.5"

* sqlitep
:PROPERTIES:
:added:    29.1
:END:

#+BEGIN_SRC elisp
(let ((db (sqlite-open)))
  (prog1 (sqlitep db)
    (sqlite-close db)))
#+END_SRC

#+RESULTS:
: t

* sqrt

#+BEGIN_SRC elisp
(sqrt 4)
#+END_SRC

#+RESULTS:
: 2.0

* start-process

#+BEGIN_SRC elisp
(start-process "sleep" "*sleep*" "sleep" "5")
#+END_SRC

#+RESULTS:
: #<process sleep>

* start-process-shell-command

#+BEGIN_SRC elisp
(start-process-shell-command "sleep" "*sleep*" "sleep 5 && echo wake")
#+END_SRC

#+RESULTS:
: #<process sleep>

* stem-english

#+BEGIN_SRC elisp
(stem-english "mesmerizing")
#+END_SRC

#+RESULTS:
: ("mesmer" "mesmeriz" "mesmerize" "mesmerizing")

* store-substring

#+BEGIN_SRC elisp
(let ((a-str "hello"))
  (store-substring a-str 0 ?H)
  a-str)
#+END_SRC

#+RESULTS:
: "Hello"

* stream

#+BEGIN_SRC elisp
(stream-first (stream '(1 2 3)))
#+END_SRC

#+RESULTS:
: 1

* stream-append

#+BEGIN_SRC elisp
(seq-into (stream-append (stream '(1 2 3)) (stream '(4 5 6)))
          'list)
#+END_SRC

#+RESULTS:
: (1 2 3 4 5 6)

* stream-concatenate

#+BEGIN_SRC elisp
(let ((stream1 (stream '(1 2 3)))
      (stream2 (stream '(4 5 6))))
  (seq-into (stream-concatenate (stream (list stream1 stream2)))
            'list))
#+END_SRC

#+RESULTS:
: (1 2 3 4 5 6)

* stream-cons

#+BEGIN_SRC elisp :lexical t
(cl-labels ((fib (a b) (stream-cons a (fib b (+ a b)))))
  (let ((stream (fib 0 1)))
    (seq-into (seq-take stream 11) 'list)))
#+END_SRC

#+RESULTS:
: (0 1 1 2 3 5 8 13 21 34 55)

* stream-empty-p

#+BEGIN_SRC elisp
(stream-empty-p (stream-rest (stream '(1))))
#+END_SRC

#+RESULTS:
: t

* stream-first

#+BEGIN_SRC elisp
(stream-first (stream '(1 2 3)))
#+END_SRC

#+RESULTS:
: 1

* stream-flush

#+BEGIN_SRC elisp :lexical t :results silent
(let ((i 0))
  (cl-labels ((fun
               ()
               (stream-make
                (when (< i 10)
                  (setq i (1+ i))
                  ;; do some side effects
                  (message "=> %d" i)
                  (cons nil (fun))))))
    (stream-flush (fun))))
#+END_SRC

* stream-from-iterator

#+BEGIN_SRC elisp :lexical t
(let* ((iter-fn (iter-lambda ()
                  (let ((a 0)
                        (b 1))
                    (while t
                      (iter-yield a)
                      (cl-psetq a b
                                b (+ a b))))))
       (iter (funcall iter-fn))
       (stream (stream-from-iterator iter)))
  (seq-into (seq-take stream 11) 'list))
#+END_SRC

#+RESULTS:
: (0 1 1 2 3 5 8 13 21 34 55)

* stream-iterate-function

#+BEGIN_SRC elisp
(seq-into (seq-take (stream-iterate-function #'1+ 0)
                    10)
          'list)
#+END_SRC

#+RESULTS:
: (0 1 2 3 4 5 6 7 8 9)

* stream-of-directory-files

#+BEGIN_SRC elisp
;; How many Emacs Lisp files do I have in ~/.emacs.d?
(seq-length
 (stream-of-directory-files
  user-emacs-directory nil nil
  (lambda (dir)
    (let ((basename (file-name-nondirectory dir)))
      (not (or (member basename '(".git" "var" "etc" ".cask" "el-get"))
               ;; elpa-26.1, elpa-26.2
               (string-prefix-p "elpa" basename)))))
  nil
  (lambda (file)
    (equal "el" (file-name-extension file)))))
#+END_SRC

#+RESULTS:
: 80

* stream-pop

#+BEGIN_SRC elisp
(let ((stream (stream-range 1 10))
      result)
  (while (not (stream-empty-p stream))
    (push (stream-pop stream) result))
  (nreverse result))
#+END_SRC

#+RESULTS:
: (1 2 3 4 5 6 7 8 9)

* stream-range

#+BEGIN_SRC elisp
(let ((stream (stream-range 0))
      result)
  (dotimes (_ 10 (nreverse result))
    (push (stream-first stream) result)
    (setq stream (stream-rest stream))))
#+END_SRC

#+RESULTS:
: (0 1 2 3 4 5 6 7 8 9)

* stream-regexp

#+BEGIN_SRC elisp :lexical t
(with-temp-buffer
  (insert "<2018-11-30>")
  (goto-char (point-min))
  (let ((stream (stream-regexp (current-buffer) "[0-9]+")))
    (seq-into (seq-map (lambda (match)
                         (apply #'buffer-substring match))
                       stream)
              'list)))
#+END_SRC

#+RESULTS:
: ("2018" "11" "30")

* stream-rest

#+BEGIN_SRC elisp
(stream-first (stream-rest (stream '(1 2 3))))
#+END_SRC

#+RESULTS:
: 2

* stream-scan

#+BEGIN_SRC elisp
;; (* 1 2 3 4 5)
;; (* (* (* (* (* 1 1) 2) 3) 4) 5)
(seq-elt (stream-scan #'* 1 (stream-range 1))
         5)
#+END_SRC

#+RESULTS:
: 120

* streamp

#+BEGIN_SRC elisp
(streamp (stream '(1 2 3)))
#+END_SRC

#+RESULTS:
: t

* string

#+BEGIN_SRC elisp
(string ?a ?b ?c)
#+END_SRC

#+RESULTS:
: "abc"

* string-as-multibyte

#+BEGIN_SRC elisp
(string-as-multibyte (string-as-unibyte "Î»"))
#+END_SRC

#+RESULTS:
: "Î»"

* string-as-unibyte

#+BEGIN_SRC elisp
(mapcar #'identity (string-as-unibyte "Î»"))
#+END_SRC

#+RESULTS:
: (206 187)

* string-blank-p
:PROPERTIES:
:added:    24.4
:END:

#+BEGIN_SRC elisp
(string-blank-p " ")
#+END_SRC

#+RESULTS:
: 0

* string-bytes

#+BEGIN_SRC elisp
;; #x3bb, #xCE #xBB
(string-bytes "Î»")
#+END_SRC

#+RESULTS:
: 2

* string-chop-newline

#+BEGIN_SRC elisp
(string-chop-newline "hello\nworld\n\n\n")
#+END_SRC

#+RESULTS:
: "hello\nworld\n\n"

* string-clean-whitespace
:PROPERTIES:
:added:    28.1
:END:

#+BEGIN_SRC elisp
(string-clean-whitespace "\thello    \rworld    \n ")
#+END_SRC

#+RESULTS:
: "hello world"

* string-distance
:PROPERTIES:
:added:    27.1
:END:

#+BEGIN_SRC elisp
(string-distance "kitten" "sitting")
#+END_SRC

#+RESULTS:
: 3

* string-empty-p
:PROPERTIES:
:added:    24.4
:END:

#+BEGIN_SRC elisp
(string-empty-p "")
#+END_SRC

#+RESULTS:
: t

* string-equal-ignore-case
:PROPERTIES:
:added:    29.1
:END:

#+BEGIN_SRC elisp
(string-equal-ignore-case "hello" "HELLO")
#+END_SRC

#+RESULTS:
: t

* string-fill

#+BEGIN_SRC elisp
(string-fill (emacs-version) 48)
#+END_SRC

#+RESULTS:
: "GNU Emacs 28.1 (build 1,\naarch64-apple-darwin21.4.0, NS appkit-2113.40\nVersion 12.3.1 (Build 21E258)) of 2022-05-08"

* string-join
:PROPERTIES:
:added:    24.4
:END:

#+BEGIN_SRC elisp
(string-join '("a" "b" "c") "-")
#+END_SRC

#+RESULTS:
: "a-b-c"

* string-limit
:PROPERTIES:
:added:    28.1
:END:

#+BEGIN_SRC elisp
(string-limit "hello world" 5)
#+END_SRC

#+RESULTS:
: "hello"

* string-lines
:PROPERTIES:
:added:    28.1
:changes:  29.1 It no longer returns an empty final string if the string ends with a newline. The optional KEEP-NEWLINES argument is added.
:END:

#+BEGIN_SRC elisp
;; Emacs 28.x
(string-lines "hello\nworld\n")
#+END_SRC

#+RESULTS:
: ("hello" "world" "")

#+BEGIN_SRC elisp
;; Emacs 29.1
(string-lines "hello\nworld\n")
#+END_SRC

#+RESULTS:
: ("hello" "world")

* string-match

#+BEGIN_SRC elisp
(let ((string "Today is <2018-11-07>."))
  (when (string-match "<\\([-0-9]+\\)>" string)
    (match-string 1 string)))
#+END_SRC

#+RESULTS:
: "2018-11-07"

* string-match-p

#+BEGIN_SRC elisp
(list (string-match-p "world" "hello world")
      (string-match-p "12345" "hello world"))
#+END_SRC

#+RESULTS:
: (6 nil)

* string-or-null-p

#+BEGIN_SRC elisp
(mapcar #'string-or-null-p '("" nil 42 t))
#+END_SRC

#+RESULTS:
: (t t nil nil)

* string-pad
:PROPERTIES:
:added:    28.1
:END:

#+BEGIN_SRC elisp
(string-pad "12" 4 ?0 'start)
#+END_SRC

#+RESULTS:
: "0012"

* string-prefix-p
:PROPERTIES:
:added:    24.1
:END:

#+BEGIN_SRC elisp
(string-prefix-p "Sat" "Saturday night plans")
#+END_SRC

#+RESULTS:
: t

* string-remove-prefix
:PROPERTIES:
:added:    24.4
:END:

#+BEGIN_SRC elisp
(string-remove-prefix "=> " "=> Hello <=")
#+END_SRC

#+RESULTS:
: "Hello <="

* string-remove-suffix
:PROPERTIES:
:added:    24.4
:END:

#+BEGIN_SRC elisp
(string-remove-suffix " <=" "=> Hello <=")
#+END_SRC

#+RESULTS:
: "=> Hello"

* string-replace
:PROPERTIES:
:added:    28.1
:END:

#+BEGIN_SRC elisp
(string-replace "bar" "BAR" "foobar")
#+END_SRC

#+RESULTS:
: "fooBAR"

* string-search
:PROPERTIES:
:added:    28.1
:END:

#+BEGIN_SRC elisp
(string-search "bar" "foobar")
#+END_SRC

#+RESULTS:
: 3

* string-suffix-p
:PROPERTIES:
:added:    24.4
:END:

#+BEGIN_SRC elisp
(string-suffix-p "!" "Cats are the best!")
#+END_SRC

#+RESULTS:
: t

* string-to-char

#+BEGIN_SRC elisp
(string-to-char "abc")
#+END_SRC

#+RESULTS:
: 97

#+BEGIN_SRC elisp
(list (string-to-char (string ?\0))
      (string-to-char ""))
#+END_SRC

#+RESULTS:
: (0 0)

* string-to-list

#+BEGIN_SRC elisp
(string-to-list "abc")
#+END_SRC

#+RESULTS:
: (97 98 99)

* string-to-multibyte

#+BEGIN_SRC elisp
;; Î», #x3bb, #xCE #xBB
(string-to-multibyte "\u03BB")
#+END_SRC

#+RESULTS:
: "Î»"

* string-to-number

#+BEGIN_SRC elisp
(string-to-number "42")
#+END_SRC

#+RESULTS:
: 42

#+BEGIN_SRC elisp
(string-to-number "2A" 16)
#+END_SRC

#+RESULTS:
: 42

* string-to-syntax

#+BEGIN_SRC elisp
(string-to-syntax "()")
#+END_SRC

#+RESULTS:
: (4 . 41)

* string-to-unibyte

#+BEGIN_SRC elisp
;; FIXME: I don't understand this function
#+END_SRC

* string-to-vector

#+BEGIN_SRC elisp
(string-to-vector "hello")
#+END_SRC

#+RESULTS:
: [104 101 108 108 111]

* string-trim
:PROPERTIES:
:added:    24.4
:changes:  26.1 The optional TRIM-LEFT and TRIM-RIGHT arguments are added.
:END:

#+BEGIN_SRC elisp
(string-trim " hello ")
#+END_SRC

#+RESULTS:
: "hello"

* string-trim-left
:PROPERTIES:
:added:    24.4
:changes:  26.1 The optional REGEXP argument is added.
:END:

#+BEGIN_SRC elisp
(string-trim-left " hello ")
#+END_SRC

#+RESULTS:
: "hello "

* string-trim-right
:PROPERTIES:
:added:    24.4
:changes:  26.1 The optional REGEXP argument is added.
:END:

#+BEGIN_SRC elisp
(string-trim-right " hello ")
#+END_SRC

#+RESULTS:
: " hello"

* string-version-lessp
:PROPERTIES:
:added:    26.1
:END:

#+BEGIN_SRC elisp
(string-version-lessp "foo2.png" "foo12.png")
#+END_SRC

#+RESULTS:
: t

* string-width

#+BEGIN_SRC elisp
(string-width "ä½ å¥½ï¼Œä¸–ç•Œï¼")
#+END_SRC

#+RESULTS:
: 12

* string<

#+BEGIN_SRC elisp
(string< "abc" "abd")
#+END_SRC

#+RESULTS:
: t

* string=

#+BEGIN_SRC elisp
(string= "foo" "foo")
#+END_SRC

#+RESULTS:
: t

* string>
:PROPERTIES:
:added:    25.1
:END:

#+BEGIN_SRC elisp
(string> "abd" "abc")
#+END_SRC

#+RESULTS:
: t

* stringp

#+BEGIN_SRC elisp
(stringp "")
#+END_SRC

#+RESULTS:
: t

* subr-arity

#+BEGIN_SRC elisp
(subr-arity (symbol-function 'message))
#+END_SRC

#+RESULTS:
: (1 . many)

* subrp

#+BEGIN_SRC elisp
(subrp (symbol-function 'message))
#+END_SRC

#+RESULTS:
: t

* subst-char-in-region

#+BEGIN_SRC elisp
(with-temp-buffer
  (insert "/Users/xcy/.emacs.d/init.el")
  (subst-char-in-region (point-min) (point-max) ?/ ?!)
  (buffer-string))
#+END_SRC

#+RESULTS:
: "!Users!xcy!.emacs.d!init.el"

* subst-char-in-string

#+BEGIN_SRC elisp
(subst-char-in-string ?/ ?! "/Users/xcy/.emacs.d/init.el")
#+END_SRC

#+RESULTS:
: "!Users!xcy!.emacs.d!init.el"

* substitute-command-keys

#+BEGIN_SRC elisp
(substitute-command-keys "To save a file, type \\[save-buffer].")
#+END_SRC

#+RESULTS:
: "To save a file, type C-x C-s."

* substitute-in-file-name

#+BEGIN_SRC elisp
(substitute-in-file-name "$HOME/.vimrc")
#+END_SRC

#+RESULTS:
: "/Users/xcy/.vimrc"

* substring

#+BEGIN_SRC elisp
(substring "abcdefg" 0 3)
#+END_SRC

#+RESULTS:
: "abc"

#+BEGIN_SRC elisp
;; Get the first and last character in a non-empty string
(list :first (substring "abcdefg" 0 1)
      :last  (substring "abcdefg" -1))
#+END_SRC

#+RESULTS:
: (:first "a" :last "g")

* substring-no-properties

#+BEGIN_SRC elisp
(substring-no-properties (propertize "hello" 'face 'italic))
#+END_SRC

#+RESULTS:
: "hello"

* suspend-emacs

#+BEGIN_SRC elisp
;; Emacs -> Vim -> Emacs
(suspend-emacs "vim ; fg")
#+END_SRC

* svg-circle

#+BEGIN_SRC elisp
(let ((svg (svg-create 100 100)))
  (svg-circle svg 50 50 50 :fill-color "red")
  svg)
#+END_SRC

#+RESULTS:
#+BEGIN_EXAMPLE
(svg
 ((width . 100)
  (height . 100)
  (version . "1.1")
  (xmlns . "http://www.w3.org/2000/svg"))
 (circle
  ((cx . 50)
   (cy . 50)
   (r . 50)
   (fill . "red"))))
#+END_EXAMPLE

* svg-create

#+BEGIN_SRC elisp
(svg-create 100 100)
#+END_SRC

#+RESULTS:
: (svg
:  ((width . 100)
:   (height . 100)
:   (version . "1.1")
:   (xmlns . "http://www.w3.org/2000/svg")))

* svg-gradient

#+BEGIN_SRC elisp
(let ((svg (svg-create 400 400)))
  (svg-gradient svg "gradient1" 'linear '((0 . "red") (100 . "blue")))
  (svg-circle svg 200 200 100 :gradient "gradient1")
  svg)
#+END_SRC

#+RESULTS:
#+BEGIN_EXAMPLE
(svg
 ((width . 400)
  (height . 400)
  (version . "1.1")
  (xmlns . "http://www.w3.org/2000/svg"))
 (defs nil
   (linearGradient
    ((id . "gradient1")
     (x1 . 0)
     (x2 . 0)
     (y1 . 0)
     (y2 . 1))
    (stop
     ((offset . "0%")
      (stop-color . "red")))
    (stop
     ((offset . "100%")
      (stop-color . "blue")))))
 (circle
  ((cx . 200)
   (cy . 200)
   (r . 100)
   (x1 . 0)
   (x2 . 0)
   (y1 . 0)
   (y2 . 1)
   (fill . "url(#gradient1)"))))
#+END_EXAMPLE

* svg-image

#+BEGIN_SRC elisp
(svg-image (svg-create 100 100))
#+END_SRC

#+RESULTS:
: (image :type svg :data "<svg width=\"100\" height=\"100\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\"></svg>" :scale 1)

* svg-insert-image

#+BEGIN_SRC elisp
(let ((svg (svg-create 300 200)))
  (svg-rectangle svg 0 0 "100%" "100%" :fill-color "red")
  (svg-circle svg 150 100 80 :fill-color "green")
  (svg-text svg "SVG"
            :font-size 60
            :text-anchor "middle"
            :x 150
            :y 125
            :fill-color "white")
  (with-current-buffer (generate-new-buffer "*SVG*")
    (svg-insert-image svg)
    (display-buffer (current-buffer)))
  nil)
#+END_SRC

#+RESULTS:
: nil

* svg-line

#+BEGIN_SRC elisp
(let ((svg (svg-create 100 100)))
  (svg-line svg 0 0 100 100 :stroke-color "red")
  svg)
#+END_SRC

#+RESULTS:
#+BEGIN_EXAMPLE
(svg
 ((width . 100)
  (height . 100)
  (version . "1.1")
  (xmlns . "http://www.w3.org/2000/svg"))
 (line
  ((x1 . 0)
   (x2 . 100)
   (y1 . 0)
   (y2 . 100)
   (stroke . "red"))))
#+END_EXAMPLE

* svg-print

#+BEGIN_SRC elisp
(with-temp-buffer
  (svg-print (svg-create 100 100))
  (buffer-string))
#+END_SRC

#+RESULTS:
: "<svg width=\"100\" height=\"100\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\"></svg>"

* svg-rectangle

#+BEGIN_SRC elisp
(let ((svg (svg-create 100 100)))
  (svg-rectangle svg 0 0 "100%" "100%" :fill-color "red")
  svg)
#+END_SRC

#+RESULTS:
#+BEGIN_EXAMPLE
(svg
 ((width . 100)
  (height . 100)
  (version . "1.1")
  (xmlns . "http://www.w3.org/2000/svg"))
 (rect
  ((width . "100%")
   (height . "100%")
   (x . 0)
   (y . 0)
   (fill . "red"))))
#+END_EXAMPLE

* svg-remove

#+BEGIN_SRC elisp
(let ((svg (svg-create 100 100)))
  (svg-line svg 0 0 100 100 :stroke-color "red" :id "line1")
  (svg-remove svg "line1")
  svg)
#+END_SRC

#+RESULTS:
: (svg
:  ((width . 100)
:   (height . 100)
:   (version . "1.1")
:   (xmlns . "http://www.w3.org/2000/svg")))

* svg-text

#+BEGIN_SRC elisp
(let ((svg (svg-create 300 200)))
  (svg-text
   svg "SVG"
   :font-size 60
   :text-anchor "middle"
   :x 150
   :y 125
   :fill-color "white")
  svg)
#+END_SRC

#+RESULTS:
#+BEGIN_EXAMPLE
(svg
 ((width . 300)
  (height . 200)
  (version . "1.1")
  (xmlns . "http://www.w3.org/2000/svg"))
 (text
  ((y . 125)
   (x . 150)
   (text-anchor . "middle")
   (font-size . 60)
   (fill . "white"))
  "SVG"))
#+END_EXAMPLE

* symbol-file
:PROPERTIES:
:changes:  29.1 The optional NATIVE-P argument is added.
:END:

#+BEGIN_SRC elisp
(symbol-file 'pcase)
#+END_SRC

#+RESULTS:
: "/Users/xcy/src/emacs-mac/lisp/emacs-lisp/pcase.elc"

* symbol-function

#+BEGIN_SRC elisp
(symbol-function '+)
#+END_SRC

#+RESULTS:
: #<subr +>

* symbol-name

#+BEGIN_SRC elisp
(symbol-name 'foo)
#+END_SRC

#+RESULTS:
: "foo"

* symbol-plist

#+BEGIN_SRC elisp
(symbol-plist 'arith-error)
#+END_SRC

#+RESULTS:
: (error-conditions
:  (arith-error error)
:  error-message "Arithmetic error")

* symbol-value

#+BEGIN_SRC elisp
(symbol-value (intern "emacs-version"))
#+END_SRC

#+RESULTS:
: "26.1"

* symbolp

#+BEGIN_SRC elisp
(symbolp 'foo)
#+END_SRC

#+RESULTS:
: t

* syntax-after

#+BEGIN_SRC elisp
(with-temp-buffer
  (insert "()")
  ;; the temporarily buffer uses standard-syntax-table
  (syntax-after (point-min)))

;; (string-to-syntax "()")
;; => (4 . 41)
#+END_SRC

#+RESULTS:
: (4 . 41)

* syntax-class

#+BEGIN_SRC elisp
(with-temp-buffer
  (insert "()")
  (syntax-class (syntax-after (point-min))))

;; (string-to-syntax "(")
;; => (4)
#+END_SRC

#+RESULTS:
: 4

* syntax-class-to-char
:PROPERTIES:
:added:    28.1
:END:

#+BEGIN_SRC elisp
(string (syntax-class-to-char 2))
#+END_SRC

#+RESULTS:
: "w"

* system-name

#+BEGIN_SRC elisp
(system-name)
#+END_SRC

#+RESULTS:
: "Chunyangs-MacBook-Air.local"

* take
:PROPERTIES:
:added:    29.1
:END:

#+BEGIN_SRC elisp
(take 2 (list 1 2 3 4))
#+END_SRC

#+RESULTS:
: (1 2)

* tan

#+BEGIN_SRC elisp
(tan (/ float-pi 4))
#+END_SRC

#+RESULTS:
: 0.9999999999999999

* temporary-file-directory
:PROPERTIES:
:added:    26.1
:END:

#+BEGIN_SRC elisp
(list :local
      (temporary-file-directory)
      :remote
      (let ((default-directory "/ssh:root@192.168.8.1:"))
        (temporary-file-directory)))
#+END_SRC

#+RESULTS:
: (:local "/var/folders/7f/s191h4q97p90374yw15ssrs00000gn/T/" :remote "/ssh:root@192.168.8.1:/tmp")

* terminal-list

#+BEGIN_SRC elisp
(terminal-list)
#+END_SRC

#+RESULTS:
: (#<terminal 1 on Mac>)

* terminal-name

#+BEGIN_SRC elisp
(terminal-name)
#+END_SRC

#+RESULTS:
: "Mac"

* terpri

#+BEGIN_SRC elisp :results output
(terpri)
#+END_SRC

#+RESULTS:
: "\n"

* test-completion

#+BEGIN_SRC elisp
(test-completion "bar" '("foo" "bar" "baz"))
#+END_SRC

#+RESULTS:
: t

* text-property-any

#+BEGIN_SRC elisp
(let ((s (propertize
          (concat (propertize "alice" 'sender t)
                  (propertize " => " 'separator t)
                  (propertize "bob" 'receiver t))
          'message t)))
  (text-property-any 0 (length s) 'separator t s))
#+END_SRC

#+RESULTS:
: 5

* text-property-not-all

#+BEGIN_SRC elisp
(let ((s (propertize
          (concat (propertize "alice" 'sender t)
                  (propertize " => " 'separator t)
                  (propertize "bob" 'receiver t))
          'message t)))
  (text-property-not-all 0 (length s) 'sender t s))
#+END_SRC

#+RESULTS:
: 5

* text-property-search-backward
:PROPERTIES:
:added:    27.1
:END:

#+BEGIN_SRC elisp
(with-temp-buffer
  (insert (format "<< %s, %s, %s >>"
                  (propertize "foo" 'face 'bold)
                  (propertize "bar" 'face 'italic)
                  (propertize "baz" 'face 'bold)))
  (cl-loop with match
           while (setq match (text-property-search-backward 'face 'bold t))
           collect (buffer-substring (prop-match-beginning match)
                                     (prop-match-end match))))
#+END_SRC

#+RESULTS:
: (#("baz" 0 3
:    (face bold))
:  #("foo" 0 3
:    (face bold)))

* text-property-search-forward
:PROPERTIES:
:added:    27.1
:END:

#+BEGIN_SRC elisp
(with-temp-buffer
  (insert
   (replace-regexp-in-string
    (rx (or "bold" "italic"))
    (lambda (s)
      (pcase s
        ("bold" (propertize "bold" 'face 'bold))
        ("italic" (propertize "italic" 'face 'italic))))
    "This is a bold and here's bolditalic and this is the end."))
  (goto-char (point-min))
  (cl-loop with match
           while (setq match (text-property-search-forward 'face nil nil))
           collect (buffer-substring (prop-match-beginning match)
                                     (prop-match-end match))))
#+END_SRC

#+RESULTS:
: (#("bold" 0 4
:    (face bold))
:  #("bold" 0 4
:    (face bold))
:  #("italic" 0 6
:    (face italic)))

* textsec-suspicious-p
:PROPERTIES:
:added:    29.1
:END:

#+BEGIN_SRC elisp
(textsec-suspicious-p "https://Ð°pple.com" 'url)
#+END_SRC

#+RESULTS:
: "`Ð°pple.com' mixes characters from different scripts in suspicious ways"

* thing-at-point
:PROPERTIES:
:changes:  28.1 New 'thing-at-point' target: 'existing-filename' and 'string'.
:changes+:  28.1 New variable 'thing-at-point-provider-alist'.
:END:

#+BEGIN_SRC elisp :eval no
(thing-at-point 'symbol)
#+END_SRC

* thing-at-point-looking-at

#+BEGIN_SRC elisp
(with-temp-buffer
  (insert "Today is <2019-10-30>.")
  ;;       123456789abcdef
  (goto-char #xf)
  (when (thing-at-point-looking-at
         (rx (+ (in "0-9-")))
         ;; limit to current line
         (max (- (point) (line-beginning-position))
              (- (line-end-position) (point))))
    (match-string 0)))
#+END_SRC

#+RESULTS:
: "2019-10-30"

* thread-first
:PROPERTIES:
:added:    25.1
:END:

#+BEGIN_SRC elisp
(thread-first 5
  (+ 20)
  (/ 25)
  -
  (+ 40))
#+END_SRC

#+RESULTS:
: 39

* thread-join

#+BEGIN_SRC elisp
(thread-join
 (make-thread
  (lambda ()
    (sit-for 3))))
#+END_SRC

#+RESULTS:
: nil

* thread-last
:PROPERTIES:
:added:    25.1
:END:

#+BEGIN_SRC elisp
(thread-last 5
  (+ 20)
  (/ 25)
  -
  (+ 40))
#+END_SRC

#+RESULTS:
: 39

* threadp

#+BEGIN_SRC elisp
(threadp (current-thread))
#+END_SRC

#+RESULTS:
: t

* thunk-delay

#+BEGIN_SRC elisp :lexical t
(let ((delayed (thunk-delay (message "this message is delayed"))))
  (thunk-force delayed))
#+END_SRC

#+RESULTS:
: "this message is delayed"

* thunk-evaluated-p

#+BEGIN_SRC elisp :lexical t
(let ((delayed (thunk-delay (message "this message is delayed"))))
  (thunk-force delayed)
  (thunk-evaluated-p delayed))
#+END_SRC

#+RESULTS:
: t

* thunk-force

#+BEGIN_SRC elisp :lexical t
(let ((x 1))
  (let ((delayed (thunk-delay (setq x (1+ x)))))
    (list x
          (thunk-force delayed)
          (thunk-force delayed)
          (thunk-force delayed))))
#+END_SRC

#+RESULTS:
: (1 2 2 2)

* thunk-let
:PROPERTIES:
:added:    27.1
:END:

#+BEGIN_SRC elisp :lexical t
(thunk-let ((x (/ 1 0)))
  42)
#+END_SRC

#+RESULTS:
: 42

* thunk-let*
:PROPERTIES:
:added:    27.1
:END:

#+BEGIN_SRC elisp :lexical t :results drawer output
(thunk-let* ((x (prog2 (print "Calculating x...")
                    (+ 1 1)
                  (print "Finished calculating x")))
             (y (prog2 (print "Calculating y...")
                    (+ x 1)
                  (print "Finished calculating y")))
             (z (prog2 (print "Calculating z...")
                    (+ y 1)
                  (print "Finished calculating z")))
             (a (prog2 (print "Calculating a...")
                    (+ z 1)
                  (print "Finished calculating a"))))
  (print (* z x)))
#+END_SRC

#+RESULTS:
:RESULTS:

"Calculating z..."

"Calculating y..."

"Calculating x..."

"Finished calculating x"

"Finished calculating y"

"Finished calculating z"

8
:END:

* time-add

#+BEGIN_SRC elisp
(time-add nil 3600)
#+END_SRC

#+RESULTS:
: (23532 41872 521709 0)

* time-convert
:PROPERTIES:
:added:    27.1
:changes:  29.1 The FORM argument of 'time-convert' is mandatory.
:END:

#+BEGIN_SRC elisp
(time-convert (current-time) 'integer)
#+END_SRC

#+RESULTS:
: 1577874377

* time-equal-p
:PROPERTIES:
:added:    27.1
:END:

#+BEGIN_SRC elisp
(time-equal-p
 (encode-time '(29 31 17 30 4 2019 2 t 7200))
 '(23752 27217))
#+END_SRC

#+RESULTS:
: t

* time-less-p

#+BEGIN_SRC elisp
(time-less-p before-init-time after-init-time)
#+END_SRC

#+RESULTS:
: t

* time-subtract

#+BEGIN_SRC elisp
(let ((t1 (current-time)))
  (sit-for 1)
  (message "Elapsed time: %fs"
           (float-time (time-subtract nil t1))))
#+END_SRC

#+RESULTS:
: "Elapsed time: 1.006051s"

* time-to-day-in-year

#+BEGIN_SRC elisp
(time-to-day-in-year (current-time))
#+END_SRC

#+RESULTS:
: 319

* time-to-days

#+BEGIN_SRC elisp
(time-to-days (current-time))
#+END_SRC

#+RESULTS:
: 737013

* time-to-seconds

#+BEGIN_SRC elisp
(time-to-seconds)
#+END_SRC

#+RESULTS:
: 1542230349.328713

* timerp

#+BEGIN_SRC elisp
(timerp (car timer-list))
#+END_SRC

#+RESULTS:
: t

* tooltip-show

#+BEGIN_SRC elisp
(tooltip-show "Emacs is addictive!")
#+END_SRC

#+RESULTS:
: nil

* tq-close

#+BEGIN_SRC elisp
(let ((tq (tq-create (start-process "cat" "*cat*" "cat"))))
  (tq-close tq))
#+END_SRC

#+RESULTS:
: t

* tq-create

#+BEGIN_SRC elisp
(tq-create (start-process "cat" "*cat*" "cat"))
#+END_SRC

#+RESULTS:
: (nil #<process cat> . #<buffer  tq-temp-cat>)

* tq-enqueue

#+BEGIN_SRC elisp :results silent
(let ((tq (tq-create (start-process "upcase" "*upcase*" "tr" "a-z" "A-Z"))))
  (tq-enqueue tq
              (concat user-full-name "\n")
              "^$"
              nil
              (lambda (_ response)
                (message "Result: %s" response)))
  (sit-for .1)
  (tq-close tq))
#+END_SRC

* translate-region

#+BEGIN_SRC elisp
(with-temp-buffer
  (insert "Hello World")
  ;; Reverse case, a -> A and A -> a
  (translate-region
   (point-min)
   (point-max)
   (apply #'string
          (mapcar (lambda (char)
                    (cond ((<= ?a char ?z) (- char 32))
                          ((<= ?A char ?Z) (+ char 32))
                          (t char)))
                  ;; ASCII code range
                  (number-sequence 0 255))))
  (buffer-string))
#+END_SRC

#+RESULTS:
: "hELLO wORLD"

* transpose-regions

#+BEGIN_SRC elisp
(with-temp-buffer
  (let (beg1 end1 beg2 end2)
    (insert "hello" ?\n
            "world" ?\n)
    (goto-char (point-min))
    (setq beg1 (line-beginning-position)
          end1 (line-end-position))

    (forward-line 1)
    (setq beg2 (line-beginning-position)
          end2 (line-end-position))
    (transpose-regions beg1 end1
                       beg2 end2)
    (buffer-string)))
#+END_SRC

#+RESULTS:
: "world\nhello\n"

* treesit-available-p
:PROPERTIES:
:added:    29.1
:END:

#+BEGIN_SRC elisp
(treesit-available-p)
#+END_SRC

#+RESULTS:
: t

* treesit-language-abi-version
:PROPERTIES:
:added:    29.1
:END:

#+BEGIN_SRC elisp
(treesit-language-abi-version 'bash)
#+END_SRC

#+RESULTS:
: 14

* treesit-language-available-p
:PROPERTIES:
:added:    29.1
:END:

#+BEGIN_SRC elisp
(treesit-language-available-p 'bash)
#+END_SRC

#+RESULTS:
: t

* treesit-library-abi-version
:PROPERTIES:
:added:    29.1
:END:

#+BEGIN_SRC elisp
(list (treesit-library-abi-version) (treesit-library-abi-version t))
#+END_SRC

#+RESULTS:
: (14 13)

* treesit-parse-string
:PROPERTIES:
:added:    29.1
:END:

#+BEGIN_SRC elisp
(treesit-parse-string "<h1>hi</h1>" 'html)
#+END_SRC

#+RESULTS:
: #<treesit-node fragment in 1-12>

* truncate

#+BEGIN_SRC elisp
(truncate 1.2)
#+END_SRC

#+RESULTS:
: 1

* truncate-string-to-width

#+BEGIN_SRC elisp
(truncate-string-to-width "magit-diff: elisp-demos" 18 nil nil t)
#+END_SRC

#+RESULTS:
: "magit-diff: eli..."

* try-completion

#+BEGIN_SRC elisp
(try-completion "b" '("foo" "baz" "bar"))
#+END_SRC

#+RESULTS:
: "ba"

* type-of

#+BEGIN_SRC elisp
(type-of 42)
#+END_SRC

#+RESULTS:
: integer

#+BEGIN_SRC elisp :results raw table :colnames '("Object" "Type")
(mapcar (lambda (object)
          (list object (type-of object)))
        (list 42
              float-pi
              nil
              (cons 1 2)
              "This is a string"
              [1 2 3]
              (start-process "pwd" nil "pwd")))
#+END_SRC

#+RESULTS:
| Object            | Type    |
|-------------------+---------|
| 42                | integer |
| 3.141592653589793 | float   |
| nil               | symbol  |
| (1 . 2)           | cons    |
| This is a string  | string  |
| [1 2 3]           | vector  |
| pwd               | process |

* ucs-names

#+BEGIN_SRC elisp
(hash-table-count (ucs-names))
#+END_SRC

#+RESULTS:
: 43519

#+BEGIN_SRC elisp
(mapcar
 #'string
 (mapcar
  #'cdr
  (map-filter
   (lambda (char-name char-code)
     (string-prefix-p "SMILING FACE " char-name))
   (ucs-names))))
#+END_SRC

#+RESULTS:
: ("ðŸ˜ƒ" "ðŸ˜„" "ðŸ˜…" "ðŸ˜†" "ðŸ˜‡" "ðŸ˜ˆ" "ðŸ˜Š" "ðŸ˜" "ðŸ˜Ž" "ðŸ¤­" "ðŸ¥°")

* ucs-normalize-NFC-string

#+BEGIN_SRC elisp
;; (string ?e 769) -> (string ?Ã©)
(ucs-normalize-NFC-string (string ?e 769))
#+END_SRC

#+RESULTS:
: "Ã©"

* ucs-normalize-NFD-string

#+BEGIN_SRC elisp
;; (string ?c ?a ?f ?Ã©) -> (string ?c ?a ?f ?e 769)
(ucs-normalize-NFD-string "cafÃ©")
#+END_SRC

#+RESULTS:
: "cafeÌ"

* ucs-normalize-NFKC-string

#+BEGIN_SRC elisp
(ucs-normalize-NFKC-string "ï¬ƒ")
#+END_SRC

#+RESULTS:
: "ffi"

* ucs-normalize-NFKD-string

#+BEGIN_SRC elisp
(ucs-normalize-NFKD-string "âµ")
#+END_SRC

#+RESULTS:
: "5"

* unibyte-string

#+BEGIN_SRC elisp
;; Î», #x3bb, #xCE #xBB
(string-as-multibyte (unibyte-string #xCE #xBB))
#+END_SRC

#+RESULTS:
: "Î»"

* unintern

#+BEGIN_SRC elisp
(let ((a-obarray (make-vector 3 0)))
  (intern "foo" a-obarray)
  (unintern "foo" a-obarray))
#+END_SRC

#+RESULTS:
: t

* unless

#+BEGIN_SRC elisp
(unless nil 123)
#+END_SRC

#+RESULTS:
: 123

* unwind-protect

#+BEGIN_SRC elisp :eval no
(let ((buffer (get-buffer-create "*temp*")))
  (with-current-buffer buffer
    (unwind-protect
        (foo-bar-baz-aux)
      (kill-buffer buffer))))
#+END_SRC

* upcase

#+BEGIN_SRC elisp
(upcase "Hello World")
#+END_SRC

#+RESULTS:
: "HELLO WORLD"

* upcase-initials

#+BEGIN_SRC elisp
(upcase-initials "The CAT in the hAt")
#+END_SRC

#+RESULTS:
: "The CAT In The HAt"

* url-build-query-string

#+BEGIN_SRC elisp
(url-build-query-string '((name "tom") (age 3)))
#+END_SRC

#+RESULTS:
: "name=tom&age=3"

* url-copy-file

#+BEGIN_SRC elisp
(url-copy-file "http://example.com" "index.html")
#+END_SRC

#+RESULTS:
: t

* url-encode-url
:PROPERTIES:
:added:    24.3
:END:

#+BEGIN_SRC elisp
(url-encode-url "HTTPS://Google.com?q=hello world")
#+END_SRC

#+RESULTS:
: "https://google.com?q=hello%20world"

* url-file-directory

#+BEGIN_SRC elisp
(url-file-directory
 "https://www.google.com/webhp?hl=en&sa=X&ved=0ahUKEwj_5qqF0sngAhXlw4sBHUT3DYcQPAgH")
#+END_SRC

#+RESULTS:
: "https://www.google.com/"

* url-file-extension

#+BEGIN_SRC elisp
(url-file-extension "https://github.com/rejeep/evm/blob/master/README.md?rel=xuchunyang")
#+END_SRC

#+RESULTS:
: ".md"

* url-file-nondirectory

#+BEGIN_SRC elisp
(url-file-nondirectory
 "https://www.google.com/webhp?hl=en&sa=X&ved=0ahUKEwj_5qqF0sngAhXlw4sBHUT3DYcQPAgH")
#+END_SRC

#+RESULTS:
: "webhp"

* url-filename

#+BEGIN_SRC elisp
(url-filename (url-generic-parse-url "http://localhost:8000/pkg/io/#CopyN"))
#+END_SRC

#+RESULTS:
: "/pkg/io/"

* url-generic-parse-url

#+BEGIN_SRC elisp
(url-generic-parse-url "https://www.gnu.org/software/emacs/")
#+END_SRC

#+RESULTS:
: #s(url "https" nil nil "www.gnu.org" nil "/software/emacs/" nil nil t nil t t)

* url-hexify-string

#+BEGIN_SRC elisp
(url-hexify-string "hello world")
#+END_SRC

#+RESULTS:
: "hello%20world"

* url-host

#+BEGIN_SRC elisp
(url-host (url-generic-parse-url "http://example.com/index.html"))
#+END_SRC

#+RESULTS:
: "example.com"

* url-http-user-agent-string

#+BEGIN_SRC elisp
(string-trim (url-http-user-agent-string))
#+END_SRC

#+RESULTS:
: "User-Agent: URL/Emacs Emacs/28.2 (nil; aarch64-apple-darwin22.2.0)"

* url-insert-file-contents

#+BEGIN_SRC elisp
(with-temp-buffer
  ;; (info "(url) Disk Caching") is breaking `url-insert-file-contents', so
  ;; disable cache
  (let ((url-request-extra-headers '(("Pragma" . "no-cache"))))
    (url-insert-file-contents "http://example.com"))
  (re-search-forward (rx "<title>" (group (1+ anything)) "</title>"))
  (match-string 1))
#+END_SRC

#+RESULTS:
: "Example Domain"

* url-parse-query-string

#+BEGIN_SRC elisp
(url-parse-query-string "name=tom&age=3")
#+END_SRC

#+RESULTS:
: (("age" "3")
:  ("name" "tom"))

#+BEGIN_SRC elisp
(pcase (url-path-and-query
        (url-generic-parse-url
         "https://www.ldoceonline.com/autocomplete/english/?q=grea&contentType=application%2Fjson%3B+charset%3Dutf-8"))
  (`(,_path . ,query)
   (url-parse-query-string query)))
#+END_SRC

#+RESULTS:
: (("contentType" "application/json;+charset=utf-8")
:  ("q" "grea"))

* url-path-and-query

#+BEGIN_SRC elisp
(url-path-and-query
 (url-generic-parse-url
  "https://www.google.com/webhp?hl=en&sa=X&ved=0ahUKEwj_5qqF0sngAhXlw4sBHUT3DYcQPAgH"))
#+END_SRC

#+RESULTS:
: ("/webhp" . "hl=en&sa=X&ved=0ahUKEwj_5qqF0sngAhXlw4sBHUT3DYcQPAgH")

* url-queue-retrieve

#+BEGIN_SRC elisp
(url-queue-retrieve "http://example.com/"
                    (lambda (status)
                      (message "Status: %s" status)
                      (display-buffer (current-buffer))))
#+END_SRC

#+RESULTS:
: [nil 0 1 0 1 url-queue-check-progress nil idle 0]

* url-recreate-url

#+BEGIN_SRC elisp
(url-recreate-url (url-generic-parse-url "https://www.gnu.org/software/emacs/"))
#+END_SRC

#+RESULTS:
: "https://www.gnu.org/software/emacs/"

* url-retrieve

#+BEGIN_SRC elisp
(url-retrieve "http://example.com"
              (lambda (status start-time)
                (message "The request is completed in %f seconds"
                         (float-time (time-subtract nil start-time)))
                (display-buffer (current-buffer)))
              `(,(current-time))
              'silent
              'inhibit-cookies)
#+END_SRC

#+RESULTS:
: #<buffer  *http example.com:80*-426008>

* url-retrieve-synchronously
:PROPERTIES:
:changes:  26.1 The optional TIMEOUT argument is added.
:END:

#+BEGIN_SRC elisp
(url-retrieve-synchronously "http://example.com/")
#+END_SRC

#+RESULTS:
: #<buffer  *http example.com:80*-771275>

#+BEGIN_SRC elisp
(with-current-buffer (url-retrieve-synchronously "https://api.github.com/status")
  (goto-char url-http-end-of-headers)
  (json-read))
#+END_SRC

#+RESULTS:
: ((message . "GitHub lives! (2018-11-06 21:40:11 -0800) (1)"))

#+BEGIN_SRC elisp :results silent
(let ((url-user-agent (format "%s <%s>" user-full-name user-mail-address))
      (url-request-method "POST")
      (url-request-extra-headers '(("Content-Type" . "application/json")))
      (url-request-data (encode-coding-string
                         (json-encode '((id . 123)
                                        ("en" . "hello world")
                                        ("zh" . "ä½ å¥½ï¼Œä¸–ç•Œ")))
                         'utf-8)))
  (pop-to-buffer (url-retrieve-synchronously "http://httpbin.org/post")))
#+END_SRC

* url-target

#+BEGIN_SRC elisp
(url-target
 (url-generic-parse-url "http://localhost:8000/pkg/io/#CopyN"))
#+END_SRC

#+RESULTS:
: "CopyN"

* url-unhex-string

#+BEGIN_SRC elisp
(url-unhex-string "hello%20world")
#+END_SRC

#+RESULTS:
: "hello world"

* user-error
:PROPERTIES:
:added:    24.3
:END:

#+BEGIN_SRC elisp
(user-error "It's all your fault, not mime")
#+END_SRC

* user-full-name

#+BEGIN_SRC elisp
(let ((user-full-name "Hello Kitty"))
  (user-full-name))
#+END_SRC

#+RESULTS:
: "Hello Kitty"

* user-login-name

#+BEGIN_SRC elisp
(user-login-name)
#+END_SRC

#+RESULTS:
: "xcy"

* user-real-login-name

#+BEGIN_SRC elisp
(user-real-login-name)
#+END_SRC

#+RESULTS:
: "xcy"

* user-real-uid

#+BEGIN_SRC elisp
(user-real-uid)
#+END_SRC

#+RESULTS:
: 501

* user-uid

#+BEGIN_SRC elisp
(user-uid)
#+END_SRC

#+RESULTS:
: 501

* vconcat

#+BEGIN_SRC elisp
(vconcat '(a b) "cd" [e f])
#+END_SRC

#+RESULTS:
: [a b 99 100 e f]

* vector

#+BEGIN_SRC elisp
(vector 1 2 3)
#+END_SRC

#+RESULTS:
: [1 2 3]

* vectorp

#+BEGIN_SRC elisp
(vectorp [1 2 3])
#+END_SRC

#+RESULTS:
: t

* verify-visited-file-modtime

#+BEGIN_SRC elisp
(verify-visited-file-modtime)
#+END_SRC

#+RESULTS:
: t

* version-to-list

#+BEGIN_SRC elisp
(version-to-list "26.1")
#+END_SRC

#+RESULTS:
: (26 1)

* version<

#+BEGIN_SRC elisp
(version< "24.5" "26.1")
#+END_SRC

#+RESULTS:
: t

* version<=

#+BEGIN_SRC elisp
(version<= "24.5" "26.1")
#+END_SRC

#+RESULTS:
: t

* version=

#+BEGIN_SRC elisp
(version= "24.5" "24.5")
#+END_SRC

#+RESULTS:
: t

* visible-frame-list

#+BEGIN_SRC elisp
(visible-frame-list)
#+END_SRC

#+RESULTS:
: (#<frame /Users/xcy/src/elisp-demos/elisp-demos.org 0x1049a21e8>)

* websocket-open

#+BEGIN_SRC elisp :results silent
(websocket-open
 "wss://echo.websocket.org/"
 :on-open
 (lambda (ws)
   (message "Connected")
   (websocket-send-text ws "Hello, WebSocket!"))
 :on-message
 (lambda (ws frame)
   (message "Receive: %s" (websocket-frame-text frame))
   (websocket-close ws))
 :on-close
 (lambda (ws)
   (message "Closed")))
#+END_SRC

* websocket-server

#+BEGIN_SRC elisp :lexical t :results silent
(let ((wss
       (websocket-server
        8888
        :on-open
        (lambda (ws)
          (message "[Server] on-open"))
        :on-message
        (lambda (ws frame)
          (message "[Server] on-message")
          (message "[Server] Received %S from client" (websocket-frame-text frame))
          (message "[Server] Sending %S to client" (upcase (websocket-frame-text frame)))
          (websocket-send-text ws (upcase (websocket-frame-text frame))))
        :on-close
        (lambda (ws)
          (message "[Server] on-close")))))
  (websocket-open
   "ws://localhost:8888/"
   :on-open
   (lambda (ws)
     (message "[Client] on-open")
     (message "[Client] Sending %S to server" "Hello, WebSocket!")
     (websocket-send-text ws "Hello, WebSocket!"))
   :on-message
   (lambda (ws frame)
     (message "[Client] Received %S from server" (websocket-frame-text frame))
     ;; Close the client
     (websocket-close ws))
   :on-close
   (lambda (ws)
     (message "[Client] on-close")))
  (run-with-idle-timer
   1 nil
   (lambda ()
     (message "Cleanup, closing the server")
     (websocket-server-close wss))))
#+END_SRC

* when

#+BEGIN_SRC elisp
(when t 123)
#+END_SRC

#+RESULTS:
: 123

#+BEGIN_SRC elisp
(when nil 123)
#+END_SRC

#+RESULTS:
: nil

* when-let
:PROPERTIES:
:added:    25.1
:END:

#+BEGIN_SRC elisp
(when-let ((match-index (string-match "d" "abcd")))
  (+ match-index 2))
#+END_SRC

#+RESULTS:
: 5

* when-let*
:PROPERTIES:
:added:    26.1
:END:

#+BEGIN_SRC elisp
(when-let* ((match-index (string-match "d" "abcd")))
  (+ match-index 2))
#+END_SRC

#+RESULTS:
: 5

* where-is-internal

#+BEGIN_SRC elisp
(where-is-internal 'save-buffer)
#+END_SRC

#+RESULTS:
: ([24 19]
:  [menu-bar file save-buffer])

#+BEGIN_SRC elisp
(mapcar #'key-description (where-is-internal 'save-buffer))
#+END_SRC

#+RESULTS:
: ("C-x C-s" "<menu-bar> <file> <save-buffer>")

* while

#+BEGIN_SRC elisp
(let ((i 1)
      (sum 0))
  (while (<= i 100)
    (setq sum (+ sum i))
    (setq i (+ i 1)))
  sum)
#+END_SRC

#+RESULTS:
: 5050

* widen

#+BEGIN_SRC elisp
(with-temp-buffer
  (insert "hello world")
  (narrow-to-region 1 6)
  `(:narrowed
    ,(buffer-string)
    ,@(widen)
    :widened
    ,(buffer-string)))
#+END_SRC

#+RESULTS:
: (:narrowed "hello" :widened "hello world")

* window-bump-use-time
:PROPERTIES:
:added:    28.1
:END:

#+BEGIN_SRC elisp
(window-bump-use-time)
#+END_SRC

#+RESULTS:
: nil

* window-frame

#+BEGIN_SRC elisp
(window-frame)
#+END_SRC

#+RESULTS:
: #<frame /Users/xcy/src/elisp-demos/elisp-demos.org 0x10495b9c8>

* window-list

#+BEGIN_SRC elisp
(window-list)
#+END_SRC

#+RESULTS:
: (#<window 111 on elisp-demos.org> #<window 119 on *scratch*>)

* window-live-p

#+BEGIN_SRC elisp
(window-live-p (selected-window))
#+END_SRC

#+RESULTS:
: t

* window-margins

#+BEGIN_SRC elisp
(window-margins)
#+END_SRC

#+RESULTS:
: (nil)

* window-minibuffer-p

#+BEGIN_SRC elisp
(window-minibuffer-p (minibuffer-window))
#+END_SRC

#+RESULTS:
: t

* window-parent

#+BEGIN_SRC elisp
(window-parent)
#+END_SRC

#+RESULTS:
: #<window 43>

* window-valid-p

#+BEGIN_SRC elisp
(window-valid-p (selected-window))
#+END_SRC

#+RESULTS:
: t

* windowp

#+BEGIN_SRC elisp
(windowp (selected-window))
#+END_SRC

#+RESULTS:
: t

* with-current-buffer

#+BEGIN_SRC elisp
(with-current-buffer "*Messages*"
  (current-buffer))
#+END_SRC

#+RESULTS:
: #<buffer *Messages*>

* with-delayed-message
:PROPERTIES:
:added:    29.1
:END:

#+BEGIN_SRC elisp
(with-delayed-message (1 "This takes too long")
  (sleep-for 1.2))
#+END_SRC

* with-demoted-errors

#+BEGIN_SRC elisp
(with-demoted-errors "Error: %S"
  (/ 1 0))
#+END_SRC

#+RESULTS:
: nil

* with-eval-after-load

#+BEGIN_SRC elisp
(with-eval-after-load 'dired
  (require 'dired-x))
#+END_SRC

#+RESULTS:
: dired-x

* with-help-window

#+BEGIN_SRC elisp
(with-help-window "*My Help Window*"
  (princ "Used keymap is help-mode-map:")
  (terpri)
  (terpri)
  (prin1 help-mode-map)
  (terpri))
#+END_SRC

#+RESULTS:
: t

* with-memoization
:PROPERTIES:
:added:    29.1
:END:

#+BEGIN_SRC elisp
(let* ((cache nil)
       (func (lambda ()
               (with-memoization cache
                 (with-current-buffer
                     (url-retrieve-synchronously "https://example.com/")
                   (current-time))))))
  (equal (funcall func)
         (funcall func)))
#+END_SRC

#+RESULTS:
: t

* with-output-to-string

#+BEGIN_SRC elisp
(with-output-to-string
  (princ "Hello World"))
#+END_SRC

#+RESULTS:
: "Hello World"

* with-restriction
:PROPERTIES:
:added:    29.1
:END:

#+BEGIN_SRC elisp
(with-temp-buffer
  (insert "hello world")
  (with-restriction 1 6
    (buffer-string)))
#+END_SRC

#+RESULTS:
: "hello"

* with-silent-modifications

#+BEGIN_SRC elisp
(with-temp-buffer
  (insert "hello")
  (set-buffer-modified-p nil)
  (with-silent-modifications
    (add-text-properties (point-min) (point-max) '(display "world")))
  (buffer-modified-p))
#+END_SRC

#+RESULTS:
: nil

* with-slots

#+BEGIN_SRC elisp
(defclass my-color ()
  ((alpha) (red) (green) (blue))
  "A color class.")

(let ((c (my-color)))
  (with-slots (red green blue (a alpha)) c
    (setq red   #x41
          green #x69
          blue  #xE1
          a 1.0))
  c)
#+END_SRC

#+RESULTS:
: #s(my-color 1.0 65 105 225)

* with-sqlite-transaction

#+BEGIN_SRC elisp
;; (require 'sqlite)
(let ((db (sqlite-open)))
  (with-sqlite-transaction db
    (sqlite-execute db "CREATE TABLE users (name TEXT)")
    (sqlite-execute db "INSERT INTO users (name) VALUES ('Tom')")
    (sqlite-execute db "INSERT INTO users (name) VALUES ('Jerry')")
    (sqlite-select db "SELECT * FROM users")))
#+END_SRC

#+RESULTS:
: (("Tom")
:  ("Jerry"))

* with-syntax-table

#+BEGIN_SRC elisp
(list
 (with-syntax-table emacs-lisp-mode-syntax-table
   ;; Comment starters: â€˜<â€™
   (string (char-syntax ?\;)))

 (with-syntax-table text-mode-syntax-table
   ;; Punctuation characters: â€˜.â€™
   (string (char-syntax ?\;))))
#+END_SRC

#+RESULTS:
: ("<" ".")

* with-temp-buffer

#+BEGIN_SRC elisp
(with-temp-buffer
  (insert "hello")
  (insert "world")
  (buffer-string))
#+END_SRC

#+RESULTS:
: "helloworld"

* with-temp-file

#+BEGIN_SRC elisp
(with-temp-file (make-temp-file "elisp-demos-")
  (insert "This will be inserted to the file.\n")
  (insert "Peace.\n")
  42)
#+END_SRC

#+RESULTS:
: 42

* with-temp-message

#+BEGIN_SRC elisp
(progn (message "The original message")
       (sit-for 3)
       (with-temp-message "Hello World"
         (sit-for 3)))
#+END_SRC

#+RESULTS:
: t

* with-timeout

#+BEGIN_SRC elisp
(with-timeout (3 (message "You've not type any key"))
  (read-char "Type some key in 3 seconds"))
#+END_SRC

#+RESULTS:
: "You've not type any key"

* without-restriction
:PROPERTIES:
:added:    29.1
:END:

#+BEGIN_SRC elisp
(with-temp-buffer
  (insert "hello world")
  (with-restriction 1 6
    (without-restriction
      (buffer-string))))
#+END_SRC

#+RESULTS:
: "hello world"

* write-char

#+BEGIN_SRC elisp :results output
(write-char ?a)
#+END_SRC

#+RESULTS:
: "a"

* write-region

#+BEGIN_SRC elisp
(write-region "Hello World\n" nil "/tmp/tmp.txt")
#+END_SRC

#+RESULTS:
: nil

* ws-start

#+BEGIN_SRC elisp
(require 'web-server)

;; http://localhost:8888
(ws-start
 (lambda (request)
   (process-send-string
    (oref request process)
    (let ((body "Hello, World!\n"))
      (concat "HTTP/1.1 200 OK\r\n"
              "Content-Type: text/plain; charset=UTF-8\r\n"
              (format "Content-Length: %d\r\n" (string-bytes body))
              "\r\n"
              body))))
 8888)
#+END_SRC

* x-display-list

#+BEGIN_SRC elisp
(x-display-list)
#+END_SRC

#+RESULTS:
: ("Mac")

* x-popup-dialog

#+BEGIN_SRC elisp
(x-popup-dialog (selected-frame) '("Are you ready?" ("Yes" . :yes) ("No" . :no)))
#+END_SRC

#+RESULTS:
: :yes

* x-popup-menu

#+BEGIN_SRC elisp
(x-popup-menu
 t
 (list "What action?"
       (cons ""
             '(("Copy here" . copy)
               ("Move here" . move)
               ("Link here" . link)
               "--"
               ("Cancel" . nil)))))
#+END_SRC

#+RESULTS:
: copy

* x-server-vendor

#+BEGIN_SRC elisp
(x-server-vendor)
#+END_SRC

#+RESULTS:
: "Apple Inc."

* x-server-version

#+BEGIN_SRC elisp
(x-server-version)
#+END_SRC

#+RESULTS:
: (10 14 5)

* xml-get-children

#+BEGIN_SRC elisp
(with-temp-buffer
  (insert
   "<info>"
   "<user id=\"1\"><name>Bob</name></user>"
   "<user id=\"2\"><name>Joe</name></user>"
   "</info>")
  (let ((x (xml-parse-region)))
    (xml-get-children (assq 'info x) 'user)))
#+END_SRC

#+RESULTS:
: ((user
:   ((id . "1"))
:   (name nil "Bob"))
:  (user
:   ((id . "2"))
:   (name nil "Joe")))

#+BEGIN_SRC elisp
(xml-get-children
 '(info
   nil
   (user nil "Bob")
   (user nil "Joe"))
 'user)
#+END_SRC

#+RESULTS:
: ((user nil "Bob")
:  (user nil "Joe"))

* xml-node-attributes

#+BEGIN_SRC elisp
(xml-node-attributes
 '(user
   ((id . "1"))
   (name nil "Bob")))
#+END_SRC

#+RESULTS:
: ((id . "1"))

* xml-node-children

#+BEGIN_SRC elisp
(xml-node-children
 '(user
   ((id . "1"))
   (name nil "Bob")))
#+END_SRC

#+RESULTS:
: ((name nil "Bob"))

* xml-node-name

#+BEGIN_SRC elisp
(xml-node-name
 '(user
   ((id . "1"))
   (name nil "Bob")))
#+END_SRC

#+RESULTS:
: user

* xml-parse-file

#+BEGIN_SRC elisp
(let ((file (make-temp-file "elisp-demos-")))
  (write-region "<note>hello world!</note>" nil file)
  (unwind-protect
      (xml-parse-file file)
    (delete-file file)))
#+END_SRC

#+RESULTS:
: ((note nil "hello world!"))

* xml-parse-region

#+BEGIN_SRC elisp
(with-temp-buffer
  (insert "\
<?xml version=\"1.0\" encoding=\"UTF-8\"?>
<note>
  <to>Tove</to>
  <from>Jani</from>
  <heading>Reminder</heading>
  <body>Don't forget me this weekend!</body>
</note>")
  (xml-parse-region))
#+END_SRC

#+RESULTS:
: ((note nil "\n  "
:        (to nil "Tove")
:        "\n  "
:        (from nil "Jani")
:        "\n  "
:        (heading nil "Reminder")
:        "\n  "
:        (body nil "Don't forget me this weekend!")
:        "\n"))

* xmlgen

#+BEGIN_SRC elisp :results value raw :wrap SRC html
((lambda (string)
   "Prettify HTML in STRING."
   (with-temp-buffer
     (insert string)
     (html-mode)
     (sgml-pretty-print (point-min) (point-max))
     (buffer-string)))
 (xmlgen '(html
           (head
            (title "Example Domain")
            (meta :charset "utf-8"))
           (body
            (h1 "Example Domain")
            (p "This domain...")
            (p (a :href "http://www.iana.org/domains/example" "More information..."))))))
#+END_SRC

#+RESULTS:
#+BEGIN_SRC html
<html>
  <head>
    <title>Example Domain
    </title>
    <meta charset="utf-8"/>
  </head>
  <body>
    <h1>Example Domain
    </h1>
    <p>This domain...
    </p>
    <p>
      <a href="http://www.iana.org/domains/example">More information...
      </a>
    </p>
  </body>
</html>
#+END_SRC

* xor
:PROPERTIES:
:added:    26.1
:changes:  27.1 Improved and moved from array.el to subr.el.
:END:

#+BEGIN_SRC elisp
(list (xor nil t)
      (xor t nil)
      (xor nil nil)
      (xor t t))
#+END_SRC

#+RESULTS:
: (t t nil nil)

* xr

#+BEGIN_SRC elisp
(xr "\\.\\(?:mp4\\|mp3\\)\\'")
#+END_SRC

#+RESULTS:
: (seq "."
:      (or "mp4" "mp3")
:      eos)

* y-or-n-p

#+BEGIN_SRC elisp
(y-or-n-p "Are you ready? ")
#+END_SRC

#+RESULTS:
: t

* y-or-n-p-with-timeout

#+BEGIN_SRC elisp
(y-or-n-p-with-timeout "Are you ready? " 3 'default)
#+END_SRC

#+RESULTS:
: default

* yes-or-no-p

#+BEGIN_SRC elisp
(yes-or-no-p "Are you ready? ")
#+END_SRC

#+RESULTS:
: t

* zerop

#+BEGIN_SRC elisp
(zerop 0)
#+END_SRC

#+RESULTS:
: t

* zlib-available-p

#+BEGIN_SRC elisp
(zlib-available-p)
#+END_SRC

#+RESULTS:
: t

* zlib-decompress-region

#+BEGIN_SRC elisp
(with-temp-buffer
  (set-buffer-multibyte nil)
  (let ((coding-system-for-read 'binary)
        (coding-system-for-write 'binary))
    (call-process-region "hello" nil "gzip" nil t))
  (when (zlib-decompress-region (point-min) (point-max))
    (buffer-string)))
#+END_SRC

#+RESULTS:
: "hello"
